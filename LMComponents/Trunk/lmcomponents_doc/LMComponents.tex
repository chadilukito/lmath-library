% !TeX program = xelatex
\documentclass[12pt,a4paper,oneside]{report}
\usepackage{fontspec}
\defaultfontfeatures{Ligatures=TeX}
\setmainfont{Crimson}
\setsansfont{Century Gothic}
\setmonofont[Scale=0.8]{DejaVu Sans Mono}
\usepackage[margin=10pt,font=small,labelfont=bf,labelsep=endash]{caption} % figures and tables caption options
\usepackage[top=1in, bottom=1in, left=1.5in, right=1.0in]{geometry}
\usepackage[compact]{titlesec}
\usepackage{gensymb} % provides Celsius, micro and degree commands
\titlespacing*{\chapter}{0pt}{-60pt}{10pt}
\titleformat{\chapter}[display]{\normalfont\LARGE\bfseries}{\chaptertitlename\ \thechapter}{10pt}{}
\titleformat{\section}[hang]{\normalfont\Large\bfseries}{\thesection\ }{0pt}{}
\titleformat{\subsubsection}[block]{\normalfont\large\bfseries} % format for label and text
{} %label (may be counter: \thesection)
{0pt} % distance between label and text, 0 if no label
{}
\titleformat{\paragraph}[runin]{\normalfont\normalsize\bfseries}{}{0pt}{}
\usepackage{amsmath}
\usepackage{xcolor}
\definecolor{darkblue}{RGB}{0,0,128}
\usepackage[xetex]{hyperref}
\hypersetup{
	colorlinks   = true, %Colours links instead of ugly boxes
	urlcolor     = darkblue, %Colour for external hyperlinks
	linkcolor    = darkblue, %Colour of internal links
	citecolor	 = darkblue, %Colour of citations
	pdftitle	 ={LMComponents Reference},
	pdfauthor	 ={Viatcheslav Nesterov},
	pdfsubject	 ={Reference for LMComponents, extension of LMath library},
	pdfkeywords	 ={pascal, object pascal, mathematics, math, library, science, programming, scientific programming}
}
\renewcommand{\labelitemii}{$\bullet$}
\newcommand{\euler}{\mathrm{e}}
\newcommand{\keyword}[1]{\textbf{#1}}
\newcommand{\declarationitem}[1]{{\addfontfeatures{FakeSlant} #1}}
\newcommand{\descriptiontitle}[1]{{\addfontfeatures{FakeSlant}#1}}
\newcommand{\inlineitem}[1]{{\addfontfeatures{FakeBold} #1}}

\newcommand{\code}[1]{\texttt{#1}}  
\setcounter{secnumdepth}{3}
\setcounter{tocdepth}{3}
\begin{document}
\title{LMComponents: object-oriented extension of LMath library}
\author{Viatcheslav Nesterov}
\maketitle
\newpage
\label{toc}\tableofcontents
\newpage
% special variable used for calculating some widths.
\newlength{\tmplength}
\chapter{Unit lmPointsVec}
\label{lmPointsVec}
\index{lmPointsVec}
\section{Description}
\code{TPoints} is a class wrapper around \code{TRealPointVector} (see LMath.pdf, Chapter 2). Its properties X[index] and Y[index] provide access to X and Y fields as to separate arrays of \code{Float}; if the package was compiled with -dDebug setting, range check is done for \code{Index}. However, use of \code{X} and \code{Y} properties has a considerable penalty on performance. Direct access to underlying array \code{TPoints.Points} is provided for use in time-critical code sections, but in general it is safer to use \code{X} and \code{Y} properties.

If \code{Append} procedure is used for adding new points, \code{Count} is adjusted automatically; by exceeding current \code{Capacity}, memory is automatically reallocated.

In addition, many utility methods and properties are provided, such as \code{MaxX, MaxY, MinX, MinY}; \code{RemovePoints} allows to remove subarray from an arbitrary index; \code{constructor Combine} allows to create \code{TPoints} from two vectors of Float; opposite to it, \code{Extract} is a mean to extract \code{X} or \code{Y} as vector of Float; \code{SortX} and \code{SortY} sort \code{Points} as names suggest.
\section{Classes, Interfaces, Objects and Records}
\subsection{ERealPointsException Class}
\label{lmPointsVec.ERealPointsException}
\index{ERealPointsException}
\subsubsection{Hierarchy}
ERealPointsException {$>$} Exception
\subsubsection{Description}
Exception which flags invalid operation with \code{TPoints}.
 
\subsection{TPoints Class}
\label{lmPointsVec.TPoints}
\index{TPoints}
\subsubsection{Hierarchy}
TPoints {$>$} TObject
\subsubsection{Declaration}
\begin{verbatim}
TPoints = class
protected
  function GetBuffer(I: integer): pointer;
  function GetX(ind:integer):Float;
  function GetY(ind:integer):Float;
  procedure SetX(ind:integer; value:Float);
  procedure SetY(ind:integer; value:Float);
  function GetPoint(ind:integer):TRealPoint;
  procedure SetPoint(ind:integer; Value:TRealPoint);
public
  Points:TRealPointVector;
  Capacity:integer;
  Count:integer;
  Index:integer;
  constructor Create(ACapacity:integer);
  constructor Combine(XVector,YVector:TVector; Lb, Ub:integer);
  destructor Destroy; override;
  procedure Append(APoint:TRealPoint);
  function RemovePoints(Ind: integer; ACount:integer):integer;
  function Reallocate(Step:integer):integer;
  procedure FreePoints; virtual;
  procedure AllocatePoints(ACapacity:integer);
  procedure SortX(descending:boolean);
  function MaxX: Float; virtual;
  function MaxY: Float; virtual;
  function MinX: Float; virtual;
  function MinY: Float; virtual;
  function Range: Float; virtual;
  function RangeY: Float; virtual;
  procedure SortY(descending:boolean);
  procedure ExtractX(var AXVector:TVector; Lb, Ub: integer);
  procedure ExtractY(var AYVector:TVector; Lb, Ub: integer);
  property X[I:integer]:Float read GetX write SetX;
  property Y[I:integer]:Float read GetY write SetY;
  property ThePoints[I:integer]:TRealPoint read GetPoint write SetPoint; default;
  property DataBuffer[I:integer]:pointer read GetBuffer;
end;
\end{verbatim}

\subsubsection{Properties}
\begin{itemize}
	\item[\inlineitem{X}\hfill]
	\begin{flushleft}
		\code{public property X[I:integer]: Float;}
	\end{flushleft}
	\item[\descriptiontitle{Description}]
	Shortcut to \code{Points[index].X} with additional range check. By \textit{assigning} X[index], if  \code{Index} $>$ \code{Count-1}, Count is increased to \code{Index+1}. If \code{index} $>$ \code{Capacity} and -dDebug is set, \code{ERealPointException} is raised. 
	
	By reading the field, if -dDebug and \code{index} $>$ \code{Count}, then exception is raised.
	
	Use of this field has, however, penalty on performance; use direct access to \code{Points} array in time-critical procedures. 
	\par  \label{lmPointsVec.TPoints-Y}
	\index{Y}
	\item[\inlineitem{Y}\hfill]
	\begin{flushleft}
		\code{
			public property Y[I:integer]: Float;}
	\end{flushleft}
	\item[\descriptiontitle{Description}]
	Shortcut to \code{Points[index].Y}. See X property above for description of its behaviour. 
	\par  \label{lmPointsVec.TPoints-ThePoints}
	\index{ThePoints}
	\item[\inlineitem{ThePoints}\hfill]
	\begin{flushleft}
		\code{
			public property ThePoints[I:integer]: TRealPoint;}
	\end{flushleft}
	\item[\descriptiontitle{Description}]
	Access to \code{Points} with range-check; behaviour is similar to X and Y properties, as well as performance penalty.
	\par  \label{lmPointsVec.TPoints-DataBuffer}
	\index{DataBuffer}
	\item[\inlineitem{DataBuffer}\hfill]
	\begin{flushleft}
		\code{
			public property DataBuffer[I:integer]: pointer;}
	\end{flushleft}
	Pointer to Points[I]. Useful for fast low-level filling of the data.
\end{itemize}
	
\subsubsection{Fields}
\begin{itemize}
	\label{lmPointsVec.TPoints-Points}
	\index{Points}
	\item[\inlineitem{Points}\hfill]
	\begin{flushleft}
		\code{
			public Points:TRealPointVector;}
	\end{flushleft}
\item[\descriptiontitle{Description}]

This is actual array of data. Public access to it is provided for direct operations in time-critical program sections. Don't forget to use and adjust \code{Count} and \code{Capacity} fields! Outside time-critical sections, use \code{X}, \code{Y} and \code{ThePoints} properties.
	
\par  \label{lmPointsVec.TPoints-Capacity}
\index{Capacity}
	\item[\inlineitem{Capacity}\hfill]
	\begin{flushleft}
		\code{
			public Capacity:integer;}
	\end{flushleft}
	\item[\descriptiontitle{Description}]	
	This is currently \emph{allocated} \code{Points} length. It should not be confused with \code{Count} which shows number of currently \emph{assigned} points (or, to be exact, highest index of assigned element). If new points are added using \code{Append} method, \code{Count} is updated and memory is automatically reallocated as needed.
	  
	\par  \label{lmPointsVec.TPoints-Index}
	\index{Index}
	\item[\inlineitem{Index}\hfill]
	\begin{flushleft}
		\code{
			public Index:integer;}
	\end{flushleft}
	\item[\descriptiontitle{Description}]	
	General use pointer. After call of \hyperref[lmPointsVec.TPoints-MinX]{MinY, MaxY, MinX, MaxX} functions it points to the first element which has corresponding value.
	\par  \end{itemize}
	\par  \label{lmPointsVec.TPoints-Count}
\index{Count}
\begin{itemize}
\item[\inlineitem{Count}\hfill]
\begin{flushleft}
	\code{
		public Count:integer;}
\end{flushleft}
\item[\descriptiontitle{Description}]	
Highest index of assigned element in \code{Points}. It is automatically adjusted when \code{X[index]}, \code{Y[index]} or \code{ThePoints[index]} properties are assigned, when \code{RemovePoints} is used or when \code{Append} procedure is used to add a new point. \code{Append} adds always to \code{Points[Count]} position. Attempt to read beyond \code{Count} raises exception if -dDebug was used. If low-level access to \code{Points} array was used, \code{Count} should be adjusted manually.
\par  \end{itemize}

\subsubsection{Methods}
\paragraph{Create}\hspace*{\fill}
\label{lmPointsVec.TPoints-Create}
\index{Create}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			public constructor Create(ACapacity:integer);}
	\end{flushleft}
	\item[\descriptiontitle{Description}]
	Creates \code{TPoints} object and allocates memory for \code{Points} with \code{Capacity} elements. 
\end{itemize}
\paragraph{Combine}\hspace*{\fill}
\label{lmPointsVec.TPoints-Combine}
\index{Combine}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			public constructor Combine(XVector,YVector:TVector; Lb, Ub:integer);}
	\end{flushleft}
	\item[\descriptiontitle{Description}]
	Creates TPoints object with Points array combined from two arrays of float: \code{XVector} is used to fill \code{X} fields in \code{Points} array; \code{YVector} is for \code{Y} fields. \code{Lb, Ub} are low and upper indexes of the vectors to use. \code{Count} and \code{Capacity} of resulting \code{TPoints} is set to $Ub-Lb$. 
\end{itemize}
\paragraph{Destroy}\hspace*{\fill}

\label{lmPointsVec.TPoints-Destroy}
\index{Destroy}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			public destructor Destroy; override;}
	\end{flushleft}
\end{itemize}
\paragraph{Append}\hspace*{\fill}
\label{lmPointsVec.TPoints-Append}
\index{Append}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			public procedure Append(APoint:TRealPoint);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Appends a point to the end (Count position) and increases Count. If Capacity is exceeded, automatically reallocates more space.
	
\end{itemize}
\paragraph{RemovePoints}\hspace*{\fill}

\label{lmPointsVec.TPoints-RemovePoints}
\index{RemovePoints}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			public function RemovePoints(Ind: integer; ACount:integer):integer;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	removes \code{min(ACount, Count{-}Ind)} points starting from \code{Ind}, moves rest to left. Returns number of actually removed points. Adjusts \code{Count} to new value.
	
\end{itemize}
\paragraph{Reallocate}\hspace*{\fill}

\label{lmPointsVec.TPoints-Reallocate}
\index{Reallocate}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			public function Reallocate(Step:integer):integer;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	\code{Reallocate(Step:integer)} increases \code{Capacity} by \code{Step}.
	
\end{itemize}
\paragraph{FreePoints}\hspace*{\fill}

\label{lmPointsVec.TPoints-FreePoints}
\index{FreePoints}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			public procedure FreePoints; virtual;}
	\end{flushleft}
\item[\descriptiontitle{Description}]
Frees \code{Points}, sets \code{Count} and \code{Capacity} to zero.	
\end{itemize}
\paragraph{AllocatePoints}\hspace*{\fill}

\label{lmPointsVec.TPoints-AllocatePoints}
\index{AllocatePoints}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			public procedure AllocatePoints(ACapacity:integer);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	AllocatePoints(ACapacity:integer) allocates given capacity; unlike \code{Reallocate} does not take into account preexisting \code{Capacity}.
	
\end{itemize}
\paragraph{MinX, MaxX, MinY, MaxY}
\label{lmPointsVec.TPoints-MinX}
\index{MinX}
\begin{itemize}
	\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function MinX: Float; virtual;\\
			function MaxX: Float; virtual;\\
			function MinY: Float; virtual;\\
			function MaxY: float virtual;}
	\end{flushleft}
	\item[\descriptiontitle{Description}]
	Return maximal and minimal X and Y values, according to the names. After the call, \hyperref[lmPointsVec.TPoints-Index]{Index} field points to the first found element with this value. These functions use simple linear search. If structure of your data allows more efficient algorithms, override these functions, but don't forget to update Index field. 
\end{itemize}
\label{lmPointsVec.TPoints-Range}
\index{Range}
\paragraph{Range}
\begin{itemize}
\item[\declarationitem{Declaration}\hfill]
\begin{flushleft}
	\code{
		function Range: Float; virtual;}
\end{flushleft}
\item[\descriptiontitle{Description}]
$Range=MaxX-MinX$\label{lmPointsVec.TPoints-RangeY}
\end{itemize}
\index{RangeY}
\paragraph{RangeY}
\begin{itemize}
\item[\declarationitem{Declaration}\hfill]
\begin{flushleft}
	\code{
		function RangeY: Float;}
\end{flushleft}
\item[\descriptiontitle{Description}]
$RangeY=MaxY-MinY$
\end{itemize}

\paragraph{SortX, SortY}\hspace*{\fill}
\label{lmPointsVec.TPoints-SortX}
\index{SortX}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			public procedure SortX(descending:boolean);
			public procedure SortY(descending:boolean);}
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Sort \code{Points} by \code{X} or \code{Y}, accordingly; if descending then in descending order, otherwise in ascending.
\end{itemize}
\paragraph{ExtractX, ExtractY}\hspace*{\fill}

\label{lmPointsVec.TPoints-ExtractX}
\index{ExtractX}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			public procedure ExtractX(var AXVector:TVector; Lb, Ub: integer);
			public procedure ExtractY(var AYVector:TVector; Lb, Ub: integer);}
	\end{flushleft}

	\item[\descriptiontitle{Description}]
	Extract all X from [Lb..Ub] interval as TVector. If length of AXVector or AYVector is insufficient, it is reallocated. 
\end{itemize}
\chapter{Unit lmFilters}
\label{lmfilters}
\index{lmfilters}
\section{Description}
Unit lmFilters includes several digital filters of a signal. They are implemented as non-visual components. Most of them can be used both for filtering of earlier sampled data saved in any format and for filtering in real time, during data acquisition. To make the components format-independent, data points are fed into filter with user-defined \code{OnInput} event (see \ref{lmfilters-TInputFunc} and \ref{lmfilters.TDigFilter-OnInput}) and returned by another user-defined \code{OnOutput} event (\ref{lmfilters-TOutputproc} and \ref{lmfilters.TDigFilter-OnOutput}). You can drop a component onto a form and define \code{OnInput} and \code{OnOutput} events. Afterwards, set sampling rate and cut-off frequency by call of \code{SetupFilter} (\ref{lmfilters.TOneFreqFilter-SetupFilter}) method. For moving average filter (\ref{lmfilters.TMovAvFilter}), one has an alternative to define averaging window length instead of defining sampling rate and cut-off frequency. For median filter (\ref{lmfilters.TMedianFilter}), this is the only possibility, because for this filter cut-off frequency is not defined. After setting up the filter properties,  either call \code{Filter} (\ref{lmfilters.TDigFilter-Filter}) method for off-line filtering of existing data, or initiate filtering in real time. To do so, call \code{InitFiltering} (\ref{lmfilters.TDigFilter-InitFiltering}) and then call \code{NextPoint} (\ref{lmfilters.TDigFilter-NextPoint}) method whenever new datapoint is aquired. \code{OnInput} event is called from \code{Filter} method when the filtering procedure needs next input value, and \code{OnOutput} when it is ready to return a next output value. Similarly, \code{NextPoint} calls \code{OnInput} and \code{OnOutput} when is invoked. This technique with \code{OnInput} and \code{OnOutput} events makes the components independent of a format of data which are filtered. 

Implemented are gaussian filter (\ref{lmfilters.TGaussFilter}), moving average filter (\ref{lmfilters.TMovAvFilter}), which are probably the best ``smoothing'' filters for time domain, and median filter (\ref{lmfilters.TMedianFilter}) which is ideal to remove short spikes preserving sharp edges. One-pole high-pass filter, notch filter and Chebyshev filter are implemented in \code{lmRecursFilters} unit (\ref{lmRecursFilters}). All of these filters except Gaussian can be used for both real time and off-line filtering. Gaussian filter requires forward and backward filtering, hence, can be used only off line.

\section{Types}
\subsection{TInputFunc}
\label{lmfilters-TInputFunc}
\index{TInputFunc}
\begin{itemize}
	\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			TInputFunc = function(Index:integer):Float of Object;}
	\end{flushleft}
	\item[\descriptiontitle{Description}]
	Procedural type used by \code{OnInput} event of \code{TDigFilter} (\ref{lmfilters.TDigFilter}) and its inheritants.
\end{itemize}
\subsection{TOutputProc}
\label{lmfilters-TOutputproc}
\index{TOutputproc}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			TOutputproc = procedure(Val:Float; Index:integer) of Object;}
	\end{flushleft}
	\item[\descriptiontitle{Description}]
Procedural type used by \code{OnOutput} event of \code{TDigFilter} (\ref{lmfilters.TDigFilter}) and its inheritants.
\end{itemize}
\section{Classes, Interfaces, Objects and Records}
\subsection{EFilterException Class}
\label{lmfilters.EFilterException}
\index{EFilterException}
\subsubsection{Hierarchy}
EFilterException {$>$} exception
%%%%Description
\subsection{TDigFilter Class}
\label{lmfilters.TDigFilter}
\index{TDigFilter}
\subsubsection{Hierarchy}
TDigFilter {$>$} TComponent
\subsubsection{Declaration}
	\begin{verbatim}
		TDigFilter = class(TComponent)
		protected
		  FOnInput:TInputFunc;
		  FOnOutput:TOutputProc;
		  Index:integer;
		public
		 procedure Filter(StartIndex, EndIndex:integer); virtual; abstract;
		 procedure InitFiltering; virtual;
 procedure NextPoint; virtual; abstract;
		published
		  property OnInput:TInputFunc read FOnInput write FOnInput;
		  property OnOutput:TOutputProc read FOnOutput write FOnOutput;
		end;
		\end{verbatim}
\subsubsection{Description}
TDigFilter is an abstract ancestor class for all digital filters. Itself it is never instantiated, but introduces important common behaviour. 
\subsubsection{Events}
\begin{itemize}\label{lmfilters.TDigFilter-OnInput}
	\index{OnInput}
	\item[\inlineitem{OnInput}\hfill]
	\begin{flushleft}
		\code{
			published property OnInput: TInputFunc read FOnInput write FOnInput;}
	\end{flushleft}
	\par \code{function(Index:integer):Float of object;} must provide a value of input signal at index \code{Index}. It is called from \code{Filter}\label{lmfilters.TDigFilter-OnOutput} method.
	\index{OnOutput}
	\item[\inlineitem{OnOutput}\hfill]
	\begin{flushleft}
		\code{
			published property OnOutput: TOutputProc read FOnOutput write FOnOutput;}
	\end{flushleft}
	\par \code{procedure(Val:Float; Index:integer) of object} receives a value of filtered signal at \code{Index} and can do with it what a user needs.

	Both OnInput and OnOutput events are called from Filter (\ref{lmfilters.TDigFilter-Filter}) method, to get next value from the data stream been filtered. This technique makes the filter independent from an actual data format.

	The most simple implementation of these events may be following:
\begin{verbatim}
uses uTypes, lmFilters;
var
  DataArr:TVector;
	{.....}
function Main.MyFilterInputFunc(Index:integer):Float;
begin
  Result := DataArr[Index];
end;

procedure Main.MyFilterOutputProc(Val:Float; Index:integer);
begin
  DataArr[Index] := Val;
end;
\end{verbatim}
\end{itemize}
\subsubsection{Fields}
\paragraph{Index}\label{lmfilters.TDigFilter-index}
\begin{itemize}
	\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			protected Index:Integer;}
	\end{flushleft}
	\par  
\item[\descriptiontitle{Description}]
Integer field for indexing of the data points. Descendants use it in \code{NextPoint} (\ref{lmfilters.TDigFilter-NextPoint}) method.
\end{itemize}
\subsubsection{Methods}
\paragraph{Filter}
\label{lmfilters.TDigFilter-Filter}
\index{Filter}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			public procedure Filter(StartIndex, EndIndex:integer); virtual; abstract;}
	\end{flushleft}
	\par
	\item[\descriptiontitle{Description}]
	Receives input signal values calling \code{OnInput} (\ref{lmfilters.TDigFilter-OnInput}), makes actual filtering and outputs result calling \code{OnOutput} (\ref{lmfilters.TDigFilter-OnInput}).
\end{itemize}
\paragraph{InitFiltering}
\label{lmfilters.TDigFilter-InitFiltering}
\index{InitFiltering}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure InitFiltering; virtual;}
	\end{flushleft}
	\item[\descriptiontitle{Description}] Initiates process of online filtering; sets \code{Index} to zero.
\end{itemize}
\paragraph{NextPoint}
\label{lmfilters.TDigFilter-NextPoint}
\index{NextPoint}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure NextPoint; virtual; abstract;}
	\end{flushleft}
	\item[\descriptiontitle{Description}] Descendants use it for real-time filtering. Calls \code{OnInput} (\ref{lmfilters.TDigFilter-OnInput}) with passing \code{Index} \ref{lmfilters.TDigFilter-index} value as parameter to get input value, calculates filtered output value, calls \code{onOutput} (\ref{lmfilters.TDigFilter-OnOutput})passing \code{Index} and calculated value as parameters and increments \code{Index}.
	\item[\descriptiontitle{How to use.}] Define \code{OnInput} and \code{OnOutput} events such that \code{OnInput} returns a newly acquired data value and \code{OnOutput} returns in \code{Val} the calculated filtered value to your final dataset. Before the beginning of data aquisition, call \code{InitFiltering}. Value of \code{Index} field is initially set to zero. During the aquisition cycle, simply call \code{NextPoint} whenever new data value is acquired. 
\end{itemize}

\subsection{TOneFreqFilter Class}
\label{lmfilters.TOneFreqFilter}
\index{TOneFreqFilter}
\subsubsection{Hierarchy}
TOneFreqFilter {$>$} \hyperref[lmfilters.TDigFilter]{\code{TDigFilter}} {$>$} TComponent
\subsubsection{Declaration}
\begin{verbatim}
TOneFreqFilter = class(TDigFilter)
private
  FSamplingRate : Float;
  FCutFreq1     : Float;
public
  constructor Create(AOwner:TComponent); override;
  procedure SetupFilter(ASamplingRate, ACornerFreq : Float); virtual;
published
  property SamplingRate : Float;
  property CornerFreq     : Float;
end;
\end{verbatim}
\subsubsection{Description}
Descendant of \code{TDigFilter} \ref{lmfilters.TDigFilter} which defines filters with one cut-off frequency (that is, not pass-band or stop-band with distinct cut-offs for low and high frequencies). Introduces \code{SamplingRate} and \code{CornerFreq} properties.
\subsubsection{Properties}
\begin{itemize}\label{lmfilters.TOneFreqFilter-SamplingRate}
	\index{SamplingRate}
	\item[\inlineitem{SamplingRate}\hfill]
	\begin{flushleft}
		\code{
			published property SamplingRate;}
	\end{flushleft}
	\item[\descriptiontitle{Description}]
	Sampling rate, usually Hz; must have same units as \code{CornerFreq}.
	\label{lmfilters.TOneFreqFilter-Cutfreq1}
	\index{Cutfreq1}
	\item[\inlineitem{CornerFreq}\hfill]
	\begin{flushleft}
		\code{
			published property CornerFreq;}
	\end{flushleft}
	\item[\descriptiontitle{Description}] Cut-off (or corner) frequency, usually Hz. Must have same units as \code{SamplingRate} and be less then \code{$SamplingRate/2$}.
	\end{itemize}
\subsubsection{Methods}
\paragraph{Create}
\label{lmfilters.TOneFreqFilter-Create}
\index{Create}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			public constructor Create(AOwner:TComponent); override;}
	\end{flushleft}
\item[\descriptiontitle{Description}] Calls \code{inherited Create}, sets \code{SamplingRate} to 14400 and \code{CornerFreq} at 4000.
\end{itemize}
\paragraph{SetupFilter}
\label{lmfilters.TOneFreqFilter-SetupFilter}
\index{SetupFilter}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			public procedure SetupFilter(ASamplingRate, ACornerFreq : Float); virtual;}
	\end{flushleft}
	\item[\descriptiontitle{Description}] Procedure which sets \code{SamplingRate} and \code{CornerFreq}. It must be called before first call of \code{Filter} method. 	
\end{itemize}
\subsection{TFIRFilter Class}
\label{lmfilters.TFIRFilter}
\index{TFIRFilter}
\subsubsection{Hierarchy}
TFIRFilter {$>$} \hyperref[lmfilters.TOneFreqFilter]{\code{TOneFreqFilter}} {$>$} \hyperref[lmfilters.TDigFilter]{\code{TDigFilter}} {$>$} 
TComponent
\subsubsection{Declaration}
\begin{verbatim}
TFIRFilter = class(TOneFreqFilter)
protected
  FWinLength : integer;
  PrevPtr:integer;
  WindowData:TVector;
  procedure SetWinLength(L:integer); virtual;
  procedure InitFiltering; override;
public
  constructor Create(AOwner:TComponent); override;
published
  property WinLength : integer read FWinLength write SetWinLength;
end;
\end{verbatim}
\subsubsection{Description}
TFIRFilter: Finite Impulse response filter. Abstract class, descendant of \code{TOneFreqFilter} which introduces \code{WinLength} property for the filter window length (or length of the Impulse Response). 
\subsubsection{Properties}
\begin{itemize}\label{lmfilters.TFIRFilter-WinLength}
	\index{WinLength}
	\item[\inlineitem{WinLength}\hfill]
	\begin{flushleft}
		\code{
			published property WinLength : integer read FWinLength write SetWinLength;}
	\end{flushleft}
  \end{itemize}
\subsubsection{Fields}
\begin{itemize}\label{lmfilters.TFIRFilter-FWinLength}
	\item[\inlineitem{FWinLength}\hfill]
	\begin{flushleft}
		\code{
			protected PrevPtr:integer;}
	\end{flushleft}
\end{itemize}
\begin{itemize}\label{lmfilters.TFIRFilter-PrevPtr}
	\item[\inlineitem{PrevPtr}\hfill]
	\begin{flushleft}
		\code{
			protected FWinLength: integer;}
	\end{flushleft}
	\item[\descriptiontitle{Description}] Used internally by \code{InitFiltering} and \code{NextPoint}
\end{itemize}
\begin{itemize}\label{lmfilters.TFIRFilter-WindowData}
	\item[\inlineitem{WindowData}\hfill]
	\begin{flushleft}
		\code{
			protected WindowData:TVector;}
	\end{flushleft}
	\item[\descriptiontitle{Description}] Used internally by \code{InitFiltering} and \code{NextPoint}
\end{itemize}
\subsubsection{Methods}
\paragraph{Create}\hspace*{\fill}
\label{lmfilters.TFIRFilter-Create}
\index{Create}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			public constructor Create(AOwner:TComponent); override;}
	\end{flushleft}
	\item[\descriptiontitle{Description}] Calls \code{inherited Create}, sets \code{WinLength} to 5.
\end{itemize}
\paragraph{SetWinLength}\hspace*{\fill}
\label{lmfilters.TFIRFilter-SetWinLength}
\index{SetWinLength}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			protected procedure SetWinLength(L:integer); virtual;}
	\end{flushleft}
\item[\descriptiontitle{Description}] Sets \hyperref[lmfilters.TFIRFilter-WinLength]{WinLength} to L, allocates \code{WindowData}.
\end{itemize}
\subsection{TMovAvFilter Class}
\label{lmfilters.TMovAvFilter}
\index{TMovAvFilter}
\subsubsection{Hierarchy}
TMovAvFilter {$>$} \hyperref[lmfilters.TFIRFilter]{\code{TFIRFilter}} {$>$} \hyperref[lmfilters.TOneFreqFilter]{\code{TOneFreqFilter}} {$>$} \hyperref[lmfilters.TDigFilter]{\code{TDigFilter}} {$>$} 
TComponent
\subsubsection{Declaration}
\begin{verbatim}
TMovAvFilter = class(TFIRFilter)
protected
  Buffer : float;
  procedure SetWinLength(L:integer); override;
public
  procedure Filter(StartIndex, EndIndex:integer); override;
  procedure SetupFilter(ASamplingRate, ACornerFreq:Float); override;
  procedure InitFiltering; override;
  procedure NextPoint; override;
published
  property WinLength : integer read FWinLength write SetWinLength;
end;
\end{verbatim}
\subsubsection{Description}
Implements moving average filter. It is possible to use \hyperref[lmfilters.TMovAvFilter-SetupFilter]{SetupFilter} procedure to set \\ \hyperref[lmfilters.TOneFreqFilter-Cutfreq1]{\code{CornerFreq}}  and \hyperref[lmfilters.TOneFreqFilter-SamplingRate]{\code{SamplingRate}} properties or directly set \hyperref[lmfilters.TFIRFilter-WinLength]{WinLength}. In the first case, needed \code{WinLength}{} is automatically calculated; in the second case, resulting \code{CornerFreq} is automatically found, provided that \code{SamplingRate} was previously set. So, these approaches are mutually exclusive. 
\subsubsection{Properties}
\paragraph{WinLength}\hspace*{\fill}
\begin{itemize}\label{lmfilters.TMovAvFilter-WinLength}
	\index{WinLength}
	\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			published property WinLength : integer read FWinLength write SetWinLength;}
	\end{flushleft}
\item[\descriptiontitle{Description}] Contains length of the data window for averaging.
\end{itemize}
\subsubsection{Methods}
\paragraph{SetWinLength}
\label{lmfilters.TMovAvFilter-SetWinLength}
\index{SetWinLength}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			protected procedure SetWinLength(L:integer); override;}
	\end{flushleft}
\item[\descriptiontitle{Description}] Sets WinLength, calculates corresponding \code{CornerFreq}.
\end{itemize}
\paragraph{Filter}\hspace*{\fill}
\label{lmfilters.TMovAvFilter-Filter}
\index{Filter}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			public procedure Filter(StartIndex, EndIndex:integer); override;}
	\end{flushleft}
\item[\descriptiontitle{Description}] Filters a dataset, sequentially calling \hyperref[lmfilters.TDigFilter-OnInput]{\code{OnInput}} and \hyperref[lmfilters.TDigFilter-OnOutput]{\code{OnOutput}} beginning from \code{StartIndex} to \code{EndIndex}.
\end{itemize}
\paragraph{SetupFilter}\hspace*{\fill}
\label{lmfilters.TMovAvFilter-SetupFilter}
\index{SetupFilter}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			public procedure SetupFilter(ASamplingRate, ACornerFreq:Float); override;}
	\end{flushleft}
\item[\descriptiontitle{Description}] Sets \code{SamplingRate} and \code{CornerFreq}, calculates and sets corresponding \code{WinLength}. Importantly, if WinLength is set directly, corresponding new value for \code{CornerFreq} is set. 
\end{itemize}
\paragraph{NextPoint}\hspace*{\fill}
\begin{itemize}
	\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
	procedure NextPoint; override;	
	\end{flushleft}
	\item[\descriptiontitle{Description}] During real time filtering calculates next data point. See \ref{lmfilters.TDigFilter-NextPoint}.
\end{itemize}	
\subsection{TGaussFilter Class}
\label{lmfilters.TGaussFilter}
\index{TGaussFilter}
\subsubsection{Hierarchy}
TGaussFilter {$>$} \hyperref[lmfilters.TOneFreqFilter]{\code{TOneFreqFilter}} {$>$} \hyperref[lmfilters.TDigFilter]{\code{TDigFilter}} {$>$} TComponent
\subsubsection{Declaration}
\begin{verbatim}
TGaussFilter = class(TOneFreqFilter)
public
  constructor Create(AOwner:TComponent); override;
  procedure SetupFilter(ASamplingRate, ACornerFreq: Float); override;
  procedure Filter(StartIndex, EndIndex:integer); override;
published
  property OnInputBackward : TInputFunc;
end;
\end{verbatim}
\subsubsection{Description}
Implements gaussian filter with the algorithm described in:\\
Young I.T., L.J. van Vliet. Recursive implementation of the Gaussian Filter. // Signal Processing, 44 (1995) 139-151
\subsubsection{Properties}
\label{lmFilters:OnInputBackward}
\paragraph{OnInputBackward}
\begin{itemize}
	\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
	property OnInputBackward : TInputFunc;	
	\end{flushleft}
	\item[\descriptiontitle{Description}] \code{TGaussFilter} filters data in two steps: forward and backward filtering. Backward filtering uses data which were already processed by forward filtering. Hence, if you place filtered data into a new variable, you must define \code{OnInputBackward} event which should read data from the output variable. If, in contrast, you filter \code{in situ} such that input data are transformed rather than new data created, defining \code{OnInputBackward} event is not necessary.
	\item[\descriptiontitle{Example 1.}] Different structures are used for input and output. \code{OnInputBackward} event is needed.
	\begin{verbatim}
var
  MyGaussFilter : TGaussFilter;
  MyInputVector, MyOutputVector : TVector;
.........
function SomeObject.InputFunction(I:Integer):float;
begin
  Result := MyInputVector[I];
end;

{Note that output goes to a different place than input...}
procedure SomeObject.OutProcedure(Val: Float; I:Integer);
begin
  MyOutputVector[I] := Val;
end;

{...Hence, InputBackward event is needed to read values
which were processed by forward filtering procedure}
function SomeObject.InputBackward(I:Integer):float;
begin
  Result := MyOutputVector[I];
end;
.......
begin
  MyGaussfilter := TGaussFilter.Create(nil);
  MyGaussFilter.OnInput := @MyObject.InputFunction;
  MyGaussFilter.OnInputBackward := @SomeObject.InputBackward;
  MyGaussFilter.OnOutput := @SomeObject.OutProcedure;
  MyGaussFilter.Filter(0,High(MyInputVector));
end;
	\end{verbatim} 
	\item[\descriptiontitle{Example 2.}] Filtering in place. No need for separate \code{InputBackward} procedure.
	\begin{verbatim}
	var
	  MyGaussFilter : TGaussFilter;
	  MyDataVector  : TVector;
	.........
	function SomeObject.InputFunction(I:Integer):float;
	begin
	  Result := MyDataVector[I];
	end;
	
	{Note that output goes to the same place where from input was read.}
	procedure SomeObject.OutProcedure(Val: Float; I:Integer);
	begin
	  MyDataVector[I] := Val;
	end;
	.......
	begin
	  MyGaussfilter := TGaussFilter.Create(nil);
	  MyGaussFilter.OnInput := @MyObject.InputFunction;
	  {Separate OnInputBackward is not needed and is not assigned.}
	  MyGaussFilter.OnOutput := @SomeObject.OutProcedure;
	  MyGaussFilter.Filter(0,High(MyInputVector));
	end;
\end{verbatim}	
\end{itemize}	

\subsubsection{Methods}
\paragraph{Create}
\label{lmfilters.TGaussFilter-Create}
\index{Create}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			public constructor Create(AOwner:TComponent); override;}
	\end{flushleft}
\item[\descriptiontitle{Description}] Calls \code{inherited Create}, calculates all necessary filter coefficients.
\end{itemize}
\paragraph{SetupFilter}
\label{lmfilters.TGaussFilter-SetupFilter}
\index{SetupFilter}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			public procedure SetupFilter(ASamplingRate, ACornerFreq: Float); override;}
	\end{flushleft}
\item[\descriptiontitle{Description}] Sets \hyperref[lmfilters.TOneFreqFilter-Cutfreq1]{\code{CornerFreq}}  and \hyperref[lmfilters.TOneFreqFilter-SamplingRate]{\code{SamplingRate}}, calculates corresponding filter coefficients. 
\end{itemize}
\paragraph{Filter}
\label{lmfilters.TGaussFilter-Filter}
\index{Filter}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			public procedure Filter(StartIndex, EndIndex:integer); override;}
	\end{flushleft}
\item[\descriptiontitle{Description}] Filters a dataset, sequentially calling \hyperref[lmfilters.TDigFilter-OnInput]{\code{OnInput}} and \hyperref[lmfilters.TDigFilter-OnOutput]{\code{OnOutput}} beginning from \code{StartIndex} to \code{EndIndex}.
\end{itemize}
\subsection{TMedianFilter Class}
\label{lmfilters.TMedianFilter}
\index{TMedianFilter}
\subsubsection{Hierarchy}
TMedianFilter {$>$} \hyperref[lmfilters.TFIRFilter]{\code{TFIRFilter}} {$>$} \hyperref[lmfilters.TOneFreqFilter]{\code{TOneFreqFilter}} {$>$} \hyperref[lmfilters.TDigFilter]{\code{TDigFilter}} {$>$} TComponent
\subsubsection{Declaration}
\begin{verbatim}
TMedianFilter = class(TFIRFilter)
protected
  function FindMedian:Float;
  procedure SetWinLength(L:integer); override;
public
  procedure InitFiltering; override;
  procedure NextPoint; override;
  constructor Create(AOwner:TComponent); override;
  procedure filter(StartIndex, EndIndex:integer); override;
end;
\end{verbatim}
\subsubsection{Description}
Implementation of Median Filter. Use \code{Filter} method to filter a ready data set, use \code{InitFiltering} and \code{NextPoint} methods for real time signal filtering.
\subsubsection{Methods}
\paragraph{FindMedian}
\label{lmfilters.TMedianFilter-FindMedian}
\index{FindMedian}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{protected function FindMedian:Float;}
	\end{flushleft}
\item[\descriptiontitle{Description}] Finds Median of the filtering window. Is called from \code{Filter}, a user does not need to call it directly.
\end{itemize}
\paragraph{SetWinLength}
\label{lmfilters.TMedianFilter-SetWinLength}
\index{SetWinLength}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{protected procedure SetWinLength(L:integer); override;}
	\end{flushleft}
\item[\descriptiontitle{Description}] Sets WinLength property, internally allocates buffer for median search.\\ WinLength must be $\ge 3$ and odd. 
\end{itemize}
\paragraph{Create}
\label{lmfilters.TMedianFilter-Create}
\index{Create}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{public constructor Create(AOwner:TComponent); override;}
	\end{flushleft}
\item[\descriptiontitle{Description}] Calls \code{inherited Create}, setting window length to 5, allocates corresponding buffer for median search.
\end{itemize}
\label{FindMedian.InitFiltering}
\index{InitFiltering}
\paragraph{InitFiltering}
\begin{itemize}
	\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
	procedure InitFiltering; override;	
	\end{flushleft}
	\item[\descriptiontitle{Description}]
	Initiates real time filtering. Call this procedure before start of acquiring and filtering of real time signal.
\end{itemize}	
\paragraph{NextPoint}
\begin{itemize}
	\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		procedure NextPoint; override;	
	\end{flushleft}
	\item[\descriptiontitle{Description}] During real time filtering calculates next data point. See \ref{lmfilters.TDigFilter-NextPoint}.
\end{itemize}	
\paragraph{Filter}
\label{lmfilters.TMedianFilter-filter}
\index{filter}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure Filter(StartIndex, EndIndex:integer); override;}
	\end{flushleft}
	\item[\descriptiontitle{Description}\hfill] See \ref{lmfilters.TDigFilter-Filter}.
\end{itemize}
\section{Functions and Procedures}
\subsection{Register}
\label{lmfilters-Register}
\index{Register}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure Register;}
	\end{flushleft}
\end{itemize}

\chapter{Unit lmRecursFilters}
\label{lmRecursFilters}
\index{lmRecursFilters}
\section{Overview}
Several components implementing infinite impulse response filters are defined in this unit:\\
	\hyperref[lmRecursFilters.THighPassFilter]{\code{THighPassFilter}}\\ 
	\hyperref[lmRecursFilters.TNarrowBandFilter]{\code{TNarrowBandFilter}}\\
	\hyperref[lmRecursFilters.TNotchFilter]{\code{TNotchFilter}}\\
	\hyperref[lmRecursFilters.TBandPassFilter]{\code{TBandPassFilter}}\\
	\hyperref[lmRecursFilters.TChebyshevFilter]{\code{TChebyshevFilter}}
\section{Classes}
\subsection{THighPassFilter Class}
\label{lmRecursFilters.THighPassFilter}
\index{THighPassFilter}
\subsubsection{Hierarchy}
THighPassFilter {$>$} \hyperref[lmfilters.TOneFreqFilter]{\code{TOneFreqFilter}} {$>$} \hyperref[lmfilters.TDigFilter]{\code{TDigFilter}} {$>$} TComponent
\subsubsection{Declaration}
\begin{verbatim}
THighPassFilter = class(TOneFreqFilter)
public
  procedure SetupFilter(ASamplingRate, ACornerFreq : Float); override;
  procedure Filter(StartIndex, EndIndex:integer); override;
  procedure InitFiltering; override;
  procedure NextPoint; override;
end;
\end{verbatim}
\subsubsection{Description}
\code{THighPassFilter} component implements a single-pole high-pass filter. Call \code{SetupFilter} method to set sampling rate and corner (cut-off) frequency. Procedure \code{Filter} can be used to filter an existing data set.
\subsubsection{Methods}
\paragraph{SetupFilter}
\label{lmRecursFilters.THighPassFilter-SetupFilter}
\index{SetupFilter}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
	\code{	public procedure SetupFilter(ASamplingRate, ACornerFreq : Float); override;}		
	\end{flushleft}
	\item[\descriptiontitle{Description}\hfill] Sets \code{SamplingRate} and \code{CornerFreq} and calculates filter coefficients. 
\end{itemize}
\paragraph{Filter}\hspace*{\fill}
\label{lmRecursFilters.THighPassFilter-Filter}
\index{Filter}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{public procedure Filter(StartIndex, EndIndex:integer); override;}
	\end{flushleft}
\item[\descriptiontitle{Description}] Filters a dataset, sequentially calling \hyperref[lmfilters.TDigFilter-OnInput]{\code{OnInput}} and \hyperref[lmfilters.TDigFilter-OnOutput]{\code{OnOutput}} beginning from \code{StartIndex} to \code{EndIndex}.
\end{itemize}
\paragraph{InitFiltering}\hspace*{\fill}
\label{lmRecursFilters.THighPassFilter-InitFiltering}
\index{InitFiltering}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
			\code{public procedure InitFiltering; override;}
	\end{flushleft}
\item[\descriptiontitle{Description}] Initiates real time filtering. Call this procedure before start of acquiring and filtering of real time signal. \hyperref[lmfilters.TOneFreqFilter-Cutfreq1]{\code{CornerFreq}}  and \hyperref[lmfilters.TOneFreqFilter-SamplingRate]{\code{SamplingRate}}, calculates corresponding filter coefficients. \end{itemize}
\paragraph{NextPoint}
\label{lmRecursFilters.THighPassFilter-NextPoint}
\index{NextPoint}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
			\code{public procedure NextPoint; override;}
	\end{flushleft}
\item[\descriptiontitle{Description}] 
During real time filtering calculates next data point. See \ref{lmfilters.TDigFilter-NextPoint}.
\end{itemize}
\subsection{TNarrowBandFilter Class}
\label{lmRecursFilters.TNarrowBandFilter}
\index{TNarrowBandFilter}
\subsubsection{Hierarchy}
TNarrowBandFilter {$>$} \hyperref[lmfilters.TOneFreqFilter]{\code{TOneFreqFilter}} {$>$} \hyperref[lmfilters.TDigFilter]{\code{TDigFilter}} {$>$} TComponent
\subsubsection{Declaration}
\begin{verbatim}
 TNarrowBandFilter = class(TOneFreqFilter)
 protected
  Old: array[-2..0] of Float;
  New: array[-2..0] of Float;
  NewVal: float;
  procedure SetBandWidth(ABandWidth:float); virtual;
  procedure SetSamplingrate(AValue: Float); override;
  procedure SetCornerFreq(ACornerFreq:float); override;
public
  procedure SetupFilter(ASamplingRate, ACornerFreq : float); override;
  procedure SetupNarrowBandFilter(ASamplingRate, ABandFreq, ABandWidth : float); virtual;
  procedure Filter(StartIndex: integer; EndIndex:integer); override;
  procedure InitFiltering; override;
  procedure NextPoint; override;
published
  property BandWidth : float;
end;
\end{verbatim}
\subsubsection{Description}
\code{TNarrowBandFilter} is an ancestor class for one-pole band-reject, called also notch, filter (\code{TNotchFilter},  \ref{lmRecursFilters.TNotchFilter}) and one-pole band-pass filter (\code{TBandpassFilter}, \ref{lmRecursFilters.TBandPassFilter}). These filters have two properties: central frequency which is completely suppressed (notch filter) or completely passed (band-pass) and band width, which describes how steep is the frequency response of the filter. Central frequency is defined by \hyperref[lmfilters.TOneFreqFilter-Cutfreq1]{CornerFreq}. For band width, new property is introduced: \hyperref[lmRecursFilters.TNarrowBandFilter-BandWidth]{\code{BandWidth}}.    
\subsubsection{Properties}
\begin{itemize}\label{lmRecursFilters.TNarrowBandFilter-BandWidth}
	\index{BandWidth}
	\item[\inlineitem{BandWidth}\hfill]
	\begin{flushleft}
		\code{published property BandWidth : float;}
	\end{flushleft}
	\item[\descriptiontitle{Description}\hfill] Defines the width of rejected or passed band between points with energy 0.5, which means amplitude 0.707 of original. Smaller is the value, steeper is the frequency response, but at the expense of larger ripple in time domain. Default value is 5.0. 
	\end{itemize}
\subsubsection{Methods}
\paragraph{SetBandWidth}
\label{lmRecursFilters.TNarrowBandFilter-SetBandWidth}
\index{SetBandWidth}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{protected procedure SetBandWidth(ABandWidth:float); virtual;}
	\end{flushleft}
	\item[\descriptiontitle{Description}\hfill] 
		\begin{flushleft}
		Setter of \code{BandWidth}. Sets new value and calls \hyperref[lmRecursFilters.TNarrowBandFilter-SetupNarrowBandFilter]{\code{SetupNarrowBandFilter}} with new values.
	\end{flushleft}
\end{itemize}
\paragraph{SetSamplingrate}
\label{lmRecursFilters.TNarrowBandFilter-SetSamplingrate}
\index{SetSamplingrate}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
			protected procedure SetSamplingrate(AValue: Float); override;
	\end{flushleft}
	\item[\descriptiontitle{Description}\hfill] 
\begin{flushleft}
	Setter of \code{SamplingRate}. Sets new value and calls \hyperref[lmRecursFilters.TNarrowBandFilter-SetupNarrowBandFilter]{\code{SetupNarrowBandFilter}} with new values.
\end{flushleft}
\end{itemize}
\paragraph{SetCornerFreq}
\label{lmRecursFilters.TNarrowBandFilter-SetCutFreq1}
\index{SetCutFreq1}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
			\code{protected procedure SetCornerFreq(ACornerFreq:float); override;}
	\end{flushleft}
	\item[\descriptiontitle{Description}\hfill] 
\begin{flushleft}
	Setter of \code{CornerFreq}. Sets new value and calls \hyperref[lmRecursFilters.TNarrowBandFilter-SetupNarrowBandFilter]{\code{SetupNarrowBandFilter}} with new values.
\end{flushleft}
\end{itemize}
\paragraph{SetupFilter}
\label{lmRecursFilters.TNarrowBandFilter-SetupFilter}
\index{SetupFilter}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{public procedure SetupFilter(ASamplingRate, ABandFreq, ABandWidth : float); override;}
	\end{flushleft}
	\item[\descriptiontitle{Description}\hfill] 
	\begin{flushleft}
		Calls \hyperref[lmRecursFilters.TNarrowBandFilter-SetupNarrowBandFilter]{\code{SetupNarrowBandFilter}} with new values for \code{Samplingrate}, and \code{CornerFreq} leaving \hyperref[lmRecursFilters.TNarrowBandFilter-BandWidth]{\code{BandWidth}} unchanged (default value is 5.0) and calculates filter coefficients accordingly. It is more efficient to call \code{SetupNarrowBandFilter} directly rather than set values of the properties or call \code{SetupFilter}. However, \code{SetupFilter} allows to use descendants of \code{TNarrowBandFilter} in more generic code where variable of \code{TDigFilter} class is used.
	\end{flushleft}
\end{itemize}
\paragraph{Filter}
\label{lmRecursFilters.TNarrowBandFilter-Filter}
\index{Filter}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{public procedure Filter(StartIndex: integer; EndIndex:integer); override;}
	\end{flushleft}
	\item[\descriptiontitle{Description}\hfill] See \ref{lmfilters.TDigFilter-Filter}.
\end{itemize}
\paragraph{InitFiltering}
\label{lmRecursFilters.TNarrowBandFilter-InitFiltering}
\index{InitFiltering}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
	\code{public procedure InitFiltering; override;}
	\end{flushleft}
	\item[\descriptiontitle{Description}\hfill] See \ref{lmfilters.TDigFilter-InitFiltering}.
\end{itemize}
\paragraph{NextPoint}
\label{lmRecursFilters.TNarrowBandFilter-NextPoint}
\index{NextPoint}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
			\code{public procedure NextPoint; override;}
	\end{flushleft}
	\item[\descriptiontitle{Description}\hfill] See \ref{lmfilters.TDigFilter-NextPoint}.
\end{itemize}
\subsection{TNotchFilter Class}
\label{lmRecursFilters.TNotchFilter}
\index{TNotchFilter}
\subsubsection{Hierarchy}
TNotchFilter {$>$} \hyperref[lmRecursFilters.TNarrowBandFilter]{TNarrowBandFilter} {$>$} 
\hyperref[lmfilters.TOneFreqFilter]{\code{TOneFreqFilter}} {$>$} \hyperref[lmfilters.TDigFilter]{\code{TDigFilter}} {$>$} TComponent
\subsubsection{Declaration}
\begin{verbatim}
TNotchFilter = class(TNarrowBandFilter)
  public
  procedure SetupFilter(ASamplingRate, ABandFreq, ABandWidth : float); override;
end;
\end{verbatim}
\subsubsection{Description}
Implements notch (band-reject) filter, which may be used, for example, to eliminate a 50 Hz hum from a signal. See \ref{lmRecursFilters.TNarrowBandFilter} for methods and properties. 
\subsection{TBandPassFilter Class}
\label{lmRecursFilters.TBandPassFilter}
\index{TBandPassFilter}
\subsubsection{Hierarchy}
TBandPassFilter {$>$} \hyperref[lmRecursFilters.TNarrowBandFilter]{TNarrowBandFilter} {$>$} 
\hyperref[lmfilters.TOneFreqFilter]{\code{TOneFreqFilter}} {$>$} \hyperref[lmfilters.TDigFilter]{\code{TDigFilter}} {$>$} TComponent
\subsubsection{Description}
Implements band-pass filter, which allows to isolate a narrow band around given frequency. See \ref{lmRecursFilters.TNarrowBandFilter} for methods and properties. 
\subsection{TChebyshevFilter Class}
\label{lmRecursFilters.TChebyshevFilter}
\index{TChebyshevFilter}
\subsubsection{Hierarchy}
TChebyshevFilter {$>$} \hyperref[lmfilters.TOneFreqFilter]{\code{TOneFreqFilter}} {$>$} \hyperref[lmfilters.TDigFilter]{\code{TDigFilter}} {$>$} TComponent
\subsubsection{Declaration}
\begin{verbatim}
TChebyshevFilter = class(TOneFreqFilter)
  procedure Filter(StartIndex, EndIndex:integer); override;
  procedure SetupChebyshevFilter(ASamplingRate: Float; ACornerFreq: Float;
   ANPoles: integer; APRipple: float; AHighPass:boolean);
  procedure SetupFilter(ASamplingRate, ACornerFreq : float); 
  procedure InitFiltering; 
  procedure NextPoint;
end;
\end{verbatim}
\subsubsection{Description}
\code{TChebyshevFilter} implements a Chebyshev filter, which may be used both as a high- or low-pass filter. Main characteristic of this filter is a steep frequency response at the expense of a considerable signal distortion in time domain. Another noticeable feature of Chebyshev filters is a ripple in frequency domain; here is implemented type 1 filter where ripple is allowed only in pass-band. Larger ripple comes with a steeper frequency response. Setting ripple to zero converts Chebyshev filter to the Butterworth maximally flat filter. Drawback is a relatively flat frequency response. In most cases, ripple 0.5 \% is a good choice, when frequency response is already almost maximally steep, while ripple is nearly invisible. Setting ripple to 0 converts Chebyshev filter to ``maximally flat'' Butterworth filter. More poles make the frequency response steeper, but calculations are more complicated. With too many  poles filter performance can deteriorate due to rounding errors, hence, in this implementation maximal number of poles is limited to 10. Usually, 6 poles is a good choice. Note, that \code{SetupFilter} is not used for \code{TChebyshevFilter}. Rather, use \code{TChebyshevFilter.SetupChebyshevFilter} method.
\paragraph{SetupChebyshevFilter}
\label{lmRecursFilters.TChebyshevFilter-SetupChebyshevFilter}
\index{SetupChebyshevFilter}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
	\code{public procedure SetupChebyshevFilter(ASamplingRate: Float; ACornerFreq: Float; ANPoles: integer; APRipple: float; AHighPass:boolean);}
	\end{flushleft}
	\item[\descriptiontitle{Description}\hfill] Similar to \code{SetupFilter}, defines \code{SamplingRate} and \code{CornerFreq}. Additionally, with \code{APoles} it defines number of poles; APRipple defines amount of ripple in the pass band; finally, AHighPass defines if a high pass (if true) or low pass (if false) filter is requested. \code{APoles} must be positive even below or equal 10.
\end{itemize}
\paragraph{Filter}\hspace*{\fill}
\begin{itemize}
	\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
	procedure Filter(StartIndex, EndIndex:integer);	
	\end{flushleft}
	\item[\descriptiontitle{Description}] Filters a dataset, sequentially calling \hyperref[lmfilters.TDigFilter-OnInput]{\code{OnInput}} and \hyperref[lmfilters.TDigFilter-OnOutput]{\code{OnOutput}} beginning from \code{StartIndex} to \code{EndIndex}.
\end{itemize}	
\paragraph{SetupFilter}\hspace*{\fill}
\begin{itemize}
	\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		procedure SetupFilter(ASamplingRate, ACornerFreq : float);
	\end{flushleft}
	\item[\descriptiontitle{Description}] Calls \code{SetupChebyshevFilter} with given \code{ASamplingRate} and \code{ACornerFreq} and leaves other parameters unchanged. Default values after construction are 6 poles, ripple 0.5\% and low pass filter. It is more efficient to call \code{SetupChebyshevFilter} directly rather than use \code{SetupFilter}. However, this latter methid allows to use Chebyshev filter in a generic code where variable of \code{TDigFilter} type is used.
\end{itemize}	
\paragraph{InitFiltering}\hspace*{\fill}
\begin{itemize}
	\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
	procedure InitFiltering;	
	\end{flushleft}
	\item[\descriptiontitle{Description}] Initiates real time filtering. Call this procedure before start of acquiring and filtering of real time signal.
\end{itemize}	
\paragraph{NextPoint}\hspace*{\fill}
\begin{itemize}
	\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		procedure NextPoint;
	\end{flushleft}
	\item[\descriptiontitle{Description}] During real time filtering calculates next data point. See \ref{lmfilters.TDigFilter-NextPoint}.
	
\end{itemize}	

\subsection{Functions and Procedures}
\subsubsection{Register}
\label{lmRecursFilters-Register}
\index{Register}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{procedure Register;}
	\end{flushleft}
\end{itemize}

\chapter{Unit lmcoordsys}
\label{lmcoordsys}
\index{lmcoordsys}
\section{Description}
\code{TCoordSys} component implemented in this unit is relatively simple Cartesian coordinate plane for drawing points, lines, graphical primitives and mathematical functions in user's coordinates. Component is derived from TPanel, so, you can place other components, for example, scale edits, on top of it.

Usage: place the component on your form, in the Object Inspector define positions of axes, distance between grid lines (in user space) as well as coordinate limits (\code{MinX, MaxX, MinY, MaxY}). Define \code{TPen} properties which are used for drawing axes, grid lies and user data as well as numeric format for axes numbering.

For drawing of user's data define \hyperref[lmcoordsys.TCoordSys-OnDrawData]{OnDrawdata} event; all your drawing must occur within it. 

Coordinates are converted between user space and screen coordinates with \hyperref[lmcoordsys.TCoordSys-UserToScreen]{UserToScreen}, \hyperref[lmcoordsys.TCoordSys-ScreenToUser]{ScreenToUser}, \hyperref[lmcoordsys.TCoordSys-XUserToScreen]{XUserToScreen}, \hyperref[lmcoordsys.TCoordSys-YScreenToUser]{YUserToScreen}, \hyperref[lmcoordsys.TCoordSys-XScreenToUser]{XScreenToUser} and \hyperref[lmcoordsys.TCoordSys-YScreenToUser]{YScreenToUser} functions, but you seldom need to call them directly. Procedures \hyperref[lmcoordsys.TCoordSys-PutLine]{PutLine}, \hyperref[lmcoordsys.TCoordSys-GoToXY]{GoToXY}, \hyperref[lmcoordsys.TCoordSys-LineTo]{LineTo}, \hyperref[lmcoordsys.TCoordSys-Circle]{Circle}, \hyperref[lmcoordsys.TCoordSys-Aim]{Aim}, \hyperref[lmcoordsys.TCoordSys-FillRect]{FillRect} are provided for drawing graphical primitives and data in user's space. Procedure \hyperref[lmcoordsys.TCoordSys-FastDraw]{FastDraw} serves for fast drawing of arrays of \code{TPoint} sorted for X coordinate; \hyperref[lmcoordsys.TCoordSys-DrawSpline]{DrawSpline} and \hyperref[lmcoordsys.TCoordSys-DrawFunc]{DrawFunc} provide plotting of data and mathematical functions.

\code{Canvas} property is published, allowing to define easily own drawing procedures.

All drawing of user's data must occur in \code{OnDrawData} event, which is called from \code{Paint} procedure.  
\section{Classes}
\subsection{TCoordSys Class}\label{lmcoordsys.TCoordSys}
\index{TCoordSys}
\subsubsection{Hierarchy}
TCoordSys {$>$} TPanel
\subsubsection{Declaration}
\begin{verbatim}
TCoordSys = class(TPanel)
protected
  function GetFont:TFont;
  procedure SetXAxisLabel(const ALabel:String);virtual;
  function GetXAxisLabel:string; virtual;
  procedure SetYAxisLabel(const ALabel:String);virtual;
  function GetYAxisLabel:string; virtual;
  procedure SetMinX(AMinX:Float); virtual;
  procedure SetMaxX(AMaxX:Float); virtual;
  procedure SetMinY(AMinY:Float); virtual;
  procedure SetMaxY(AMaxY:Float); virtual;
  procedure DrawAxis; virtual;
  procedure DrawGridLines; virtual;
  procedure DrawAxisLabels; virtual; abstract; 
  procedure SetLeftMargin(AMargin:integer); virtual;
  procedure SetRightMargin(AMargin:integer); virtual;
  procedure SetLowerMargin(AMargin:integer); virtual;
  procedure SetUpperMargin(AMargin:integer); virtual;
  procedure SetXPos(AXPos:Float); virtual;
  procedure SetYPos(AYPos:Float); virtual;
  procedure SetXGridDist(AXGridDist:Float); virtual;
  procedure SetYGridDist(AYGridDist:Float); virtual;
  procedure SetAxisPen(APen:TPen); virtual;
  procedure SetGridPen(APen:TPen); virtual;
  procedure SetOutputPen(APen:TPen); virtual;
  procedure SetPenPos(APenPos:TRealPoint); virtual;
  procedure SetGridDir; virtual; abstract;
public
  ScaleX, ScaleY:Float;
  property PenPos: TRealPoint read FPenPos write SetPenPos;
  constructor Create(AOwner:TComponent); override;
  destructor Destroy; override;
  procedure Paint; override;
  procedure LineTo(APoint:TRealPoint); overload; 
  procedure LineTo(X,Y:Float); overload;
  procedure NewLimits(AMinX,AMinY,AMaxX,AMaxY:Float); virtual;
  procedure XScrollTo(AX:Float); virtual;
  procedure YScrollTo(AY:Float); virtual;
  procedure PutLine(P1,P2:TRealPoint); overload;
  procedure PutLine(X1,Y1,X2,Y2:Float); overload;
  function UserToScreen(UP:TRealPoint):TPoint;virtual;
  function  XUserToScreen(X:Float):integer;virtual;
  function  YUserToScreen(Y:Float):integer;virtual;
  function  XScreenToUser(X:integer):Float; virtual;
  function  YScreenToUser(Y:integer):Float; virtual;
  procedure Circle(Center:TRealPoint; R:integer); virtual;
  procedure Aim(Center: TRealPoint; R: integer); virtual;
  procedure FillRect(X1,Y1,X2,Y2:Float); overload;
  procedure Fillrect(P1,P2:TRealPoint); overload;
  procedure GoToXY(X,Y:Float);
  function ScreenToUser(SP:TPoint):TRealPoint; virtual;
  procedure ReScale(CoeffX, CoeffY:Float);
  procedure FastDraw(APoints:TRealPointVector; Lb, Ub: integer);
  procedure DrawSpline(APoints:TPoints; Lb, Ub: integer);
  procedure DrawFunc(AFunc:TParamFunc; Params:Pointer; 
       LeftX, RightX : Float); virtual;
published                                    
  property XAxisLabel:string read FXAxisLabel write FXAxisLabel;
  property YAxisLabel:string read FYAxisLabel write FYAxisLabel;
  property MinX:Float; 
  property MinY:Float;
  property MaxX:Float;
  property MaxY:Float read FMaxY write SetMaxY;
  property XPos:Float read FXPos write SetXPos;
  property YPos:Float read FYPos write SetYPos;
  property Font:TFont read GetFont;
  property AxisPen:TPen;
  property OutputPen:TPen;
  property GridPen:TPen;
  property LeftMargin:integer default 0;
  property RightMargin:integer default 0;
  property LowerMargin:integer default 0;
  property UpperMargin:integer default 0;
  property XGridDist:Float;
  property YGridDist:Float;
  property XGridNumbersPrecision: integer default 5;
  property XGridNumbersDecimals: integer default 2;
  property YGridNumbersPrecision: integer default 9;
  property YGridNumbersDecimals: integer default 4;
  property Canvas;
  property OnDrawData:TNotifyEvent;
end;
\end{verbatim}
\subsubsection{Description}
TCoordSys
\subsubsection{Properties}
\begin{itemize}\label{lmcoordsys.TCoordSys-PenPos}
\index{PenPos}
\item[\inlineitem{PenPos}\hfill]
\begin{flushleft}
\code{
public property PenPos: TRealPoint;}
\end{flushleft}

Starting position for \hyperref[sec:lineto]{LineTo}. It can be set with \hyperref[lmcoordsys.TCoordSys-GoToXY]{GoToXY} method, or assigned directly. Difference is that for direct assignment coordinates must be represented as \code{TRealPoint}, while for \code{GoToXY} as separate \code{X,Y:Float}. \label{lmcoordsys.TCoordSys-XAxisLabel}
\index{XAxisLabel}
\item[\inlineitem{XAxisLabel}\hfill]
\begin{flushleft}
\code{
published property XAxisLabel: string;}\label{lmcoordsys.TCoordSys-YAxisLabel}
\end{flushleft}

Label of X axis.
\index{YAxisLabel}
\item[\declarationitem{YAxisLabel}\hfill]
\begin{flushleft}
\code{
published property YAxisLabel: string read FYAxisLabel write FYAxisLabel;}
\end{flushleft}
\par Label of Y axis.  
\index{MinX}
\item[\inlineitem{MinX,MinY,MaxX,MaxY}\hfill]
\begin{flushleft}
\code{
published property MinX: Float;\\
published property MinY: Float;\\
published property MaxX: Float;\\
published property MaxY: Float;
}
\end{flushleft}
\label{lmcoordsys.TCoordSys-MinX}
 MinX,MinY,MaxX,MaxY define window bounds in user coordinate space.\label{lmcoordsys.TCoordSys-MinY}
\index{MinY}
\index{MaxX}
\index{MaxY}
\label{lmcoordsys.TCoordSys-XPos}
\index{XPos}

\item[\inlineitem{XPos}\hfill]
\begin{flushleft}
\code{
published property XPos: Float;}
\end{flushleft}
\label{lmcoordsys.TCoordSys-YPos}
\item[\descriptiontitle{Description}] Position of X-axis in Y-coordinate. Default is 0 as well as for YPos, such that axes cross at (0,0) point.
\index{YPos}
\item[\inlineitem{YPos}\hfill]
\begin{flushleft}
\code{
published property YPos: Float;}
\end{flushleft}
\item[\descriptiontitle{Description}] Position of Y-axis in X-coordinate. Default is 0 as well as for XPos, such that axes cross at (0,0) point.
\label{lmcoordsys.TCoordSys-Font}
\index{Font}
\item[\inlineitem{Font}\hfill]
\begin{flushleft}
\code{
published property Font: TFont;}
\end{flushleft}
\par  \label{lmcoordsys.TCoordSys-AxisPen}
\index{AxisPen}
\item[\inlineitem{AxisPen}\hfill]
\begin{flushleft}
\code{
published property AxisPen: TPen;}
\end{flushleft}
\par Pen to draw axis.\label{lmcoordsys.TCoordSys-OutputPen}
\index{OutputPen}
\item[\inlineitem{OutputPen}\hfill]
\begin{flushleft}
\code{
published property OutputPen: TPen;}
\end{flushleft}
\par Pen to draw user's output (from OnDrawData event).\label{lmcoordsys.TCoordSys-GridPen}
\index{GridPen}
\item[\inlineitem{GridPen}\hfill]
\begin{flushleft}
\code{
published property GridPen: TPen;}
\end{flushleft}
Pen to draw gridlines.
\label{lmcoordsys.TCoordSys-LeftMargin}\label{lmcoordsys.TCoordSys-RightMargin}
\index{LeftMargin}
\item[\inlineitem{LeftMargin, RightMargin}\hfill]
\item[\inlineitem{Upper Margin}\hfill]
\item[\inlineitem{LowerMargin}\hfill]
\begin{flushleft}
\code{
published property LeftMargin: integer; default 0;\\
published property RightMargin: integer; default 0;\\
published property LowerMargin: integer; default 0;\\
published property UpperMargin: integer; default 0;}
\end{flushleft}
\par Width of margins, in pixel
\index{RightMargin}
\index{LowerMargin}
\index{UpperMargin}
\label{lmcoordsys.TCoordSys-XGridDist}
\index{XGridDist}
\item[\inlineitem{XGridDist}\hfill]
\begin{flushleft}
\code{
published property XGridDist: Float;}
\end{flushleft}
Distance between grid lines or ticks on X axis in user space coordinates. \label{lmcoordsys.TCoordSys-YGridDist}
\index{YGridDist}
\item[\inlineitem{YGridDist}\hfill]
\begin{flushleft}
\code{
published property YGridDist: Float;}
\end{flushleft}
Distance between grid lines or ticks on Y axis in user space coordinates. 

\label{lmcoordsys.TCoordSys-XGridNumbersPrecision}
\index{XGridNumbersPrecision}
\item [\inlineitem{Axis numbering}]
\begin{flushleft}
\code{
published property XGridNumbersPrecision:integer; default 5;\\
published property XGridNumbersDecimals:integer; default 2;}
\end{flushleft}
\par\code{Precision} and \code{Decimal} parameters for \code{FloatToStrF} call for X axis numbering. \label{lmcoordsys.TCoordSys-XGridNumbersDecimals}
\index{XGridNumbersDecimals}
\label{lmcoordsys.TCoordSys-YGridNumbersPrecision}
\index{YGridNumbersPrecision}
\code{
published property YGridNumbersPrecision: integer; default 9;\\
published property YGridNumbersDecimals: integer; default 4;}
\par \code{Precision} and \code{Decimal} parameters for \code{FloatToStrF} call for Y axis  numbering. \label{lmcoordsys.TCoordSys-YGridNumbersDecimals}
\index{YGridNumbersDecimals}
\label{lmcoordsys.TCoordSys-Canvas}
\index{Canvas}
\item[\inlineitem{Canvas}\hfill]
\begin{flushleft}
\code{
published property Canvas;}
\end{flushleft}
\label{lmcoordsys.TCoordSys-OnDrawData}
\index{OnDrawData}
\item[\inlineitem{OnDrawData}\hfill]
\begin{flushleft}
\code{
published property OnDrawData: TNotifyEvent;}
\end{flushleft}
All drawing of user data (like \hyperref[lmcoordsys.TCoordSys-DrawFunc]{drawfunction}, \hyperref[lmcoordsys.TCoordSys-FastDraw]{fastdraw}, all user-defined drawing etc.) must be done in this event.\end{itemize}
\subsubsection{Fields}
\begin{itemize}\label{lmcoordsys.TCoordSys-ScaleX}
\index{ScaleX}
\item[\inlineitem{ScaleX, ScaleY}\hfill]
\begin{flushleft}
\code{
public ScaleX:Float;\\
public ScaleY:Float;}
\end{flushleft}
\end{itemize}
\par Pixels per user unit. You must never set these values manually; they are automatically recalculated by window risizing or changes of \hyperref[lmcoordsys.TCoordSys-MinX]{MinX}, \hyperref[lmcoordsys.TCoordSys-MinX]{MaxX}, \hyperref[lmcoordsys.TCoordSys-MinY]{MinY}, \hyperref[lmcoordsys.TCoordSys-MinY]{MaxY}. \label{lmcoordsys.TCoordSys-ScaleY}
\index{ScaleY}

\subsubsection{Methods}
\paragraph{Create}\hspace*{\fill}
\label{lmcoordsys.TCoordSys-Create}
\index{Create}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
\begin{flushleft}
\code{
public constructor Create(AOwner:TComponent); override;}
\end{flushleft}
\item[\descriptiontitle{Description}] Calls \code{inherited Create}, then creates AxisPen, GridPen and OutputPen. 
\end{itemize}
\paragraph{Destroy}\hspace*{\fill}
\label{lmcoordsys.TCoordSys-Destroy}
\index{Destroy}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
\begin{flushleft}
\code{
public destructor Destroy; override;}
\end{flushleft}
\end{itemize}
\paragraph{Paint}\hspace*{\fill}
\label{lmcoordsys.TCoordSys-Paint}
\index{Paint}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
\begin{flushleft}
\code{
public procedure Paint; override;}
\end{flushleft}
\item[\descriptiontitle{Description}] Calls inherited (TPanel) Paint, then draws axes using \code{AxisPen}, after it draws gridlines and ticks using \code{GridPen} and, finally, sets \code{OutputPen} as active pen and calls \hyperref[lmcoordsys.TCoordSys-OnDrawData]{OnDrawData}, where all user-defined data drawing must occur.
\end{itemize}
\paragraph{NewLimits}\hspace*{\fill}
\label{lmcoordsys.TCoordSys-NewLimits}
\index{NewLimits}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			public procedure NewLimits(AMinX,AMinY,AMaxX,AMaxY:Float); virtual;}
	\end{flushleft}
	\item[\descriptiontitle{Description}]
	Sets new window bounds in user coordinate space (MinX, MinY, MaxX,MaxY), calls RedrawCoordSys to reflect changes.
\end{itemize}
\paragraph{ReScale}\hspace*{\fill}\label{lmcoordsys.TCoordSys-ReScale}
\index{ReScale}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			public procedure ReScale(CoeffX, CoeffY:Float);}
	\end{flushleft}
	\item[\descriptiontitle{Description}]
	Multiplies all coordinates, axes and grid positions by a factors \code{CoeffX} and \code{CoeffY}. This may be useful for conversion of units of user space, fro example between metric and imperial systems.
	
\end{itemize}
\paragraph{XScrollTo, YScrollTo}\hspace*{\fill}
\label{lmcoordsys.TCoordSys-XScrollTo}
\index{XScrollTo}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			public procedure XScrollTo(AX:Float); virtual;\\
			public procedure YScrollTo(AY:Float); virtual;}
	\end{flushleft}
	\item[\descriptiontitle{Description}]
	Procedures for scroll in \code{X} or \code{Y} direction: set \code{MinX} to \code{AX} or \code{MinY} to \code{AY}, modify \code{MaxX} or \code{MaxY} accordingly such that scale is preserved. Redraw the coordinate system and user data.
\end{itemize}
\paragraph{UserToScreen, XUserToScreen, YUserToScreen}\hspace*{\fill}
\label{lmcoordsys.TCoordSys-UserToScreen}
\index{UserToScreen}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			public function UserToScreen(UP:TRealPoint):TPoint; virtual;\\
			public function XUserToScreen(X:Float):integer; virtual;\\
			public function YUserToScreen(Y:Float):integer; virtual;}
	\end{flushleft}
	\item[\descriptiontitle{Description}]
	Convert user space coordinates to screen coordinates.
\end{itemize}

\paragraph{ScreenToUser, XScreenToUser, YScreenToUser}\hspace*{\fill}
\label{lmcoordsys.TCoordSys-XScreenToUser}
\index{XScreenToUser}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			public function ScreenToUser(SP:TPoint):TRealPoint; virtual;\\
			public function XScreenToUser(X:integer):Float; virtual;\\
			public function YScreenToUser(Y:integer):Float; virtual;}
	\end{flushleft}
	\item[\descriptiontitle{Description}]
	Convert screen coordinates to user space coordinates.
\end{itemize}
\paragraph{DrawAxis}\hspace*{\fill}
\label{lmcoordsys.TCoordSys-DrawAxis}
\index{DrawAxis}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			protected procedure DrawAxis; virtual;}
	\end{flushleft}
	\item[\descriptiontitle{Description}] Procedure which draws axes. Is automatically called from \code{Paint} method, normally user does not call it manually.
\end{itemize}
\paragraph{DrawGridLines}\hspace*{\fill}
\label{lmcoordsys.TCoordSys-DrawGridLines}
\index{DrawGridLines}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			protected procedure DrawGridLines; virtual;}
	\end{flushleft}
	\item[\descriptiontitle{Description}] Procedure for drawing ticks and grids. Called from \code{Paint}.
\end{itemize}




\paragraph{GoToXY}\hspace*{\fill}\label{lmcoordsys.TCoordSys-GoToXY}
\index{GoToXY}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			public procedure GoToXY(X,Y:Float);}
	\end{flushleft}
	\item[\descriptiontitle{Description}]
	Sets PenPos property to (X,Y) point. This property is used by LineTo procedure.
	
\end{itemize}
\paragraph{LineTo}\label{sec:lineto}\hspace*{\fill}
\label{lmcoordsys.TCoordSys-LineTo}
\index{LineTo}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
\begin{flushleft}
\code{
public procedure LineTo(APoint:TRealPoint); overload;\\
public procedure LineTo(X,Y:Float); overload;}
\end{flushleft}
\item[\descriptiontitle{Description}]
Draws line from \hyperref[lmcoordsys.TCoordSys-PenPos]{PenPos} to \code{APoint} or (X,Y) and updates \code{PenPos}.
\end{itemize}


\paragraph{PutLine}\hspace*{\fill}
\label{lmcoordsys.TCoordSys-PutLine}
\index{PutLine}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
\begin{flushleft}
\code{
public procedure PutLine(P1,P2:TRealPoint); overload;\\
public procedure PutLine(X1,Y1,X2,Y2:Float); overload;}
\end{flushleft}
\item[\descriptiontitle{Description}]
Puts line of OutputColor from (X1,Y1) to (X2,Y2) or from P1 to P2. Unlike \code{LineTo}, does not use or modify \code{PenPos}.
\end{itemize}


\paragraph{Circle}\hspace*{\fill}
\label{lmcoordsys.TCoordSys-Circle}
\index{Circle}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
\begin{flushleft}
\code{
public procedure Circle(Center:TRealPoint; R:integer); virtual;}
\end{flushleft}
\item[\descriptiontitle{Description}]
draws a circle with the \code{Center} in user space coordinates and radius \code{R} in screen pixels.
\end{itemize}
\paragraph{Aim}\hspace*{\fill}
\label{lmcoordsys.TCoordSys-Aim}
\index{Aim}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
\begin{flushleft}
\code{
public procedure Aim(Center: TRealPoint; R: integer); virtual;}
\end{flushleft}
\item[\descriptiontitle{Description}]
draws circle with cross. \code{Center} in user space coordinate and radius \code{R} in pixels.
\end{itemize}
\paragraph{FillRect}\hspace*{\fill}
\label{lmcoordsys.TCoordSys-FillRect}
\index{FillRect}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
\begin{flushleft}
\code{
public procedure FillRect(X1,Y1,X2,Y2:Float); overload;
public procedure Fillrect(P1,P2:TRealPoint); overload;}
\end{flushleft}
\item[\descriptiontitle{Description}] Draws filled rectangle in user space coordinates.
\end{itemize}


\paragraph{FastDraw}\hspace*{\fill}\label{lmcoordsys.TCoordSys-FastDraw}
\index{FastDraw}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
\begin{flushleft}
\code{
public procedure FastDraw(APoints:TRealPointVector; Lb, Ub: integer);}
\end{flushleft}
\item[\descriptiontitle{Description}]
Fast optimized drawing of large ({$>$}10000) arrays of \code{TRealPoint}. Only if "X" is sorted in ascending order
\end{itemize}
\paragraph{DrawSpline}\hspace*{\fill}\label{lmcoordsys.TCoordSys-DrawSpline}
\index{DrawSpline}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
\begin{flushleft}
\code{
public procedure DrawSpline(APoints:TPoints; Lb, Ub: integer);}
\end{flushleft}
\item[\descriptiontitle{Description}]
Draws spline through the points Apoints[Lb]..APoints[Ub]
\end{itemize}
\paragraph{DrawFunc}\hspace*{\fill}\label{lmcoordsys.TCoordSys-DrawFunc}
\index{DrawFunc}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
\begin{flushleft}
\code{
public procedure DrawFunc(AFunc:TParamFunc; Params:Pointer; LeftX, RightX : Float); virtual;}
\end{flushleft}
\item[\descriptiontitle{Description}]
Draws \code{TParamFunc (function(X:Float; Params:Pointer):Float} from \code{LeftX} to \code{RightX}. If they are outside MinX..MaxX they are cropped.
\end{itemize}
\paragraph{SetMinX, SetMinY, SetMaxX, SetMaxY}\hspace*{\fill}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\label{lmcoordsys.TCoordSys-SetMinX}
	\label{lmcoordsys.TCoordSys-SetMaxX}
	\label{lmcoordsys.TCoordSys-SetMinY}
	\label{lmcoordsys.TCoordSys-SetMaxY}
	\index{SetMinX}\index{SetMaxX}\index{SetMinY}\index{SetMaxY}
	\begin{flushleft}
		\code{protected procedure SetMinX(AMinX:Float); virtual;\\
			protected procedure SetMaxX(AMaxX:Float); virtual;\\
			protected procedure SetMinY(AMinY:Float); virtual;\\
			protected procedure SetMaxY(AMaxY:Float); virtual;}
	\end{flushleft}
	\item[\descriptiontitle{Description}] Methods to set \hyperref[lmcoordsys.TCoordSys-MinX]{MinX}, \code{MaxX}, \code{MinY}, \code{MaxY} properties. Change limits of drawn user coordinates and rescale the picture.
\end{itemize}
\paragraph{SetRightMargin, SetLeftMargin, SetLowerMargin, SetUpperMargin}\hspace*{\fill}
\label{lmcoordsys.TCoordSys-SetRightMargin}
\label{lmcoordsys.TCoordSys-SetLowerMargin}
\label{lmcoordsys.TCoordSys-SetUpperMargin}
\label{lmcoordsys.TCoordSys-SetLeftMargin}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			protected procedure SetRightMargin(AMargin:integer); virtual;\\
			protected procedure SetLeftMargin(AMargin:integer); virtual;\\
			protected procedure SetLowerMargin(AMargin:integer); virtual;\\
			protected procedure SetUpperMargin(AMargin:integer); virtual;}
	\end{flushleft}
	\item[\descriptiontitle{Description}] These procedures set margins which are not used for drawing of data. These are methods to set corresponding properties.
\end{itemize}

\paragraph{SetXGridDist, SetYDist}\hspace*{\fill}
\label{lmcoordsys.TCoordSys-SetXGridDist}
\index{SetXGridDist}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			protected procedure SetXGridDist(AXGridDist:Float); virtual;\\
			protected procedure SetYGridDist(AYGridDist:Float); virtual;}
	\end{flushleft}
	\item[\descriptiontitle{Description}] Methods to set \hyperref[lmcoordsys.TCoordSys-XGridDist]{XGridDist} and \code{YGridDist} properties.
\end{itemize}
\paragraph{SetPenPos}\hspace*{\fill}
\label{lmcoordsys.TCoordSys-SetPenPos}
\index{SetPenPos}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			protected procedure SetPenPos(APenPos:TRealPoint); virtual;}
	\end{flushleft}
	\item[\descriptiontitle{Description}] Method to set \hyperref[lmcoordsys.TCoordSys-PenPos]{PenPos} property (Alternatively, use \hyperref[lmcoordsys.TCoordSys-GoToXY]{GoToXY} procedure).
\end{itemize}
\paragraph{SetXPos, SetYPos}\hspace*{\fill}
\label{lmcoordsys.TCoordSys-SetXPos}
\index{SetXPos}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			protected procedure SetXPos(AXPos:Float); virtual;\\
			protected procedure SetYPos(AYPos:Float); virtual;}
	\end{flushleft}
	\item[\descriptiontitle{Description}] Methods to set \hyperref[lmcoordsys.TCoordSys-XPos]{XPos} and \code{YPos} properties.
\end{itemize}
\paragraph{SetAxisPen, SetGridPen, SetOutputPen}\hspace*{\fill}
\label{lmcoordsys.TCoordSys-SetAxisPen}
\index{SetAxisPen}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			protected procedure SetAxisPen(APen:TPen); virtual;\\
			protected procedure SetGridPen(APen:TPen); virtual;\\
			protected procedure SetOutputPen(APen:TPen); virtual;}
	\end{flushleft}
	\item[\declarationitem{Declaration}\hfill] Methods to set \hyperref[lmcoordsys.TCoordSys-AxisPen]{AxisPen}, GridPen and OutputPen properties, used for drawing the coordinate system and user's output.
\end{itemize}
\section{Functions and Procedures}
\subsection{Register}
\label{lmcoordsys-Register}
\index{Register}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
\begin{flushleft}
\code{
procedure Register;}

\end{flushleft}

\end{itemize}
\section{Constants}
\subsection*{ColorAxis}
\label{lmcoordsys-ColorAxis}
\index{ColorAxis}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
\begin{flushleft}
\code{ColorAxis      =  clBlack;}
\end{flushleft}
\item[\descriptiontitle{Description}]
Axis color, black.
\end{itemize}
\subsection*{ColorBack}
\label{lmcoordsys-ColorBack}
\index{ColorBack}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
\begin{flushleft}
\code{
ColorBack      =  clSilver;}
\end{flushleft}
\item[\descriptiontitle{Description}]
Background color, Light Gray.
\end{itemize}
\subsection*{ColorText}
\label{lmcoordsys-ColorText}
\index{ColorText}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
\begin{flushleft}
\code{
ColorText      =  clRed;}
\end{flushleft}
\item[\descriptiontitle{Description}]
Text color, red.
\end{itemize}
\subsection*{ColorGridLines}
\label{lmcoordsys-ColorGridLines}
\index{ColorGridLines}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
\begin{flushleft}
\code{
ColorGridLines = clWhite;}
\end{flushleft}
\item[\descriptiontitle{Description}]
Grid lines color, white.
\end{itemize}
\subsection*{ColorOutput}
\label{lmcoordsys-ColorOutput}
\index{ColorOutput}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
\begin{flushleft}
\code{
ColorOutput    =  clBlue;}
\end{flushleft}
\item[\descriptiontitle{Description}]
Blue. Default color of user data, put by PutPoint, PutLine, LineTo. May be changed by SetOutputColor
\end{itemize}
\subsection*{UpperLimitForFixedFormat}
\label{lmcoordsys-UpperLimitForFixedFormat}
\index{UpperLimitForFixedFormat}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
\begin{flushleft}
\code{
UpperLimitForFixedFormat = 1E7;}
\end{flushleft}
\item[\descriptiontitle{Description}]
everything outside [LowerLimitForFixedFormat..UpperLimitForFixedFormat] is written in ingeneer notation (e.g.1.0E9)
\end{itemize}
\subsection*{LowerLimitForFixedFormat}
\label{lmcoordsys-LowerLimitForFixedFormat}
\index{LowerLimitForFixedFormat}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
\begin{flushleft}
\code{
LowerLimitForFixedFormat = 1E-4;}
\end{flushleft}
\end{itemize}

\chapter{Unit lmNumericEdits}
\label{lmnumericedits}
\index{lmnumericedits}
\section{Classes, Interfaces, Objects and Records}
\subsection{TFloatEdit Class}
\label{lmnumericedits.TFloatEdit}
\index{TFloatEdit}
\paragraph{Hierarchy}\hspace*{\fill}

TFloatEdit {$>$} TEdit
\subsubsection{Declaration}
\begin{verbatim}
TFloatEdit = class(TEdit)
protected
  procedure TextChanged; override;
  procedure SetDecimals(ADecimals: Integer); virtual;
  procedure SetValue(const AValue: Float); virtual;
  procedure SetValueEmpty(const AValue: Boolean); virtual;
  procedure KeyPress(var Key: char); override;
public
  constructor Create(TheOwner: TComponent); override;
  procedure PasteFromClipboard; override;
  function ValueToStr(const AValue: Float): String; virtual;
published
  property DecimalPlaces: Integer read FDecimals write SetDecimals default 2;
  property Value: Float read FValue write SetValue;
  property ValueEmpty: Boolean read FValueEmpty write SetValueEmpty default False;
end;
\end{verbatim}
\paragraph{Description}\hspace*{\fill}

TFloatEdit\paragraph{Properties}\hspace*{\fill} class defines an Edit component for float numbers. Usage: Drop the component on a form; set and read \code{Value} property. 
\begin{itemize}\label{lmnumericedits.TFloatEdit-DecimalPlaces}
\index{DecimalPlaces}
\item[\inlineitem{DecimalPlaces}\hfill]
\begin{flushleft}
\code{
published property DecimalPlaces: Integer default 2;}
\end{flushleft}
\label{lmnumericedits.TFloatEdit-Value}
\index{Value}
\item[\inlineitem{Value}\hfill]
\begin{flushleft}
\code{
published property Value: Float;}
\end{flushleft}
\label{lmnumericedits.TFloatEdit-ValueEmpty}
\index{ValueEmpty}
\item[\inlineitem{ValueEmpty}\hfill]
\begin{flushleft}
\code{
published property ValueEmpty: Boolean default False;}
\end{flushleft}
\item[\descriptiontitle{Description}]
Is \code{true} if \code{Text} contains invalid or empty string. If a user sets \code{ValueEmpty := true}, \code{Text} becomes empty string.
\end{itemize}
\paragraph{Methods}\hspace*{\fill}

\paragraph{TextChanged}\hspace*{\fill}

\label{lmnumericedits.TFloatEdit-TextChanged}
\index{TextChanged}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
\begin{flushleft}
\code{protected procedure TextChanged; override;}
\end{flushleft}
\item[\descriptiontitle{Description}] Tries to convert \code{Text} to Float. If successful, assigns result of convertion to \code{Value} and sets \code{ValueEmpty} to False. Otherwise, sets \code{ValueEmpty} to True.
\end{itemize}
\paragraph{KeyPress}\hspace*{\fill}
\label{lmnumericedits.TFloatEdit-KeyPress}
\index{KeyPress}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
\begin{flushleft}
\code{
protected procedure KeyPress(var Key: char); override;}
\end{flushleft}
\item[\descriptiontitle{Description}] Filters out all symbols except decimal digits, ``+'',``-'',``E'',``.'' and ``,''. ``.'' and ``,'' are automatically converted to valid locale-dependent decimal separator.
\end{itemize}
\paragraph{Create}\hspace*{\fill}
\label{lmnumericedits.TFloatEdit-Create}
\index{Create}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
\begin{flushleft}
\code{
public constructor Create(TheOwner: TComponent); override;}
\end{flushleft}
\end{itemize}
\paragraph{ValueToStr}\hspace*{\fill}
\label{lmnumericedits.TFloatEdit-ValueToStr}
\index{ValueToStr}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
\begin{flushleft}
\code{
public function ValueToStr(const AValue: Float): String; virtual;}
\end{flushleft}
\item[\descriptiontitle{Description}] Converts \code{Value} to \code{String} according to \code{DecimalPlaces}. 
\end{itemize}
\section{Functions and Procedures}
\subsection{Register}
\label{lmnumericedits-Register}
\index{Register}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
\begin{flushleft}
\code{
procedure Register;}

\end{flushleft}

\end{itemize}
\chapter{Unit lmnumericinputdialogs}
\label{lmnumericinputdialogs}
\index{lmnumericinputdialogs}
\section{Functions and Procedures}
\subsection{IntervalQuery}
\label{lmnumericinputdialogs-IntervalQuery}
\index{IntervalQuery}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
\begin{flushleft}
\code{
function IntervalQuery(ACaption, APrompt1, APrompt2 : string; var AInterval:TInterval):boolean;}

\end{flushleft}

\par
\item[\descriptiontitle{Description}]
input dialog with two float edits. Sets TInterval; one edit is for Low, other for High. Returns True if was closed with OK, false otherwise. If one or both edits do not contain valid values, the dialog cannot be closed with ``OK''.

\end{itemize}
\subsection{FloatInputDialog}
\label{lmnumericinputdialogs-FloatInputDialog}
\index{FloatInputDialog}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
\begin{flushleft}
\code{
function FloatInputDialog(const InputCaption, InputPrompt : String; var AValue : Float) : Boolean;}
\end{flushleft}
\item[\descriptiontitle{Description}]
Input dialog for Float input. True if was closed with OK and EditBox contains valid value, false otherwise. 
\end{itemize}
\end{document}
