
\documentclass[12pt,a4paper,oneside]{article}
\usepackage[top=1in, bottom=1in, left=1.5in, right=1.0in]{geometry}
\usepackage[margin=10pt,font=small,labelfont=bf,labelsep=endash]{caption} % figures and tables caption options
\usepackage{graphicx}
\DeclareGraphicsExtensions{.pdf,.png} % pdf precedes png
\graphicspath{illustrious} %where to look for graphics
\usepackage{enumitem}
\usepackage[compact]{titlesec}
\usepackage{parskip} % to make skips between paragraphs
\usepackage{nicefrac}
\usepackage{textcomp}
\usepackage{gensymb}
\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt}
\titlespacing*{\chapter}{0pt}{-60pt}{10pt}
\titleformat{\chapter}[display]{\normalfont\LARGE\bfseries}{\chaptertitlename\ \thechapter}{10pt}{}
\titleformat{\section}[hang]{\normalfont\Large\bfseries}{\thesection\ }{0pt}{}
\titleformat{\subsubsection}[block]{\normalfont\large\bfseries}{}{0pt}{}
\titleformat{\paragraph}[runin]{\normalfont\normalsize\bfseries}{}{0pt}{}
\usepackage{amsmath}
\usepackage{xcolor}
\definecolor{darkblue}{RGB}{0,0,128}
\usepackage[pdftex]{hyperref}
\hypersetup{
	colorlinks   = true, %Colours links instead of ugly boxes
	urlcolor     = darkblue, %Colour for external hyperlinks
	linkcolor    = darkblue, %Colour of internal links
	citecolor	 = darkblue, %Colour of citations
	pdftitle	 ={LMath New Functions},
	pdfauthor	 ={Viatcheslav Nesterov},
	pdfsubject	 ={Reference for new functions in LMath library},
	pdfkeywords	 ={pascal, object pascal, mathematics, math, library, science, programming, scientific programming}
}
\newcommand{\euler}{\mathrm{e}}
\newcommand{\keyword}[1]{\textbf{#1}}
\newcommand{\declarationitem}[1]{\textbf{#1}}
\newcommand{\descriptiontitle}[1]{\textbf{#1}}
\newcommand{\code}[1]{\texttt{#1}}
\begin{document}
\title{LMath for DMath users\\
{\Large Reference Guide to New and Changed Functions and Behavior}}
\author{Viatcheslav V. Nesterov}
\maketitle
\newpage
\label{toc}\tableofcontents
\newpage
 %special variable used for calculating some widths.
\newlength{\tmplength}
\section{General Notes}
\subsection{Purpose of this manual}
LMath is a further development of DMath library by Jean Debord. Most of available functions are described in the \hyperref{file:DMath.pdf}{}{}{manual for DMath}. However, LMath changes names or behavior of some DMath functions and adds some new ones. This document contains brief description of such changes and additions. More formal definitions can be found in the \hyperref{file:LMath05.pdf}{}{}{Reference Guide for LMath}.  
\subsection{Installation and use of the library}
First, download LMath\_and\_Components061.zip from the official site of the program. 
You can download and use trunk of SVN repository to study and research the latest development, but I do not guarantee that code in the trunk was properly tested or even that it is a working code at all. 

LMath is organized as a set of Lazarus packages. Their complete list is located in the \hyperref{file:LMath05.pdf}{}{}{Reference Guide}. To install, copy directory structure contained in LMath\_and\_Components.zip on your hard drive and compile packages (.lpk files) in the following order:\\
lmGenMath; lmMathUtil; lmIntegrals.lpk; lmLinearAlgebra; lmMathStat; lmRandoms; lmOptimum; lmNonLinEq; lmPolynoms; lmPlotter; lmRegression; \\ lmSpecRegress, lmDSP. Finally, compile LMath.lpk.
 
For maximally broad compatibility, all LPK files have low level of optimization in options. Change them before compilation of final version of your program to the settings, optimal for your system. Try optimization levels 3 or 4. If you compile 32-bit packages and applications, for modern systems you may want to use -OpCOREAVX2 and -CfAVX2 options. Consider also use of -OoFASTMATH and -OoLOOPUNROLL. 

Conversely, if you get weird errors, inspect options of the packages and make sure that they are indeed conservative enough.

See \href{https://wiki.freepascal.org/Optimization}{Free Pascal Wiki} for more details about optimizations.
 
There is no need to install packages from LMath in the lazarus IDE. If you plan to use LMComponents, LMComponents.lpk must be installed, and it installs rather large subset of LMath. To use the library in your programs, add needed packages to the requirements of your project and, of course, necessary units in your \code{uses} clause. Alternative to adding every needed package, you can add to requirements the general LMath package.

Before LMath ver. 0.5, names of both packages and units began with ''u'', since 0.5 names for packages begin with ''lm''. 

In contrast to DMath, no special means for compilation of LMath as a shared library is provided. I find it unlikely that anybody would use this library in a language other then pascal, and in pascal it is always more convenient to have a single executable than an executable and required external libraries.
\section{Note about array indexing in DMath and LMath}
It must be noted here that many functions in DMath/LMath library were translated or adapted from Fortran which has two notable differences from Pascal. First, it keeps arrays in the order ``columns first'', while Pascal keeps them as ``rows first''. Consequently, many algorithms included in this library are optimized for ``columns first'' order which seriously slows down the Pascal implementation. We hope to address this issue, at least partially, in later versions of the library.

Second, in Fortran array indexing begins from ``1'', while in Pascal from ``0''. In DMath/LMath, many internal procedures are written in Fortran manner, beginning numeration with ``1'' which in Pascal implementation means of course that a first element of an array, indexed ``0'', remains unused. This is a small price which we pay for the possibility to use algorithms developed in Fortran without modifications and introducing new bugs. 

However, it would be somewhat awkward to force the users of the library adopt ``1''-based indexing. This is one of the reasons that in most cases when an array is passed as a parameter to a routine of the library, there are additional parameters \code{Lb} and \code{Ub} which stands for ``Low bound'' and ``Upper bound'' and which define a slice of an array on which the operation must be performed. Typically, \code{Lb} can be ``0'' or ``1'' and \code{Ub} can be \code{High(Passed\_array)} although of course they may take any values in between provided that $Lb<Ub$. This convention makes our library more flexible, although, admittedly, at the expense of more complicated syntax. When ``0''-based or ``1''-based array is mentioned in this manual, it means that actual data begin from index 0 or 1; technically, all dynamic arrays in Object Pascal are 0-based.
\section{Using open array parameters: LMath 0.6 and later.}
\code{Lb, Ub} convention adopted by DMath and LMath is rather flexible, but has two drawbacks: first, the calls are rather complicated with a lot of parameters passed and, second, passing TVector as a parameter excludes use of static arrays. Modern Pascal allows to define open array parameters and, importantly, pass subarrays to the procedures and functions. Use of open arrays allows to make calls more concise when a complete array must be passed, yet even more flexible when only partial array is needed. Therefore, beginning from LMath 0.6.0, many functions and procedures with open array parameters instead of \code{TVector, Lb, Ub} are developed. Older versions are kept as well.

Now, what must be kept in mind, and is important. Passing for example \\
SomeFunc(V,2,5):TVector in the form \code{TVector, Lb, Ub} and \\
SomeProc(V[2..5], R):TVector in the form \code{Open Array} \\ would not be the same, because in the first case the whole array is passed to the function and returned, but whatever it does is applied to a slice \code{[2..5]}, while in the second case only part of the array is passed and returned. This is the reason why in some cases, when it is important, functions were converted to procedures.  
  
\section{Changes since version 0.4 which may require modification of calling code}
\begin{enumerate}
	\item In \code{function CriticalPoints}, unit \code{uCrtPtPol}, allocation of \code{CrtPoints} and \code{PointTypes} prior to function call is not necessary. The function can allocate them itself.
	\item Indexing of \code{Minima} and \code{Maxima} returned by \code{FindSplineExtremums} begins now from 1 and not from 0. Reason: internal consistency of the library.
	\item Various \code{Dim*Vector} and \code{Dim*Matrix} functions were replaced by overloaded universal \code{DimVector} and \code{DimMatrix}.
	\item Package lmLineAlgebra was renamed to lmLinearAlgebra.  
\end{enumerate}
\section{Error handling}
Mechanisms of error handling in DMath and LMath are defined in \code{uErrors} unit. In DMath, success or failure of a function was defined by a numeric error code, which could be checked by call of \code{MathErr} function.
However, numeric error code is not particularly informative, especially for end users. Therefore, in LMath numeric error codes are supplemented with text error messages. With this purpose, array of strings, corresponding to error codes was defined in \code{uErrors} unit. List of standard error codes and messages can be found in the \textit{uErrors} section in \hyperref{file:LMath05.pdf}{}{}{LMath Reference Guide}. Additionally, a user can define own error codes and messages and set them by call of
\begin{verbatim}
procedure SetErrCode(ErrCode : Integer; EMessage : string = '');
\end{verbatim}
If \code{EMessage} parameter remains empty and ErrCode is a standard error code, then corresponding message from the standard list is set. Otherwise, error message is set to \code{EMessage}. Error code can be retrieved by call of
\begin{verbatim}
function MathErr : Integer;
\end{verbatim}
and text message with\\
\code{function MathErrMessage : string;}

\noindent Note that both functions must be called immediately after the call to mathematical function, before they could be rewritten by a call of another function. This may be changed in later versions.
\section{NAN and tests for approximate equality}
Due to rounding errors, testing floating numbers for exact equality can be unreliable. Therefore, unit \code{uTypes} in LMath defines following functions for approximate equality:
\begin{verbatim}
function IsZero(F: Float; Epsilon: Float = -1): Boolean;
function SameValue(A, B: Float; epsilon:float): Boolean; overload;
function SameValue(A,B:Float):boolean; overload;
\end{verbatim}
\code{IsZero} returns true if $\left| F \right| < epsilon$. If parameter \code{epsilon} is not used, it is set by default to \code{MachEp/8} where MachEp is floating point precision, see \hyperref{file:LMath05.pdf}{}{}{Reference Guide for LMath}. Default value of \code{epsilon} for \code{SetZero} can be changed with the help of \\
\code{procedure SetZeroEpsilon(AZeroEpsilon:float)}.

First of \code{SameValue} functions returns true if $\left| A - B \right| < epsilon$. Third function is most sophisticated, it uses comparison with epsilon scaled to the scale of compared numbers. 

Besides that, constants \code{NAN} (not a number), \code{Infinity} and \code{NegInfinity} are defined and function \code{IsNAN}. \code{NAN} and \code{IsNAN} are used in LMath to represent and check missing values in some statistical functions, see Section \ref{sec:statistics}.
\section{General purpose functions and procedures}
In DMath, \code{uTypes} unit contained a family of functions \code{Dim*Vector} and \code{Dim*Matrix} for allocation of arrays of different base types. In LMath, procedures \code{DimVector} and \code{DimMatrix} are overloaded for different types:
\begin{verbatim}
procedure DimVector(var V : TVector; Ub : Integer); 
procedure DimVector(var V : TIntVector; Ub : Integer);
procedure DimVector(var V : TCompVector; Ub : Integer);
procedure DimVector(var V : TRealPointVector; Ub: Integer);
procedure DimVector(var V : TBoolVector; Ub : Integer);
procedure DimVector(var V : TStrVector; Ub : Integer); 	

procedure DimMatrix(var A : TMatrix; Ub1, Ub2 : Integer);
procedure DimMatrix(var A : TIntMatrix; Ub1, Ub2 : Integer);
procedure DimMatrix(var A : TCompMatrix; Ub1, Ub2 : Integer);
procedure DimMatrix(var A : TBoolMatrix; Ub1, Ub2 : Integer);
procedure DimMatrix(var A : TStrMatrix; Ub1, Ub2 : Integer);
\end{verbatim}
Similarly, following general procedures for scalars are defined:
\begin{verbatim}
function Min(X, Y : Float) : Float;
function Min(X, Y : Integer) : Integer;
function Max(X, Y : Float) : Float;
function Max(X, Y : Integer) : Integer;
function Sgn(X : Float) : Integer;
function Sgn(X : integer) : integer; 
function Sgn0(X : Float) : Integer;
function Sgn0(X : integer) : integer;
function DSgn(A, B : Float) : Float;
function Sign(X: Float):integer; inline;
function IsNegative(X: float):boolean;
function IsNegative(X: Integer):boolean;
function IsPositive(X: float):boolean;
function IsPositive(X: Integer):boolean; 
procedure Swap(var X, Y : Float);
procedure Swap(var X, Y : Integer);
\end{verbatim}
\code{Function Sign} has the same semantic as \code{Sgn0} and was introduced for compatibility with Math unit.
\section{New Operators}
Free Pascal allows to overload operators. LMath took advantage of this feature. It defines operator \code{**} for exponentiation for \code{Float} in \code{integer} degree and \code{Float} in \code{Float} degree.

For complex numbers (type \code{complex}), unit \code{uComplex} in LMath defines  operators \code{+,-,*,/, =} (comparison) for \code{complex} and \code{float} in all meaningful combinations. This part is largely based on ideas from uComplex unit by Pierre Müller.

Operators defined for work with other structural types will be discussed in the next chapter where corresponding types are discussed.

%\chapter{New Types}
\section{TInterval}
Type \code{TInterval} defined in \code{uInterval} unit describes an interval on a numeric axis:
\begin{verbatim}
TInterval = record
  Lo:float;
  Hi:float;
  function Length:float;
end;
\end{verbatim}
Function \code{Length} returns the length of this interval, that is, $Hi-Lo$.
This type is useful for example in the tasks of signal processing where it can represent a window in finite impulse response filters. Another use is presentation of a fragment of axis shown on a screen or printout.

\noindent Following functions and procedures are defined over this type:
\vskip 6pt
\noindent\code{function IntervalsIntersect(Lo1, Hi1, Lo2, Hi2:Float):boolean; overload;\\}
Returns true if intervals [Lo1; Hi1] and [Lo2; Hi2] intersect.
\begin{verbatim}
function IntervalsIntersect(Lo1, Hi1, Lo2, Hi2:Integer):boolean;
function IntervalsIntersect(Interval1, Interval2:TInterval):boolean;
\end{verbatim}\vspace{-6pt}	
Returns true if intervals [Lo1; Hi1] and [Lo2; Hi2] intersect.
\begin{verbatim}
function Contained(ContainedInterval,ContainingInterval:TInterval):boolean;
\end{verbatim}\vspace{-6pt}	
Returns true if interval ContainedInterval is located completely inside ContainingInterval:\\
 \code{(ContainedInterval.Lo > ContainingInterval.Lo) and \\
 (ContainedInterval.Hi < ContainingInterval.Hi)}.
\begin{verbatim}
function Intersection(Interval1, Interval2:TInterval):TInterval;
\end{verbatim}	
Returns intersection of Interval1 and Interval2. If they have no intersection, result is (0;0)
\begin{verbatim}
function Inside(V:Float; AInterval:TInterval):boolean; overload;
\end{verbatim}\vspace{-6pt}	
True if V is inside \code{AInterval}.
\begin{verbatim}
function Inside(V:float; ALo, AHi:float):boolean; overload;
\end{verbatim}\vspace{-6pt}	
True if \code{V} is inside \code{(ALo, AHi)} (similar to \code{Math.InRange})
\begin{verbatim}
function IntervalDefined(AInterval:TInterval):boolean;
\end{verbatim}\vspace{-6pt}	
True if \code{AInterval.Lo} $<$ \code{AInterval.Hi}.
\begin{verbatim}
function DefineInterval(ALo,AHi:Float):TInterval;
\end{verbatim}\vspace{-6pt}	
Constructs \code{TInterval} from \code{ALo} and \code{AHi}.
\begin{verbatim}
procedure MoveInterval(V:float; var AInterval:TInterval);
\end{verbatim}\vspace{-6pt}	
Move interval by a value (it is added to both \code{Lo} and \code{Hi})
\begin{verbatim}
procedure MoveIntervalTo(V:Float; var AInterval:TInterval);
\end{verbatim}\vspace{-6pt}	
Move interval to a value (\code{Lo} is set to this value, \code{Hi} adjusted such that length remains constant).
\section{TRealPoint and TRealPointVector}
\label{sec:trealpoint}
\code{TRealPoint} represents simply point on a Cartesian plane, \code{PRealPoint} is a typed pointer on \code{TRealPoint} and \code{TRealPointVector} is an array of \code{TRealPoint} which is often useful as a representation of a signal or function in a tabbed form.
\begin{verbatim}
PRealPoint = ^TRealPoint;
TRealPoint = record
  X: Float;
  Y: Float;
end;
TRealPointVector =  array of TRealPoint;
\end{verbatim}
\noindent
Unit \code{uRealPoints} defines several functions and operators over \code{TRealPoint} treating it as a vector in 2-dimentional space.
\begin{verbatim}
function SameValue(P1,P2 : TRealPoint; epsilonX : float = -1; 
              epsilonY:float = -1):boolean;
\end{verbatim}
Comparison of \code{TRealPoint} using epsilon; epsilon for X and for Y are defined separately. If epsilon is -1, default value as defined by \code{SetEpsilon} will be used. If \code{SetEpsilon} was not used, it is \code{MachEp}.
\begin{verbatim}
function rpPoint(AX, AY:float):TRealPoint;
\end{verbatim}\vspace{-6pt}
Constructs a \code{TRealPoint} from two floats.

\begin{verbatim}
function rpSum(P1,P2:TRealPoint):TRealPoint;
\end{verbatim}\vspace{-6pt}
Sum of \code{TRealPoint}.

\begin{verbatim}
function rpSubtr(P1, P2:TRealPoint):TRealPoint;
\end{verbatim}\vspace{-6pt}
Subtraction of \code{TRealPoint}.

\begin{verbatim}
function rpMul(P:TRealPoint; S:Float):TRealPoint;
\end{verbatim}\vspace{-6pt}
Multiplication of \code{TRealPoint} by Scalar.

\begin{verbatim}
function rpDot(P1, P2:TRealPoint):Float;
\end{verbatim}\vspace{-6pt}
Dot product of \code{TRealPoint}.

\begin{verbatim}
function rpLength(P:TRealPoint):Float;
\end{verbatim}\vspace{-6pt}
Length of vector, represented by \code{TRealPoint}.

\begin{verbatim}
function Distance(P1, P2:TRealPoint):Float;
\end{verbatim}\vspace{-6pt}
Distance between two \code{TRealPoint} on cartesian plane.

These operations may be invoked also in operator form:\\
\code{P1 + P2} where \code{P1} and \code{P2} are \code{TRealPoint}: summation (equivalent of \code{rpSum}).\\
\code{P1 - P2} is substraction (equivalent of \code{rpSubstr}).\\
\code{P * S} or \code{S * P} where P is TRealPoint and \code{S} is scalar is multiplication by scalar (equivalent of \code{rpMul}).\\
\code{P1 * P2} where \code{P1} and \code{P2} are \code{TRealPoint} is dot product (equivalent of \code{rpDot}).

\section{TIntegerPoint}
\code{TIntegerPoint} similarly to \code{TRealPoint} represents a point on a Cartesian plane, but with integer coordinates, mainly pixel coordinates on a screen or canvas.
\begin{verbatim}
PIntegerPoint = ^TIntegerPoint;
TIntegerPoint = record
  X : integer;
  Y : integer;
end;
\end{verbatim}
Unit \code{uIntPoints} defines few functions and operators over \code{TIntegerPoint}.
\begin{verbatim}
function ipPoint(AX, AY:integer):TIntegerPoint;
\end{verbatim}\vspace{-6pt}
Constructs of TIntegerPoint from two integers
\begin{verbatim}
function ipSum(P1,P2:TIntegerPoint):TIntegerPoint;
\end{verbatim}\vspace{-6pt}
Summation of TIntegerPoint.
\begin{verbatim}
function ipSubtr(P1, P2:TIntegerPoint):TIntegerPoint;
\end{verbatim}\vspace{-6pt}
Subtraction of TIntegerPoint

\begin{verbatim}
function ipMul(P:TIntegerPoint; S:integer):TIntegerPoint;
\end{verbatim}\vspace{-6pt}
Multiplication of TIntegerPoint by Integer.

\noindent Same operations may be invoked in operator form:\\
\code{P1 + P2} or \code{P1 - P2} where P1 and P2 are \code{TIntegerPoint}.\\
\code{P * S} or \code{S * P} where P is \code{TIntegerPoint} and \code{S} is integer.

%\chapter{Arrays and Linear Algebra}

\section{Derivative and Critical Points of a Polynom}
Unit \code{ucrtptpol} defines two routines needed for investigation of polynomial functions.
\begin{verbatim}
procedure DerivPolynom(Coef:TVector; Deg:integer;
   DCoef:TVector; out DDeg:integer);
\end{verbatim}\vspace{-6pt}
finds an expression for a derivative of input polynomial of degree \code{Deg}. This derivative is, obviously, polynomial of \code{Deg-1} degree. Input parameters: \code{Coef} is 0-based array of coefficients of the input polynomial, beginning from free member, such that array index is equal to the degree of corresponding member. \code{Deg} is degree of the input polynomial. Output: DCoef: coefficients of derivative polynomial, DDeg is degree of derivative polynomial. For example, to find a derivative of polynomial
$$2x^4+3x^3+x-2:$$
\begin{verbatim}
uses uTypes, uVectorHelper, ucrtptpol;
const
  Deg = 4; 
var
  Coefs, DCoefs : TVector; 
  DDeg : integer;  
begin
  Coefs.FillWithArr(0,[-2,1,0,3,2]);
  DerivPolynom(Coefs, Deg, DCoefs, DDeg);
end;
\end{verbatim}
To find critical points, where derivative is zero, use \vspace{-6pt}
\begin{verbatim}
function CriticalPoints(Coef:TVector; Deg:integer; 
      CtrPoints: TRealPointVector; 
         PointTypes:TIntVector; ResLb : integer = 1):integer;
\end{verbatim}
\code{Coef} and \code{Deg} have same meaning as in \code{DerivPolynom} function, \code{Coef} is similarly 0-based. \code{CrtPoints} of \hyperref[sec:trealpoint]{TRealPoints} type contains upon call  abscissas in \code{X} and ordinates in \code{Y} of critical points found, and \code{PointTypes} contain information about the type (-1 for minimum, 1 for maximum or 0 for no extremum) of every found critical point. CrtPoints and PointTypes place meaningful infortmation beginning from index \code{ResLb}, by default 1. 
Example:
\begin{verbatim}
  NCrtP := CriticalPoints(Coefs,Deg,CrtP,PointTypes);
\end{verbatim}
Example programs to these functions are \code{extremum.lpr} and \code{polyderiv.lpr} located at \code{demo/console/polynoms}. 
\section[Utility types and functions for work with arrays]{Utility types and functions for work with\\ arrays}
\subsection{uVectorHelper}
Unit \code{uVectorHelper} in the package \code{lmMathUtil} defines type helpers for \code{TVector} and \code{TIntVector} to make more convenient simple operations with vectors, such as filling with a value or array at the initialization, swapping two elements, sorting or string representation.

Beginning from ver. 3.2, Free Pascal supports intrinsic procedures Delete() and Insert() over dynamic arrays with functionality similar to \code{Insert} and \code{Remove} implemented here. \textit{However, unlike these intrinsics, our procedures do not change length of an array.} Insert() leads to the loss of last elements of an array; Remove() appends zeroes at the end of the array. This implementation avoids call to \code{SetLength} at each deletion/insertion, making the code faster. Use standard procedures if you need changed length.     
\begin{verbatim}
TVectorHelper = type helper for TVector
  procedure Insert(value:Float; index:integer);
  procedure Remove(index:integer);
  procedure Swap(ind1,ind2:integer);
  procedure Fill(Lb, Ub : integer; Val:Float);
  procedure FillWithArr(Lb : integer; Vals:array of Float);
  procedure Sort(Descending:boolean);
  procedure InsertFrom(Source:TVector; Lb, Ub: integer; ind:integer);
  function ToString(Index:integer):string;
  function ToStrings(Dest:TStrings; First, Last:integer;
  Indices:boolean; Delimiter: char):integer;
end;

{ TIntVectorHelper }

TIntVectorHelper = type helper for TIntVector
  procedure Insert(value:Integer; index:integer);
  procedure Remove(index:integer);
  procedure Fill(Lb, Ub : integer; Val:Integer);
  procedure FillWithArr(Lb : integer; Vals:array of Integer);
  procedure InsertFrom(Source:TIntVector; Lb, Ub:integer; ind:integer);
  procedure Swap(ind1,ind2:integer);
  function ToString(Index:integer):string;
  function ToStrings(Dest:TStrings; First, Last:integer;
  Indices:boolean; Delimiter: char):integer;
end;
\end{verbatim}
These types are similar and will be described here together.

\code{Procedure Insert} inserts a value into position \code{index}, all following elements of array are shifted to the right. Last element is lost. 

\code{Procedure Remove} is opposite to \code{insert}. It removes an element in position index; following elements shifted to the left. Last element is set to 0.

\code{Procedure Fill} Fills \code{Self} from \code{Self[Lb]} to \code{Self[Ub]} with \code{Val} replacing old values. If \code{En} $>$ \code{High(Self)} then \code{Self} is filled to its end.

\code{Procedure FillWithArr} fills \code{Self} beginning from \code{Self[Lb]} with the elements of array \code{Vals} replacing old values. If \code{length(Vals)} $>$ \code{High(Self)-Lb} then only part of Vals is used. Main purpose of this procedure is convenient array initialization.

\code{Procedure InsertFrom} inserts elements of source in the range \code{Source[Lb]} to \code{Source[Ub]} into \code{Self} beginning from position \code{Self[Ind]}. All following elements are shifted to the right. Rightmost \code{Ub - Lb} elements of \code{Self} are lost.

If \code{Self} was not allocated prior to the call of \code{Fill}, \code{FillWithArr} or \code{InsertFrom}, its length is set to the necessary values, otherwise length of \code{Self} is not changed by any of these methods. If length of arrays in \code{FillWithArr} or \code{InsertFrom}, they are used only partially such that \code{Self} is filled up to existing \code{High(Self)}. All \code{Insert*} procedures overwrite last part of the array, therefore, if necessary, call \code{SetLength} or \code{DimArray} before call to these procedures. We do it this way for two reasons. First, all these procedures can be applied to the lines of a matrix and we do not want ragged matrices. Second, \code{SetLength} is very expensive and it is better to avoid its call for every insertion. 

\code{procedure Swap} swaps elements in positions Ind1 and Ind2.

\code{Function ToString} returns a string representation of a value at a position \code{Index}.

\code{Procedure ToStrings} sends string representations of elements from \code{First} to \code{Last} into \code{Dest:TStrings}. If \code{Indices} is true, then each line contains element index, delimiter as defined at the function call, and value of the corresponding element.

These methods use \code{FloatStr} and \code{IntStr} functions from \code{uStrings} unit for formatting. 

\subsection{uVecUtils}
This unit defines several handy functions and procedures for work with one- and two-dimensional arrays.
\subsubsection{Types}
\begin{verbatim}
TTestFunc    = function(X:Float):boolean;
TIntTestFunc = function(X:Integer):boolean;

TMatCoords = record
  Row, Col :integer;
end;
\end{verbatim}
\code{TTestFunc} and \code{TIntTestFunc} are used as arguments for functions described below. \code{TMatCoord} represents a position of an element in a matrix.
\subsubsection{tmCoords}
\code{function tmCoords(ARow,ACol:integer):TMatCoords;}\\
Function \code{tmCoords} constructs \code{TMatCoords} from two integers.
\subsubsection{Apply}
Procedure \code{Apply} applies a function to every element of an array in a range from Lb to Ub. Applied function must have a type \code{TFunc} for arrays of \code{Float} and \code{TIntFunc} for arrays of \code{Integer}. Both are defined in \code{uTypes} unit. \code{Apply} passes an element of an array to this function and assigns the result to the element. It is defined for \code{TVector}, \code{TMatrix}, \code{TIntVector} and \code{TIntMatrix}:
\begin{verbatim}
Procedure Apply(V:TVector; Lb, Ub: integer; Func:TFunc);
procedure Apply(M:TMatrix; LRow, URow, LCol, UCol: integer; 
   Func:TFunc);
procedure Apply(V:TIntVector; Lb, Ub: integer; Func:TIntFunc);
procedure Apply(M:TIntMatrix; LRow, URow, LCol, UCol: integer;
   Func:TIntFunc); 
\end{verbatim}
Besides that, exists a masked version of \code{Apply} which applies the function only to elements with indices listed in additional array mask.
\begin{verbatim}
procedure Apply(V:TVector; Lb, Ub: integer; 
          Mask:TIntVector; MaskLb:integer; Func:TFunc);
procedure Apply(V:TIntVector; Lb, Ub: integer;
          Mask:TIntVector; MaskLb:integer; Func:TIntFunc); 
\end{verbatim} 
\subsubsection{CompVec}
Function \code{CompVec} checks if each element of vector X is within a fraction Tol of	the corresponding element of the reference vector Xref. In this case, the function returns True, otherwise it returns False.
\begin{verbatim}
function CompVec(X, Xref : TVector; Lb, Ub  : Integer; 
   Tol : Float) : Boolean;
\end{verbatim}
\subsubsection{Any}
Function \code{Any} applies test function (TTestFunc or TIntTestFunc) to every element of a target array and returns \code{True} if the test function returns \code{True} for at least one element. 

\begin{verbatim}
function Any
    (Vector:TVector; Lb, Ub : integer; Test:TTestFunc):boolean;
function Any
    (M:TMatrix; LRow, URow, LCol, UCol : integer; 
    Test:TTestFunc):boolean;
function Any(Vector:TIntVector; Lb, Ub : integer;
    Test:TIntTestFunc):boolean; 
function Any(M:TIntMatrix; LRow, URow, 
    LCol, UCol : integer; Test:TIntTestFunc):boolean; 
\end{verbatim}
\subsubsection{FirstElement}
Function \code{FirstElement} returns a position of a first element which satisfies a condition. The function is implemented for \code{TVector}, \code{TIntVector}, \code{TMatrix} and \code{TIntMatrix}. In the latter two cases position is returned as \code{TMatCoords} record:
\begin{verbatim}
TMatCoords = record
  Row, Col :integer;
end;
\end{verbatim}
If nothing is found, the function returns $Ub+1$.

Search condition may be defined in several ways. First, with the help of test function, same way as implemented in \code{Any}. 
\begin{verbatim}
function FirstElement(Vector:TVector; Lb, Ub : integer; 
   Test:TTestFunc):integer;
function FirstElement(M:TMatrix; LRow, URow, LCol, UCol : integer;
   Test:TTestFunc):TMatCoords;
\end{verbatim}
In a second implementation, a user defines a reference value and type of comparison. Type of comparison is represented by a parameter of type \code{TCompOperator} which is defined in \code{uTypes} unit as follows:\\
\code{TCompOperator = (LT,LE,EQ,GE,GT,NE);}\\
In this form, \code{FirstElement} returns a position of a first element which satisfies following condition:
\vskip 6pt
\begin{tabular}{c|rcl|}
	Op & \multicolumn{3}{|c|}{Condition}\\
	\hline
	LT & x[I]&$<$&Ref\\ 
	LE & x[I]&$<=$&Ref\\ 
	EQ & x[I]&$=$&Ref\\ 
	GE & x[I]&$>=$&Ref\\ 
	GT & x[I]&$<$&Ref\\ 
	NE & x[I]&$<>$&Ref \\ 
\end{tabular}\\ 
\vskip 6pt
\begin{verbatim}
function FirstElement(Vector:TVector; Lb, Ub : integer; Ref:float;
   CompType:TCompOperator):integer;
function FirstElement(M:TMatrix; LRow, URow, LCol, UCol : integer;
   Ref:float; CompType:TCompOperator):TMatCoords; 

function FirstElement(Vector:TIntVector; Lb, Ub : integer; 
   Ref:integer; CompType:TCompOperator):integer;
function FirstElement(M:TIntMatrix; LRow, URow, LCol, UCol : integer;
   Ref:integer; CompType:TCompOperator):TMatCoords;
\end{verbatim}

This is the most efficient way to call \code{FirstElement} because it does not involve calls of test functions for every element, and calls are expensive. However, if more complex algorithms are needed than simple comparisons, it is possible to build and use a user-defined comparator function:
\begin{verbatim}
function FirstElement(Vector:TVector; Lb, Ub : integer; Ref:float;
   Comparator:TComparator):integer;
function FirstElement(M:TMatrix; LRow, URow, LCol, UCol : integer;
   Ref:float; Comparator:TComparator):TMatCoords;

function FirstElement(Vector:TIntVector; Lb, Ub : integer; Ref:integer;
   Comparator:TIntComparator):integer;
function FirstElement(M:TIntMatrix; LRow, URow, LCol, UCol : integer;
   Ref:integer; Comparator:TIntComparator):TMatCoords; 
\end{verbatim}

\code{TComparator} here is a function which takes two float values as arguments and returns boolean. Similar, \code{TIntComparator} takes two integers and returns boolean. Both TComparator and TIntComparator types are defined in \code{Types} unit as follows:
\begin{verbatim}
TComparator = function(Val, Ref : float): boolean;
TIntComparator = function(Val, Ref : integer): boolean;
\end{verbatim}
Element of an array is passed to a comparator as a first argument, reference value as a second.
\subsubsection{MaxLoc, MinLoc}
Functions \code{MaxLoc} and \code{MinLoc} return position of a maximal or minimal element of an array or a slice of an array.
\begin{verbatim}
function MaxLoc(Vector:TVector; Lb, Ub:integer):integer;
function MaxLoc(M:TMatrix; LRow,URow,LCol,UCol:integer):TMatCoords;

function MaxLoc(Vector:TIntVector; Lb, Ub:integer):integer;
function MaxLoc(M:TIntMatrix; LRow,URow,LCol,UCol:integer):TMatCoords;

function MinLoc(Vector:TVector; Lb, Ub:integer):integer;;
function MinLoc(M:TMatrix; LRow,URow,LCol,UCol:integer):TMatCoords;

function MinLoc(Vector:TIntVector; Lb, Ub:integer):integer;
function MinLoc(M:TIntMatrix; LRow,URow,LCol,UCol:integer):TMatCoords;
\end{verbatim}
\subsubsection{Seq, ISeq}
Functions \code{Seq} and \code{ISeq} generate an arithmetic progression and fill with it a slice of an array between \code{Lb} and \code{Ub}. If prior to the call \code{Vector} is empty, it is allocated with the length \code{Ub + 1} and fills a slice $Lb..Ub$ with the generated sequence:
$$
 First, First + Increment, \dots, First + Increment \cdot (Ub-Lb)  
$$
\begin{verbatim}
function Seq(Lb, Ub : integer; first, increment:Float; 
   Vector:TVector = nil):TVector;
function ISeq(Lb, Ub : integer; first, increment:integer; 
   Vector:TIntVector = nil):TIntVector;
\end{verbatim}
\subsubsection{SelElements and ExtractElements}
Functions of \code{SelElements} family select elements from a source array, which can be of \code{TVector} or \code{TIntVector} type and place their indices into a result array of \code{TIntVector} type. Similar to \code{FirstElement}, selection criteria may be defined with a reference value and type of comparison (\code{TCompOperator} type) or with a reference value and a comparator function of \code{TIntComparator} or \code{TComparator} type.
Selected indices are copied to Result array beginning from ResLb.
Resulting ``mask'' array can be used with masked versions of \code{Apply} procedure. Besides, all corresponding elements can be extracted in a new array using \code{ExtractElements} function (see below).

\begin{verbatim}
function SelElements(Vector:TVector; Lb, Ub, ResLb : integer;
    Ref: float; CompType:TCompOperator):TIntVector;
function SelElements(Vector:TVector; Lb, Ub, ResLb : integer;
    Ref:float; Comparator:TComparator):TIntVector;
function SelElements(Vector:TVector; Lb, Ub, ResLb : integer;
    Test:TTestFunc):TIntVector;

function SelElements(Vector:TIntVector; Lb, Ub, ResLb : integer; 
    Ref: Integer; CompType:TCompOperator):TIntVector; 
function SelElements(Vector:TIntVector; Lb, Ub, ResLb : integer;
    Ref:Integer; Comparator:TIntComparator):TIntVector;
function SelElements(Vector:TIntVector; Lb, Ub, ResLb : integer;
    Test:TIntTestFunc):TIntVector;
\end{verbatim}

Function ExtractElements allows to extract selected elements into a separate \code{TVector}:
\begin{verbatim}
function ExtractElements(Vector:TVector; 
      Mask:TIntVector; Lb:integer):TVector;
\end{verbatim}
Lb is applied for both sourse \code{Vector} and function result.
Demo programs for \code{uVectorHelper} and \code{uVecUtils}  are contained in \code{demo/console/MathUtil} folder. 
\subsection{uVecFunc}
Small unit uVecFunc defines procedures which apply \code{Sqrt} and \code{Abs} functions to every element of a vector or matrix:
\begin{verbatim}
procedure VecAbs(V : TVector; Lb, Ub : integer);
procedure VecAbs(V : TIntVector; Lb, Ub : integer);
procedure MatAbs(M : TMatrix; Lb1, Ub1, Lb2, Ub2 : integer);
procedure MatAbs(M : TIntMatrix; Lb1, Ub1, Lb2, Ub2 : integer);

procedure VecSqr(V : TVector; Lb, Ub : integer);
procedure VecSqr(V : TIntVector; Lb, Ub : integer);
procedure MatSqr(M : TMatrix; Lb1, Ub1, Lb2, Ub2 : integer);
procedure MatSqr(M : TIntMatrix; Lb1, Ub1, Lb2, Ub2 : integer);

procedure VecSqrt(V : TVector; Lb, Ub : integer);
procedure MatSqrt(M : TMatrix; Lb1, Ub1, Lb2, Ub2 : integer);
\end{verbatim}
\subsection{uSorting}
Another important operation on arrays is sorting. Unit \code{uSorting} implements three different algorithms: Quick sort, Insert sort and Heap sort. Of them, quick sort is fastest in general case, but becomes very inefficient if an input array is already highly ordered, which is not uncommon. Besides, it is implemented recursively, which makes it relatively unsafe. Heap sort is slightly slower in general, but performs much better in worst case. In most cases, it is a preferrable choice. Insertion sort is not very efficient for long arrays, but works well in arrays up to 50 elements, and is quite efficient for initially highly ordered arrays. All three algorithms are implemented for \code{TVector}, \code{TRealPointVector} for X and \code{TRealpointVector} for Y.
\begin{verbatim}
procedure QuickSort(Vector : TVector; Lb,Ub:integer; desc:boolean);
procedure QuickSortX(Points : TRealPointVector; 
   Lb,Ub:integer; desc:boolean);
procedure QuickSortY(Points : TRealPointVector; 
   Lb,Ub:integer; desc:boolean);

procedure InsertSort(Vector : TVector; Lb,Ub:integer; desc:boolean);
procedure InsertSortX(Points : TRealPointVector; 
   Lb,Ub:integer; desc:boolean);
procedure InsertSortY(Points : TRealPointVector; 
   Lb,Ub:integer; desc:boolean);

procedure Heapsort(Vector:TVector; Lb, Ub : integer; desc:boolean);
procedure HeapSortX(Points:TRealPointVector; 
   Lb, Ub : integer; desc:boolean);
procedure HeapSortY(Points:TRealPointVector; 
   Lb, Ub : integer; desc:boolean);
\end{verbatim}
If \code{Desc} is true, sorting in descending order is performed.
\subsection{uVecFileUtils}
This unit defines routines which allow to save TVector or TMatrix into a delimited text file or read it from such file. 
\begin{verbatim}
procedure SaveVecToText(FileName:string; V:TVector; Lb, Ub:integer);
\end{verbatim} 
saves slice of a vector \code{V[Lb..Ub]} as a column into a file. If $Ub > High(V)$, vector till the end is saved.
\begin{verbatim}
function LoadVecFromText(FileName:string; 
    Lb:integer; out HighLoaded : integer) : TVector;
\end{verbatim} \vskip -6pt
allocates and loads \code{TVector} from a file. Length of allocated vector is \code{Lb} plus number of lines in the file. At a reading, if a line cannot be parsed as a valid real number, it is silently skipped. Number of actually read values is returned in \code{HighLoaded}. 
\begin{verbatim}
procedure SaveMatToText(FileName : string; 
  M : TMatrix; delimiter : char; 
  FirstCol, LastCol, FirstRow, LastRow : integer);
\end{verbatim}  \vskip -6pt
saves a rectangular slice of a matrix M[FirstCol..LastCol, FirstRow..LastRow] into a file, values within a row delimited by \code{Delimiter}.
\begin{verbatim}
function LoadMatFromText(FileName: string; 
   delimiter: char; Lb:integer; MD:Float): TMatrix;
\end{verbatim}  \vskip -6pt
allocates and loads a matrix from text file. If $Lb \ne 0$, rows and columns with indices $<Lb$ remain empty (filled with 0). If a cell in the file cannot be parsed (for example, is empty line), corrsponding position in a matrix is filled with \code{MD}. If a line contains no valid values, it is supposed to be title or subtitle and is silently skipped. Importantly, maximal number of delimiters per line of a file is used to determine length of a row in the matrix. Hence, a space can be used as a delimiter only if a delimiting space is always singular.
Example:\\
If there is a file \code{example.csv} with content:
\begin{verbatim}
V1; V2; V3; V4; V5
3.1; 5.6; 7.4;;2.3
5.8; 9.6; 11.1;
7.6; 4.5; 45.2; 3.9; 7.5
\end{verbatim}
then call\\
\code{LoadMatFromText('example.csv',';',1,-10000);}\\ would produce following matrix: \\ \\
\begin{tabular}{c|cccccc}
	ind & 0 & 1 & 2 & 3 & 4 & 5 \\
	\hline 
	0 & 0 & 0 & 0 & 0 & 0 & 0 \\ 
 
	1 & 0 & 3.1 & 5.6 & 7.4 & -10000 & 2.3 \\ 
	
	2 & 0 & 5.8 & 9.6 & 11.1 & -10000 & -10000 \\ 
	
	3 & 0 & 7.6 & 4.5 & 45.2 & 3.9 & 7.5 \\ 
\end{tabular} \\  \vskip 2pt
\code{Lb = 1} causes column and row with indices ``0'' to remain empty, the matrix is filled from indices ``1''. Maximal number of delimiters ';' per line is 4, which defines 5 values pro line. Empty string between 3rd and 4th delimiters in the second line is not a valid float, it is substituted with \code{MD = -10000}; missing values at the end of next line are also substituted with \code{MD}. First line contains no valid floats at all, it is skipped.
\subsection{uVecMatPrn}
This unit defines procedures \code{PrintVector} and \code{PrintMatrix} for console output.
\begin{verbatim}
procedure PrintVector(V:TIntVector);
procedure PrintVector(V:TVector);
procedure PrintMatrix(A:TMatrix);
\end{verbatim} 
If output begins from V[0] or V[1], is defined by variable \code{vprnLB}, default value is 1. Numbers are formatted according to typed constants 
\begin{verbatim}
  vprnFmtStr : string = '%8.3f';
  vprnIntFmtStr : string = '%4d';
\end{verbatim}
 
\section{Linear Algebra enhancements}
\subsection{uMatrix}
Unit \code{uMatrix} in the \code{lmLinearAlgebra} package defines several routines for basic linear algebra operations which were strangely missing in the original DMath library.
Following functions perform element-wise operation with a \code{TVector} and \code{Float}: a \code{Float} is added to or subtracted from a vector \code{V}:\vspace{-6pt}   
\begin{verbatim}
function VecFloatAdd(V:TVector; R:Float; Lb, Ub : integer; 
        Ziel : TVector = nil; ResLb : integer = 1): TVector;
function VecFloatSubtr(V:TVector; R:Float; Lb, Ub : integer; 
        Ziel : TVector = nil; ResLb : integer = 1): TVector;
\end{verbatim}\vspace{-6pt}
\code{R} is added to (\code{VecFloatAdd}) or subtracted from (\code{VecFloatSubtr}) every element of \code{V} beginning from \code{V[Lb]} and to \code{V[Ub]}. 
\begin{verbatim}
function VecFloatDiv(V:TVector; R:Float; Lb, Ub : integer; 
         Ziel : TVector = nil; ResLb : integer = 1): TVector;
function VecFloatMul(V:TVector; R:Float; Lb, Ub : integer;  
         Ziel : TVector = nil; ResLb : integer = 1): TVector;
\end{verbatim}\vspace{-6pt}
Operation is performed, result is placed in \code{Ziel} array beginning from \code{ResLb}. Note that default value for \code{ResLb} is 1. Reason for it is that many routines in DMath and LMath were written originally in Fortran, and this inheritance makes us to use quasi 1-based arrays.

Similar procedures performing element-wise operations with a float and matrix:\vspace{-6pt}
\begin{verbatim}  
function MatFloatAdd(M:TMatrix; R:Float; Lb, Ub1, Ub2 : integer; 
         Ziel : TMatrix = nil) : TMatrix;
function MatFloatSubstr(M:TMatrix; R:Float; Lb, Ub1, Ub2 : integer; 
         Ziel : TMatrix = nil) : TMatrix;
function MatFloatDiv(M:TMatrix; R:Float; Lb, Ub1, Ub2 : integer; 
         Ziel : TMatrix = nil) : TMatrix;
function MatFloatMul(M:TMatrix; R:Float; Lb, Ub1, Ub2 : integer; 
         Ziel : TMatrix = nil) : TMatrix;
\end{verbatim}
Next set of functions performs element-wise operations over two vectors.\\
Add or subtract:\vspace{-6pt}
\begin{verbatim}
function VecAdd(V1,V2:TVector; Ziel : TVector = nil): TVector;
function VecSubstr(V1,V2:TVector; Ziel : TVector = nil): TVector;
\end{verbatim}
Multiply and divide:\vspace{-6pt}
\begin{verbatim}
function VecElemMul(V1,V2:TVector; Ziel : TVector = nil): TVector;
function VecDiv(V1,V2:TVector; Ziel : TVector = nil): TVector;
\end{verbatim}
Dot product, outer product and cross product of two vectors:\vspace{-6pt}
\begin{verbatim}
function VecDotProd(V1,V2:TVector; Lb, Ub : integer) : float;
function VecOuterProd(V1, V2:TVector; Lb, Ub1, Ub2 : integer; 
          Ziel : TMatrix = nil):TMatrix;
function VecCrossProd(V1, V2:TVector; Lb: integer; 
          Ziel :TVector = nil):TVector;
\end{verbatim}
Euclidean length of a vector (dot product with itself):\\
\code{function VecEucLength(V:TVector; LB, Ub : integer) : float;}\\
Matrix and vector product:
\begin{verbatim}
function MatVecMul(M:TMatrix; V:TVector; LB: integer;
         Ziel: TVector = nil): TVector;
\end{verbatim}
Multiplication of matrices:\vspace{-6pt}
\begin{verbatim}
function MatMul(A, B : TMatrix; LB : integer; 
         Ziel : TMatrix = nil) : TMatrix;
\end{verbatim}
Transposition of a matrix. First one places a result in \code{Ziel} which must have compatible dimensions or be \code{nil}, second one transposes a square matrix in place.\vspace{-6pt}
\begin{verbatim}
function MatTranspose(M:TMatrix; LB: integer; 
         Ziel: TMatrix = nil): TMatrix;
procedure MatTransposeInPlace(M:TMatrix; Lb, Ub : integer);
\end{verbatim}
Operators \code{+,-,*,/} are defined for \code{TVector} and \code{Float} and for \code{TMatrix} and \code{Float} (in this order), as well as \code{+,-} for \code{TVector} and \code{TVector}, which are element-wise operations.	They are done for all elements of a vector beginning from index 0, result is placed in a new vector or matrix of the same dimensions. For vector and vector operations both should have the same length.
\section{Statistics}\label{sec:statistics}
\subsection{uMeanSD\_MD: statistics with missing values}
Unit \code{uMeanSD\_MD} implements simple descriptive statistics for datasets with missing values. Missing values are represented by default as NAN (Not A Number). Alternatively, a user can define a custom missing value code using\\
\code{procedure SetMD(aMD:float);}\\[6pt]
Test if a value is undefined (NAN or missing code) with \\
\code{function Undefined(F:Float):boolean;}\\[6pt]
\code{function ValidN(X:TVector; Lb, Ub:Integer):integer;}\\
returns number of valid (defined) elements of an array \code{X} and\\
\code{function FirstDefined(X:TVector; Lb,Ub:Integer):integer;}\\
returns an index of a first defined element of an array.

Following statistical functions are implemented:\\
\code{function Max(X : TVector; Lb, Ub : Integer) : Float;}\\
Returns maximum of sample X.

\code{function Mean(X : TVector; Lb, Ub : Integer) : Float;}\\
Returns mean of sample X.

\code{function StDev(X : TVector; Lb, Ub : Integer) : Float;}\\ 
Returns Standard deviation estimated from sample X.

\code{function StDevP(X : TVector; Lb, Ub : Integer) : Float;} \\
Returns Standard deviation of population.
\subsection{DGaussian in uNormal unit}
\begin{verbatim}
function DGaussian(X, Mean, Sigma: float) : float;
\end{verbatim}\vspace{-6pt}
added. It returns probability density function of a normal distribution with give mathematical expectation (\code{mean}) and standard deviation (\code{sigma}).
\section{Optimization}
Two important optimization algorithms were added to the library in LMath ver 0.5. First is COBYLA (Constrained optimization by linear approximation) developed initially by Michael J. D. Powell. For LMath it was adapted from Fortran 77 by Viatcheslav V. Nesterov. Second is simplex method for linear programming, adapted from \textit{Numeric Recipes in Fortran 77}.

\subsection{Linear Programming}
Second important addition to \code{lmOptimum} package is the \code{uLinSimplex} unit which contains procedures for solving linear programming problems. Task of linear programming is a maximization of a linear function of several variables, subject to several equality and inequality constrains.
 \begin{verbatim}
 procedure LinProgSolve(var A : TMatrix; N, M1, M2, M3 : integer;
   out iCase: integer; out FuncVal: float; out SolVector: TVector);
\end{verbatim}\vspace{-6pt}
is the user-level linear programming solver.
Input: \code{N} is number of variables to be optimized, \code{M1, M2, M3} are number of constrains in $\leq,\geq$ and $=$ form, respectively. Matrix \code{A[M+2,N+1]} contains a tableau with the coefficients of the objective function and constrains. Output: iCase is the outcome of calculation, 0 means that finite solution was found, 1: objective function is unbounded, -1: no solution exists; FuncVal is value of the function upon optimization, and SolVector contains optimal values of argument variables. Theory and details of the programming are described in the 
\href{LMath0_5.pdf#lmoptimum.ulinsimplex}{Reference guide, section uLinSimplex}.

Example program is located at:\\
demo/gui/LinProg/
\subsection{COBYLA}\label{sec:cobyla}
Sometimes it is important to minimize or maximize an objective function subject to one or more equality and inequality constrains. To be able to solve this type of problems with LMath, I implemented COBYLA algorithm. As a bonus, it does not require knowing a derivative of the objective function.

The procedure minimizes an objective function F(X) subject to M inequality constraints on X, where X is a vector of variables that has N components. Constrain expressions must be non-negative. 
\begin{verbatim}
procedure COBYLA(
  N, M : integer; X : TVector;  
  out F : float; out MaxCV : float;  
  RHOBEG: float; RHOEND: float; 
  var MaxFun: integer;
  CalcFC: TCobylaObjectProc
);
\end{verbatim}
\begin{description}[noitemsep]
	\item[N] is number of variables to optimize, residing in \code{X[N]} array.
	\item[M] Number of inequality constrains.
	\item[X] An array of variables to be optimized. Guess values before call, optimized after. As with many optimization algorithms, it is advantageous to have realistic guess values.
	\item[F] The objective function value upon minimization.
	\item[MaxCV] Maximal constraint violation, ideally should be zero.
	\item[RhoBeg]\label{cobyla:rhobeg} A magnitude of initial change of the optimized variables. This value must be set by a user to a reasonable value. COBYLA uses an iterative process with a linear approximation of the objective function at each iteration. Since linear approximation works well only in relatively small intervals, \code{RhoBeg} should not be too big, especially if an objective function has a complex form. However, too little \code{RhoBeg} leads to inefficient calculations. Value of \code{RhoBeg} depends also of a level of uncertainty of initial values. There are no strict rules for finding an optimal \code{RhoBeg} and it may be matter of experimentation to find one.
	\item[RhoEnd] A desired precision of objective function and constrain satisfaction. Like \code{RhoBeg}, this value must be reasonably set by a user.
	\item[MaxFun] At input is a limit on the number of calls of \code{CALCFC} user-supplied function, to avoid endless looping, at the end number of actual calls. 
	\item[CalcFC] The target function.
\end{description}
User-defined function must be of \code{TCobylaObjectProc} type which is defined in \code{uTypes} as follows:
\begin{verbatim}
TCobylaObjectProc = procedure (N, M : integer; const X : TVector;
out F:Float; CON: TVector);
\end{verbatim}
\begin{description}[noitemsep]
	\item[N] Number of arguments to be adjusted;
	\item[M] Number of constraints;
	\item[X] Vector of length N+1, current vector of variables.
	\item[Con] Vector of length [M+3], vector of constraint values.
\end{description}
The subroutine should return the objective function in F, constrain values in CON[1], CON[2],
...,CON[M]. Con[M+1] and Con[M+2] are used internally. Note that we are trying to
adjust X so that F(X) is as small as possible subject to the constraint functions
being non-negative. Importantly, constraints can be violated during the calculation!

Example programs of using \code{COBYLA} are\\
demo/console/optim/TestCobyla/testcobyla.lpr\\
and testfunc.pas. Sample output of the program is in the file outputcobyla.txt.
\section{Regression and interpolation}
\subsection{Constrained non-linear regression}
Unit uConstrNlFit uses COBYLA algorithm (See \ref{sec:cobyla}) to solve problems of non-linear regression with constrains.
As in all non-linear regression procedures of DMath/LMath, a user must supply an objective function to be fitted of type \code{TRegFunc}, defined in \code{uTypes} as \code{function(X : Float; B : TVector) : Float;}. \code{X} is an independent variable, \code{B} is vector of regression parameters. Besides, for constrained regression, a procedure for calculation of constrain expressions must be supplied, of 
\begin{verbatim}
type
  TConstrainsProc = procedure(MaxCon: integer; B, Con : TVector);
\end{verbatim}
\code{MaxCon} is the number of constrains, \code{B} is vector of parameters. \code{B} and \code{Con} are allocated by calling procedure. Results of constrain calculation must be placed into \code{Con} beginning from \code{Con[1]}. Con[0] is not used because of Fortran inheritance. The fitting procedure finds such regression parameters B that constrain expressions are non-negative. However, during the calculation of fit, constrains may be violated and one should not rely on their non-negativity.   
\code{RegFunc : TRegFunc} and \code{ConstProc : TConstrainsProc} are passed to
\begin{verbatim}
procedure ConstrNLFit(RegFunc : TRegFunc; ConstProc : TConstrainsProc; 
   X, Y : TVector; Lb, Ub : Integer; var MaxFun : Integer; 
   var Tol : Float; B : TVector; LastPar : Integer; LastCon : Integer; 
   out MaxCV   : float);
\end{verbatim}\vspace{-6pt}
Other parameters are:
\code{X} and \code{Y}, data for the regression;\\ 
\code{Lb} and \code{Ub}, bounds of X and Y arrays;\\
\code{MaxFun}, on input: maximal number of calls to objective function, to avoid infinite looping, which may happen with some unfortunate sets of parameters; on output: actual number of calls to objective function.\\
\code{Tol} is tolerance of fit (RhoEnd in COBYLA algorithm);\\
\code{B} is vector of parameters. \code{B} must be allocated by a calling procedure and contain n input guess values. On output \code{B} contains fitted values.\\
\code{LastPar} is a number of parameters in B. First parameter is placed in b[1], last in B[LastParam].\\
\code{LastCon} is the number of constrains. It must be equal to the number of constrain expressions in \code{ConstProc}. \code{ConstrNlFit} allocates and passes to \code{ConstrNlFit} \code{Con} vector with the length LastCon+1.\\ 
\code{MaxCV} on input is a maximal acceptable constrain violation; on output it is an actual violation upon the fit.

Unit uConstrNLFit defines also variable \code{RhoBeg}, which is passed to COBYLA algorithm, used by \code{ConstrNLFit}. See details in the section COBYLA (\ref{cobyla:rhobeg}). Default value is 1. Adjust it to the scale of your variables before call of \code{ConstrNLFit}.

Afterwards, revise your model with the procedures 
\begin{verbatim}
function GetCFResiduals: TVector;
function GetCFFittedData: TVector;
\end{verbatim}
First of them returns theoretical values corresponding to observed points supplied in \code{X} and \code{Y} vectors passed to \code{ConstrNLFit}. Second one returns corresponding residuals: Y(calculated) - Y(observed).
 
Example program for uConstrNlFit is:
\begin{verbatim}
LMath/demo/gui/ConstrFit/constr_fit.lpr 
\end{verbatim}
\pagebreak
\subsection{Spline}
Unit uSpline defines procedures for interpolation of data with natural cubic spline, finding derivative and extremums of resulting spline function. There are two stages.

First, use the \vspace{-2pt}
\begin{verbatim}
procedure InitSpline(Xv, Yv:TVector; var Ydv:TVector;
    Lb,Ub:integer);
\end{verbatim} \vspace{-2pt}
to prepare spline data in \code{Vdv} vector. X and Y are vectors of the data to be interpolated; Lb and Ub are, as usually, lower and upper indices, they must be equal for X and Y. \code{Ydv} after the call to \code{InitSpline} has length \code{Ub+1}. After \code{InitSpline} use \vspace{-4pt} 
\begin{verbatim}
function SplInt(X:Float; Xv, Yv, Ydv: TVector;
    Lb,Ub:integer):Float;
\end{verbatim}\vspace{-2pt}
to get value of the spline function at a point \code{X}. 
All other parameters are same as were used for a call to \code{InitSpline}.
Next two functions are intended for investigation of a resulting spline. Both must be called after \code{InitSpline}.\vspace{-2pt}
\begin{verbatim}
function SplDeriv(X:Float; Xv, Yv, Ydv: TVector; 
   Lb, Ub:integer):float;
\end{verbatim}\vspace{-2pt}
has same parameters as \code{Splint} and returns a derivative of the spline function in a given point X.\vspace{-2pt}
\begin{verbatim}
procedure FindSplineExtremums(Xv,Yv,Ydv:TVector; Lb,Ub:integer;
    out Minima, Maxima:TRealPointVector; 
       out NMin, NMax: integer; ResLB:integer = 1);
\end{verbatim}\vspace{-2pt}
finds minima and maxima of the spline function. \code{Xv, Yv, Ydv, Lb} and \code{Ub} are same as before. Minima and Maxima arrays are output variables which contain coordinates of every Minimum and Maximum, argument in X and value in Y. Both these arrays are allocated by the \code{FindSplineExtremums}. Indexing of \code{Minima} and \code{Maxima} begins from \code{ResLb}, default value is 1. \code{NMin} and \code{NMax} contain number of minima and maxima found, respectively. 

Example using \code{uSpline} is located at:\\
/demo/gui/Spline/.  
\section{Special Regression Models}
Package \textbf{lmSpecregress} contains several special regression models, predominantly specific for chemistry and biology and few statistical distributions. 
\subsection{Distributions}
Unit \textbf{uDistribs} defines several distributions and instruments to model experimental data with these distributions. Defined are binomial, exponential, hypoexponential and hyperexponential distributions.
\subsubsection{Binomial distribution}
\code{Function dBinom(k,n:integer;q:Float):Float;}\\
returns binomial probability density for value \code{k} in test with \code{n} trials and \code{q} probability of success in one trial. If $k>n$, returns 0. 
\subsubsection{Exponential distribution}
\code{Function ExponentialDistribution(beta, X:float):float;}\\
evaluates exponential probability density 
\begin{equation}
pdf(x;\beta)= 
\begin{cases} 
\dfrac{1}{\beta} e^{-\frac{x}{\beta}} & x\geq0 \\ 
0 & x<0
\end{cases}
\label{eq:exp_distrib}	
\end{equation}
with time constant $\mathrm{\beta = beta}$ for given X. If
$X < 0$ returns 0.
\subsubsection{Hyperexponential distribution}
Hyperexponential distribution arises when several concurrent processes with different kinetics are going. In electrophysiology it may be; for example, when an ion channel has two independent closed states with different time constants and can enter each of these states with a probabilities P1, P2, etc. Variation coefficient $CV$ of such distribution is always greater than 1, hence the name ``hyperexponential''.
\begin{verbatim}
Function HyperExponentialDistribution(N:integer; 
    var Params:TVector; X:float):float;
\end{verbatim}\vspace{-6pt}
evaluates hyperexponential distribution
\begin{equation}
pdf(\beta_i,p_i,x) = 
\begin{cases}
\displaystyle\sum_{i=1}^n \dfrac{p_i}{\beta_i} e^{-\frac{x}{\beta_i}} & x \geq 0 \\
0 & x < 0
\end{cases}
\label{eq:hyperexp_dist}
\end{equation}
N defines number of phases; Params: zero-based TVector[2*N] containing pairs of parameters for each phase: probability and time constant $\beta$ (see Equation \ref{eq:hyperexp_dist}). Sum of all probabilities must be 1. 
\begin{verbatim}
procedure Fit2HyperExponents(var Xs, Ys:TVector; 
   Ub:integer; var P1, beta1, beta2:float);
\end{verbatim}
Fits a hyperexponential distribution with 2 phases. Input parameters: \code{Xs} and \code{Ys} are 1-based vectors with a density table of a hyperexponentially distributed random variable; \code{Ub} is their upper bound (number of (X;Y) pairs). Output: \code{P1} is a probability of the first phase; \code{beta1} and \code{beta2} are time constants for the first and second phases respectively. Probability of the second phase is $1-\mathrm{P}1$.
\subsubsection{Hypoexponential distribution}
Hypoexponential distribution arises when there are several sequential processes, each with own rate constant. Hypoexponential distribution describes a distribution of time needed to reach end state in a process which passes sequentially several stages each with its own time constant $\beta$. Equation for probability density of the hypoexponential distribution with two phases has the form:
\begin{equation}
	pdf(\beta_1,\beta_2, x) = 
	\begin{cases}
		\dfrac{e^{-\nicefrac{x}{\beta_1}}-e^{-\nicefrac{x}{\beta_2}}}{\nicefrac{1}{\beta_1}-\nicefrac{1}{\beta_2}} & x \geq 0 \\
		0 & x<0
	\end{cases}
\end{equation}
   
For hypoexponential distribution,
$$
CV < 1
$$
hence the name of the distribution.
\begin{verbatim}
function HypoExponentialDistribution2(beta1, beta2, X:float): float;
\end{verbatim}\vspace{-6pt}
returns value of the hypoexponential distribution with the parameters \code{beta1} and \code{beta2} for value X.
LMath offers two procedures to estimate parameters of a hypoexponential distribution with 2 phases. 
\begin{verbatim}
procedure EstimateHypoExponentialDistribution(
      M,CV:float; out beta1, beta2:float);
\end{verbatim}\vspace{-6pt}
finds parameters of the distribution from a known sample mean (M) and coefficient of the variation (CV).
\begin{verbatim}
procedure Fit2HypoExponents(var Xs, Ys:TVector; Ub:integer; 
   out beta1, beta2:float);
\end{verbatim}\vspace{-6pt}
fits an observed probability density with the hyperexponential distribution with the parameters \code{beta1} and \code{beta2}. Input parameters: \code{Xs} and \code{Ys} contain density table of the distribution.

The easiest way to investigate primary data with the help of \code{Fit2HyperExponents} and \code{Fit2HypoExponents} is to classify entries of the population into binned histogram using \code{Distrib} function and extracting \code{Xs} \code{Ys} vectors from \code{TStatClassVector} returned by \code{Distrib} with \code{distExtractX} and \code{DistExtractD}. All these procedures are located in \code{uDistrib} unit, see \href{LMath0_5.pdf#lmMathStat.uDistrib}{Reference guide, 7.4}.
Programming example is in
\begin{verbatim}
LMath\demo\gui\distribs\distribs.lpr 
\end{verbatim}
\subsubsection{Sum of gaussians}
Sometimes, notably in chromatography or in electrophysiology, one meets a situation when a random value is distributed as a sum of several gaussians with different probabilities:
\begin{equation}
	\label{eq:sum_gaussians}
	\begin{cases}
		pdf(x)=p_0\,\mathcal{N}(x,\mu_0,\sigma_0)+\sum\limits_{i=1}^{n-1}p_{i}\,\mathcal{N}(x,\mu_i,\sigma) \\
		\sum\limits_{i=0}^{n-1}p_i=1 \,
	\end{cases}
\end{equation}
where $n$ is number of gaussians in the distribution, $p_0..p_{n-1}$ are probabilities of gaussians, $\mathcal{N}$ is gaussian distribution:
\begin{equation}
	\label{eq:gaussian}
	\mathcal{N}(x,\mu,\sigma)=\frac{1}{{\sigma \sqrt {2\pi } }}e^{{{ - \left( {x - \mu } \right)^2 } \mathord{\left/ {\vphantom {{ - \left( {x - \mu } \right)^2 } {2\sigma ^2 }}} \right. \kern-\nulldelimiterspace} {2\sigma ^2 }}},
\end{equation}
$\mu_0..\mu_{n-1}$ are mathematical expectations and $\sigma_0$ and $\sigma$ are dispersions of $\mathcal{N}_0$ and of $\mathcal{N}_1..\mathcal{N}_{n-1}$ correspondingly.
 
In some cases, standard deviations ($\sigma$) of all gaussians are equal ($\sigma_0 = \sigma$) in Equation \ref{eq:sum_gaussians}, in other special cases, it may be different in one case: $\sigma_0 \ne \sigma$. It happens, for example, in patch-clamp for ``all closed'' level. Finally, sometimes intervals between peaks of gaussians may be different, and in some times, again in patch-clamp, they must be equal: 
\begin{equation}\label{eq:constdelta}
\mu_{i+1} - \mu_{i} = \delta_{\mu}=const
\end{equation}
\begin{figure}[tb]
	\centering
	\includegraphics[width=0.7\linewidth]{illustrious/SumGaussians}
	\caption{Composition (sum) of gaussian distributions}
	\label{fig:sumgaussians}
\end{figure}

These models are defined and fitted in the units \code{uGauss}, for variable interval between gaussians, and \code{uGaussF}, for a constant one. It must be noted, however, that these models do not enforce a limitation that sum of probabilities for all gaussians is 1, therefore equivalent of probabilities is called merely scaling factors (ScF).
Figure \ref{fig:sumgaussians} shows such distribution with $\mu_0 = 2$, $\mu_1 = 3$, $\mu_2 = 4$ and $\mu_3 = 5; \sigma_0 = 0.12; \sigma = 0.18; \left\lbrace ScF_0..ScF_3\right\rbrace = \left\lbrace 0.2,0.5,0.2,0.1\right\rbrace $.

This model was written initially for analysis of single-channel data in patch-clamp, where first gaussian typically corresponds to a situation ``all channels closed'', second to one open channel etc., that is why gaussians are counted from ``0''.  
\paragraph*{Unit uGauss, variable interval between peaks}
This unit implements following procedures and functions.
\begin{verbatim}
function ScaledGaussian(mu, sigma, ScF, X:float):float;
\end{verbatim}
Returns value of probability density function of a gaussian with a mathematical expectation \code{mu} and standard deviation \code{sigma}, scaled by factor \code{ScF}, in a point \code{X}. For example, if a model includes a sum of three gaussians with probabilities 30\%, 50\% and 20\%, ScF should be 0.3, 0.5 and 0.2, correspondingly, such that integral of the whole sum is 1. depending on a quality of actual data and presence of points which are not explained by a multigaussian model, actual sum of scaling factors may be slightly different from 1.
\begin{verbatim}
function SumGaussians(X:Float; Params:TVector):float;
\end{verbatim}\vspace{-6pt}
evaluates a sum of $N$ gaussians with all $\sigma_0..\sigma_N$ equal.
\begin{description}[noitemsep]
\item[X] independent variable;
\item[Params{[1]}] $\sigma$;
\item[{Params[2]..Params[NumberOfGaussians+1]}] $ScF_i$ (scaling factors);
\item[{Params[NumberOfGaussians+2..2*NumberOfGaussians+2]}] $\mu_i$.
\end{description}
\begin{verbatim}
function SumGaussiansS0(X:Float; Params:TVector):float;
\end{verbatim}\vspace{-6pt}
is similar to \code{SumGaussians}, but returns sum of gaussians where $\sigma_0$ is different from others. Consequently, \code{Params} are:
\begin{description}[noitemsep]
\item[Params{[1]}] $\sigma_0$
\item[Params{[2]}] $\sigma$	for gaussians 1..n, n is number of gaussians
\item[]
\end{description}
\begin{verbatim}
procedure SetGaussFit(ANumberOfGaussians:integer; 
   AUseSigma0, AFitMeans: boolean);
\end{verbatim}\vspace{-6pt}
Set model parameters. This procedure must be called before \code{SumGaussFit}.\\ Parameters:\vspace{-6pt}
\begin{description}[noitemsep]
	\item[ANumberOfGaussians] Number of gaussians which form the distribution, $n+1$ where n is index of the last gaussian.
	\item[AUseSigma0] Should $\sigma_0$ in Equation \ref{eq:sum_gaussians} be different from others?
	\item[AFitMeans] Should  $\mu_i$ be fitted or they are fixed and only $\sigma_i$ and scale factors $ScS_i$ are fitted.
\end{description}
\begin{verbatim}
procedure SumGaussFit(var AMathExpect: TVector; 
   var ASigma, ASigma0:Float;
   var ScFs : TVector; const AXV, AYV:TVector; Observ:integer);
\end{verbatim}
This procedure does actual fit of the model. Parameters:
\begin{description}[noitemsep]
	\item[AMathExpect] 0-based TVector; as input, guess values for means; as output, fitted means;
	\item[ASigma, ASigma0] on input guessed and on output fitted Sigma for all gaussians and, if needed, separately $\sigma_0$;
	\item[ScFs] 0-based TVector, as input guess values and as output fitted scaling factors;
	\item[AXV, AYV] 1-based TVector containing experimental data for X and for Y (observed probability distribution density);
	\item[Observ] number of observations (High bound of AXV and AYV).
\end{description}
\paragraph{Unit uGaussF. Fixed interval between peaks}
\begin{verbatim}
function SumGaussiansF(X:Float; Params:TVector):float;
\end{verbatim}
and
\begin{verbatim}
function SumGaussiansFS0(X:Float; Params:TVector):float;
\end{verbatim}
are similar to \code{SumGaussians} and \code{SumGaussiansS0} from \code{uGauss} unit, they return value of probability density function for given \code{X}, while \code{Params} contain parameters of the fitted distribution.

For \code{SumGaussiansF}:
\begin{description}[noitemsep]
	\item[Params{[1]}] $\sigma$;
	\item[Params{[2]}..Params{[NumberOfGaussians+1]}] $ScF$ (scaling factors)
	\item[Params{[NumberOfGaussians+2]}] $\mu_0$
	\item[Params{[NumberOfGaussians+3]}] $\delta = \mu_i-\mu_{i-1}$ distance for $i \in [1..n]$ 
\end{description}
For \code{SumGaussiansFS0}:
\begin{description}[noitemsep]
  	\item[Params{[1]}] $\sigma_0$; 
  	\item[Params{[2]}] $\sigma$;
	\item[Params{[3]}..Params{[NumberOfGaussians+2]}] $ScF_i$ (Scaling factors);
	\item[Params{[NumberOfGaussians+3]}] $\mu_0$;
	\item[Params{[NumberOfGaussians+4]}] $\delta$.
\end{description}

\begin{verbatim}
procedure SetGaussFitF(ANumberOfGaussians:integer; 
  AUseSigma0:boolean);
\end{verbatim}
and
\begin{verbatim}
procedure DeltaFitGaussians(var ASigma, ASigma0, ADelta, AMu0: Float;
   var ScFs: TVector; const AXV, AYV: TVector; Observ: integer);
\end{verbatim}
are similar to {SetGaussFit} and {SumGaussFit}.
\\code{AMu0} and \code{ADelta}  on input contain guess values for $\mu_0$ and for $\delta = \mu_i - \mu_{i-1}$, on output, fitted values. Other parameters are same as for \code{SetGaussFit} and \code{SumGaussFit}.
\subsubsection{unit uGoldman. Membrane transport and Goldman-Hodgkin-Katz equation} 
\begin{figure}[tb]
	\centering
	\includegraphics[width=0.6\linewidth]{illustrious/GHK_Curve}
	\caption{Goldman-Hodgkin-Katz curve for monovalent cation, $C_{E}/C_{I} = 10$. Note none-zero current at zero voltage and crossing of ``X'' axis at $E_{rev}=0,061\, V$. Note also that the curve asymptotically approaches linear Ohmic I-V relation when voltage becomes large, but Ohmic conductances differ for plus $+\infty$ or $-\infty$.}
	\label{fig:GHK}
\end{figure}
If two solutions are separated by a membrane selectively permeable for a certain ion, and concentrations of this ion in these two solutions differ, then dependence of an electric current through a square unit of the membrane from voltage follows the Goldman-Hodgkin-Katz equation for current density:
\begin{equation}\label{eq:GHK_current_density}
	I_s=P_s\dfrac{z^2F^2V_m}{RT}\cdot\dfrac{{C_i}-{C_e}\,\euler^{\nicefrac{-zFV_m}{RT}}}{1-\euler^{\nicefrac{-zFV_m}{RT}}}
\end{equation}
Here ($P_s$) is a specific membrane permeability, 
\[ 
\dfrac{mol/(m^2\cdot s)}{mol/m^3}=m/s,	
\]
$z$ is an ion valence, $V_m$ is voltage, $C_i$ and $C_e$ are concentrations of the ion in ``E'' and ``I'' solutions (for example, extra- and intracellular, respectively), and $T$ is temperature in Kelvins. Other values are Faraday constant ($F$) and gas constant ($R$).
If a square area of a membrane is not known, equation for current may be used:
\begin{equation}\label{eq:GHK_current}
	I=P\dfrac{z^2F^2V_m}{RT}\cdot\dfrac{{C_i}-{C_e}\,\euler^{\nicefrac{-zFV_m}{RT}}}{1-\euler^{\nicefrac{-zFV_m}{RT}}}
\end{equation}
where $P$ (instead of $P_s$) is permeability constant, $m^3/s$ and defines current through the whole membrane regardless of its surface area and dependent variable is current,$ Amp$, rather then current density, $Amp/m^2$. Otherwise these equations are identical and \code{uGoldman} unit does not distinguish them. 

Graphic presentation of this dependence for a monovalent cation with $C_{in}=10\,C_{out}$ is shown in the Figure \ref{fig:GHK}.
Note, that at zero voltage current is non-zero and crosses ``x'' axis at a reversal potential $E_{rev}$ which can be found with Nernst equation:
\begin{equation}\label{eq:nernst}
E_{rev}=\dfrac{RT}{zF}\ln\left(\dfrac{C_{e}}{C_{i}}\right)
\end{equation}
Depending of experimental conditions, $C_{in}$ may be controlled by an experimenter or unknown. Correspondingly, \code{uGoldman} unit can fit Goldman-Hodgkin-Katz equation for fixed $C_{in}$ when reversal potential $E_{rev}$ is fixed, or, in case of unknown $C_{in}$, $E_{rev}$ is free and $C_{in}$ is found by fitting procedure. 
\begin{verbatim}
function GHK(P, z, Cin, Cout, Vm, TC: float):float;
\end{verbatim}
evaluates Goldman-Hodgkin-Katz equation for given voltage $V_m$ in mV. $P$ is permeability constant $m^3/s$ or specific permeability constant; $m/s$, $z$ is ion valence; $C_{in}$ and $C_{out}$ are intracellular and extracellular concentrations of the ion, $M/m^3$ or $mM/l$; $V_m$ is transmembrane voltage, $mV$; $T_C$ is temperature, \celsius. Returned value is Current, $Amp$, or current density, $Amp/m^2$.
\begin{verbatim}
procedure FitGHK(CinFixed: boolean; az, aCout, aTC: float; 
  var Cin, P: float; Voltages, Currents: TVector; Lb, Ub: integer);
\end{verbatim}
fits Goldman-Hodgkin-Katz equation from voltage and current data.\\
\code{CinFixed}: if $C_{in}$ is known and fixed (true) or must be fitted (false); \code{az}: ion valence. It is float because some ions can exist and permeate a membrane in two different states, for example $H_2PO_{4}^-$ and $HPO_{4}^{2-}$;\code{aCout} is the extracellular (outside) concentration of the ion; \code{aTC} is temperature, \celsius. \code{Cin} is the intracellular concentration. If it must be fitted, guess value on input, found value on output, otherwise just known value as input; \code{P}, output only, is permeability, initial guess value is calculated within the fitting procedure with the function \code{PFromSlope}, see below; \code{Voltages} and \code{Currents} are experimental data of IV plot; \code{Lb} and \code{Ub} are their low and upper bounds.

Calculation of permeability $P$ from the slope of IV plot; approximate value for non-linear IV characteristics and exact for linear: 
\begin{verbatim}
function PfromSlope(dI,dV,z,C,TC:float):float;
\end{verbatim}
Parameters: \code{dI} and \code{dV} are $\delta_I$ and $\delta_V$ which give the slope; \code{z}, \code{C} and \code{TC} are valence, concentration (mM/l) and temperature (\celsius).
Several functions may be used to explore Goldman-Hodgkin-Katz dependence after the fit.
\begin{verbatim}
function GOutMax(P,TC,Cin,Cout,z:float):float;
function GInMax(P,TC,Cin,Cout,z:float):float; 
\end{verbatim} 
These two functions find maximal conductance for outward current:
$$
GOutMax=\lim_{V_m\rightarrow+\infty}{G_s}
$$
and for inward current:
$$
GInMax=\lim_{V_m\rightarrow-\infty}{G_s},
$$
see also Figure \ref{fig:GHK}.

Parameters are, as usually, \code{P}: permeability; TC: temperature; \code{Cin and Cout}: concentrations; z: valence;
\begin{verbatim}
function ERev(CIn, COut, z, TC:float):float; 
\end{verbatim}
finds a reverse potential by Nernst equation, mV, see Equation \ref{eq:nernst}.
\begin{verbatim}
function Intracellular(Cout, z, TC, ERev:float):float;
\end{verbatim}
conversly, finds intracellular concentration from Cout, valence, temperature (\celsius), ERev (mV).
Finally, 
\begin{verbatim}
function GSlope(Cin,Cout,z,TC,Vm,P:float):float;
\end{verbatim}
finds a slope conductance ($\nicefrac{dI}{dV}$) at any $Vm$, from known ion concentrations, valence, temperature, voltage and permeability.
\section{Evaluation of expressions}
Mechanisms of expression evaluation defined in \code{uEval} unit were extended in LMath compared to DMath. In DMath, only single chars could be names of variables and only 28 variables could be defined. LMath allows any alphanumeric strings beginning from letters and unlimited number of variables. Besides that, variable \code{ParsingError} was made public enabling a calling procedure to detect and handle an error. Exponentiation can be invoked both with \^ or ** operators.
New or modified procedures and functions:\\[2pt]
\code{procedure SetVariable(VarName : String; Value : Float);}\\
Defines new variable and initializes it with \code{Value}.\\[2pt]
\code{procedure DoneEval;}\\
Removes all functions and variables and frees memory.

Project \href{https://sourceforge.net/projects/eval-command-line-calculator/}{eval: command line calculator} can serve as an example program for \code{uEval} unit.
\section{General utility functions}
\subsection{uSorting}
Unit \code{uSorting} implements sorting of \code{TVector} and \hyperref[sec:trealpoint]{\code{TRealPointVector}} with three algorithms: insertion sort, heap sort and quick sort. In a general case, Insertion sort is relatively ineffective and its use may be advisable in two case: if an array is pretty small (ca 5 elements) or, and this is why we included it in the library, if the array is almost sorted from the beginning. Other two algorithms, heap and quick sort, are almost equally efficient, quick sort being slightly faster in general case, but being extremely slow if the array is almost ordered prior to the sorting, while heap sort has very similar time for best and worst cases, which makes it my personal favourite.
\begin{verbatim}
procedure QuickSort(Vector : TVector; Lb,Ub:integer; desc:boolean);
procedure QuickSortX(Points : TRealPointVector; Lb,Ub:integer;
  desc:boolean);
procedure QuickSortY(Points : TRealPointVector; Lb,Ub:integer;
  desc:boolean);

procedure InsertSort(Vector : TVector; Lb,Ub:integer; desc:boolean);
procedure InsertSortX(Points : TRealPointVector; Lb,Ub:integer;
  desc:boolean);
procedure InsertSortY(Points : TRealPointVector; Lb,Ub:integer;
  desc:boolean);

procedure Heapsort(Vector:TVector; Lb, Ub : integer; desc:boolean);
procedure HeapSortX(Points:TRealPointVector; Lb, Ub : integer;
  desc:boolean);
procedure HeapSortY(Points:TRealPointVector; Lb, Ub : integer;
  desc:boolean);
\end{verbatim}
In all these procedures first argument (\code{Vector} or \code{Points}) is an array to be sorted; \code{Lb} and \code{Ub} are lower and upper bounds of subarray which is actually sorted; \code{desc} is a flag of descending sort. *SortX procedures sort \code{TRealPointVector} for X; *SortY procedures sort it for X.

Demo Program: \begin{verbatim}
\LMath\demo\gui\TestSort\
\end{verbatim}
\subsection{uUnitsFormat}
This unit implements 
\begin{verbatim}
  function FormatUnits(Val:float; UnitsStr:string; long:boolean=false):string;
\end{verbatim}
which formats a value \code{Val} and SI units name \code{UnitStr} with SI decimal prefix such that numeric value in the output string is in [-999..999] range and corresponding prefix is used. E.g.:\code{ FormatUnits(12000, "Hz")} returns "1.2 kHz". If \code{long=True}, full form of prefix is used.
Following prefixes are defined. Short form:\\
'a','f','p','n','\micro','m','K','M','G','T','P','E';\\
long form:\\
'atto','femto','pico','nano','micro','milli','Kilo','Mega','Giga','Tera','Peta','Exa'\\ for\\
$10^{-18},10^{-15},10^{-12},10^{-9},10^{-6},10^{-3},10^{3},10^{6},10^{9},10^{12},10^{15},10^{18}$,\\
correspondingly.\\
Demo:
\begin{verbatim}
\LMath\demo\console\MathUtil\testunitsformat
\end{verbatim}
\section{LMComponents and signal processing}
\code{LMcomponents} is an object-oriented extension of \code{LMath} library. 

\code{TPoints} class from \code{lmPointsVec} unit is a class wrapper around \code{TRealPointVector} with several methods of data allocation and manipulation. 

Unit \code{lmFilters} provides several algorithms of data filtering, namely, gaussian, moving average, and median filters which are implemented as non-visual components.

Besides, \code{TCoordSys} component from \code{lmCoordSys} unit serves for graphical representation of maths. It provides several procedures for conversion between screen and user space coordinates, primitives for line, circle and rectangle drawing in user coordinates, as well as of function graphic or spline drawings. For drawing of user's data, \code{OnDrawData} event is defined.
 
Finally, \code{lmNumericEdits} and \code{lmNumericInputDialogs} units contain \code{TFloatEdit} component and \code{Intervalquery}, \code{FloatInputDialog} and \code{IntegerInputDialog} functions.

See \href{file:LMComponents.pdf}{Documentation to lmComponents} for details.


\end{document}