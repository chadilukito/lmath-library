\documentclass[12pt,a4paper,oneside]{report}
\usepackage{imakeidx}
\usepackage{fancyhdr}
\pagestyle{empty}
\makeindex[name=proc, title=Procedures and Functions]
\makeindex[name=const, title=Constants]
\makeindex[name=types, title = Types]
\makeindex
\usepackage[margin=10pt,font=small,labelfont=bf,labelsep=endash]{caption} % figures and tables caption options
\usepackage[top=1in, bottom=1in, left=1.5in, right=1.0in]{geometry}
\usepackage[compact]{titlesec}
\usepackage{gensymb} % provides Celsius, micro and degree commands

\titlespacing*{\chapter}{0pt}{-60pt}{10pt}
\titleformat{\chapter}[display]{\normalfont\LARGE\bfseries}{\chaptertitlename\ \thechapter}{10pt}{}
\titleformat{\section}[hang]{\normalfont\Large\bfseries}{\thesection\ }{0pt}{}
\titleformat{\subsubsection}[block]{\normalfont\large\bfseries} % format for label and text
{} %label (may be counter: \thesection)
{0pt} % distance between label and text, 0 if no label
{}
\titleformat{\paragraph}[runin]{\normalfont\normalsize\bfseries}{}{0pt}{}
\usepackage{amsmath}
\usepackage{xcolor}
\definecolor{darkblue}{RGB}{0,0,128}
\usepackage[pdftex]{hyperref}
\hypersetup{
	colorlinks   = true, %Colours links instead of ugly boxes
	urlcolor     = darkblue, %Colour for external hyperlinks
	linkcolor    = darkblue, %Colour of internal links
	citecolor	 = darkblue, %Colour of citations
	pdftitle	 ={LMath Reference},
	pdfauthor	 ={Viatcheslav Nesterov},
	pdfsubject	 ={Reference for LMath library},
	pdfkeywords	 ={pascal, object pascal, mathematics, math, library, science, programming, scientific programming}
}
\newcommand{\lmath}[1]{   % picture in margin
	\marginpar{\vspace{#1} 
		\begin{flushright}
			LMath
	\end{flushright} }
}
\newcommand{\lmatha}[1]{   % picture in margin
	\marginpar{\vspace{#1} 
		\begin{flushright}
			LMath 0.5
	\end{flushright} }
}
\newcommand{\euler}{\mathrm{e}}
\newcommand{\keyword}[1]{\textbf{#1}}
\newcommand{\declarationitem}[1]{\textbf{#1}}
\newcommand{\descriptiontitle}[1]{\textbf{#1}}
\newcommand{\code}[1]{\texttt{#1}}  
\setcounter{secnumdepth}{3}
\setcounter{tocdepth}{1}
\begin{document}
\title{LMath 0.5: mathematical library for\\ Free Pascal --- Lazarus\\
{\Large Reference Guide}}

\author{Edited by Viatcheslav V. Nesterov}
\maketitle
\newpage
\label{toc}\tableofcontents
\newpage
% special variable used for calculating some widths.
\newlength{\tmplength}


\chapter*{Preface}
\addcontentsline{toc}{chapter}{Preface}
\section*{Motivation}
For few years I was using the brilliant DMath library from Jean Debord. In the course of its use I have added several new procedures and units; in some cases I adapted it to more modern syntax. Initially I did it only for my own use, mostly in my \href{https://sourceforge.net/projects/nestopatch/}{Nest-O-Patch} project, but finally, since DMath is not developing after 2012, I thought that my small modifications can be useful for a community and released the modified work as a fork. 

DMath stands for Delphi Math, and is a continuation of an earlier work which was named TPMath, for Turbo Pascal Math. Continuing this tradition, I named this work LMath: Lazarus Math.

My initial intent was to integrate LMath into Free Pascal system and make use of built-in Math unit. However, after close look at the code of both, I found that DMath had very thoughtful and consistent error handling mechanism which would be broken by such integration, and abandoned this idea. Besides that, I was not sure how well handling of different float types in DMath and in Math would fit each other. After these considerations, I preferred to implement some functions from Math unit and to leave LMath self-contained.
\section*{Changes in LMath Compared to DMath}
\subsection*{Modifications of Existing Code}  
These are not numerous. 
\begin{enumerate}
\item In many cases, I have changed \code{var} descriptor to \code{out} for output parameters in function calls, to avoid getting tons of unmeaningful warnings. So, now a user must take seriously compiler complaints on possibly uninitialized variables. However, I do not guarantee that I did it everywhere.
\item Instead of many various \code{Dim*Vector} and \code{Dim*Matrix}, overloaded \hyperref[utypes-DimVector]{DimVector} and \hyperref[utypes-DimMatrix]{DimMatrix} procedures for all types of vectors and matrices were defined.
\item Similarly, changed \code{FSwap} and \code{ISwap} to universal \hyperref[uminmax-Swap]{Swap}; \hyperref[uminmax-Min]{Min} and \hyperref[uminmax-Min]{Max} are overloaded as well.
\item In \hyperref[ueval]{uEval} unit, \hyperref[ueval-parsingerror]{ParsingError} variable was made public, to enable a calling program to react adequately if an invalid expression was passed for evaluation. Names of the variables may be of any length and, unlike DMath, the whole name is meaningful. Previously, only first letter was meaningful for expression parser.
\item Converted into Lazarus and recompiled all GUI demo programs.
\end{enumerate}
But in general, I did not modify existing algorithms, since Jean Debord did really very good job and they function nicely.
\subsection*{Additions}
\begin{enumerate}
\item Added \hyperref[types:trealpoint]{TRealPoint} type which represents a point on a cartesian plane and defined several procedures and operators over it (see \ref{uRealPoints}).
\item Defined \hyperref[utypes-IsZero]{IsZero}, \hyperref[utypes-IsNan]{IsNAN} and \hyperref[utypes-SameValue]{SameValue} functions together with accompanying \hyperref[utypes-SetEpsilon]{SetEpsilon} and \hyperref[utypes-SetZeroEpsilon]{SetZeroEpsilon} functions.
\item Improvements in error handling: \hyperref[uErrors-SetErrCode]{SetErrCode} function allows to set not only numeric error code, but text message as well. Consequently, \hyperref[uErrors-MathErrMessage]{MathErrMessage} function allows to read it.  Standard error messages for standard error defined. See \ref{uErrors} for details.
\item In the unit \code{uMinMax}, function \code{Sign} was added with the same semantics as in Math unit, for compatibility reasons.
\item In \code{uMath}, operator \code{**} was defined.
\item In \code{uCompex} unit, opreators over complex numbers defined (inspired by \\ \code{uComplex} unit from Free Pascal RTL).
\item uIntervals unit was written where TInterval type is defined which represents an interval between two real numbers, several procedures with it are defined. See \ref{uIntervals} for details.
\item uCrtPtPol unit written, with the procedures to find critical points of a polynomial, see \ref{unit-ucrtptpol}.
\item Unit uMeanSD{\_}MD written which defines functions of descriptive statistics over array containing missed values. By default, missed value is represented as NAN, but any code can be defined.
\item In the unit uNormal, function DGaussian added to evaluate a normal distribution with arbitrary $\mu$ and $\sigma$.
\item Unit uSpline written, for cubic spline interpolation of a set of points and to investigate the resulting spline function, finding roots and extremums.
\item Goldman-Hodgkin-Katz equation for current and Sum of Gaussians distribution were added to the library of fitting models (see \ref{ugauss}, \ref{ugaussf} and \ref{ugoldman}).
\item Estimates and models of exponential, hyperexponential and hypoexponential distributions added (see \ref{udistribs}).
\item Unit lmSorting written which contains procedures for quick sort, insert sort and heap sort of Float and TRealPoint arrays.
\item Unit lmUnitsFormat written, for formatting values with units using SI prefixes (femto-, pico-, \dots, Tera-, Peta-).
\end{enumerate}
\section*{About the documentation} 
DMath comes with very nice \href{DMath.pdf}{manual} which describes not only the library itself, but a lot of underlying theory. This document, written by Jean Debord, is included with LMath library. Practically everything what you find in this manual remains true for LMath as well. However, new code is, of course, not covered by DMath manual. 

Therefore, I created the document which you are reading now. It was generated using \href{https://sourceforge.net/projects/pasdoc/}{PasDoc} program from the comments contained in the source files and later manually edited and extended. It contains rather formal and terse description of every routine, variable or constant found in the library and may serve as a brief reference. It covers both old and new procedures. Each chapter describes one package so you can easily find where needed function is located. I suggest that DMath.pdf is used to study the most of the library, and this document for the aquaintance with new possibilities and for quick reference.

All elements added or modified in LMath library are labeled in the margins, as shown here. If this symbol is related to a unit identifier, it means that the entire unit is new. \lmath{-28pt} 
\chapter{Structure of the Library}
I find that huge packages with hundreds of units are inconvenient, therefore I organized the library into 12 relatively small packages:
\begin{enumerate}
	\item{\hyperref[package-lmGenMath]{lmGenMath}.} This package defines several important data structures, used later in the whole library, some utility functions, basic math functions and special functions. All other packages of the library depend on lmGenMath.
	\item{\hyperref[package-lmLineAlgebra]{lmLineAlgebra}.} Operations over vectors and matrices. Depends on lmGenMath.
	\item{\hyperref[package-lmPolynoms]{lmPolynoms}.} Evaluation of polynomials, polynomial roots finding, polynomial critical points finding. Depends on lmGenMath and lmLineAlgebra.
	\item{\hyperref[package-lmIntegrals]{lmIntegrals}.} Numeric integrating and solving differential equations. Depends on lmGenMath.
	\item{\hyperref[package-lmRandoms]{lmRandoms}.} Generation of random numbers. Depends on lmGenMath.
	\item{\hyperref[package-lmMathStat]{lmMathStat}} Descriptive statistics, hypothesis testing, collection of various distributions. Depends on lmGenMath and lmLineAlgebra.
	\item{\hyperref[package-lmOptimum]{lmOptimum}.} Algorithms of function minimization. Somewhat artificially, unit uEval for evaluation of an expression, is included into this package. Depends on lmGenMath, lmLineAlgebra, lmRandoms, lmMathStat.
	\item{\hyperref[package-lmNonLinEq]{lmNonLinEq}.} Finding of roots of non-linear equations. Depends on lmGenMath, lmLineAlgebra, lmOptimum.
	\item{\hyperref[package-lmRegression]{lmRegression}.} Algorithms for linear and non-linear regression, curve fitting. Collection of common models. Unit uFFT for fast Fourier Transform is located also here.  Depends on lmLineAlgebra, lmPolynoms, lmOptimum, lmMathUtil.
	\item{\hyperref[package-lmSpecRegress]{lmSpecRegress}.} Collection of field-specific models for data fitting. Depends on lmGenMath and lmRegression.
	\item{\hyperref[package-lmMathUtil]{lmMathUtil}.} Several sorting and formatting routines. Depends on lmGenMath.
	\item{\hyperref[package-lmPlotter]{lmPlotter}.} Routines for data and functions plotting. Depends on lmGenMath, lmMathUtil and LCL.
\end{enumerate}	
All these packages are described in the following chapters. 
\pagestyle{fancy}
\fancyhead{}
\fancyhead[RO]{\rightmark}
\fancyhead[LO]{\leftmark}
\chapter{Package lmGenMath}\label{package-lmGenMath}
\section{Description}
Package lmGenMath (from General Maths) includes units which introduce basic data types (\hyperref[utypes-Float]{Float}, \hyperref[utypes-complex]{Complex}, \hyperref[types:trealpoint]{TRealPoint}, \hyperref[uIntervals.TInterval]{TInterval}) and structures which are used later throughout the whole library; defines operations over these data types; defines error handling mechanism used in the library; implements basic and special math functions and contains several utility routines which strictly speaking do not belong to the field of numeric analysis, but are needed for input-output operations. All other packages of the library depend on lmGenMath package.  


\section{Unit utypes}
\label{utypes}
\index[unit]{utypes}
\subsection{Description}
Global types and constants, dynamic arrays. The default real type is DOUBLE (8{-}byte real). Other types may be selected by defining the symbols:
SINGLEREAL (Single precision, 4 bytes) EXTENDEDREAL (Extended precision, 10 bytes) \subsection{Types}
\subsubsection{Float}
\label{utypes-Float}\index[types]{Float}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			Float = Double;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Floating point type (Default = Double)
\end{itemize}
\subsubsection{TRealPoint}\label{types:trealpoint}\index[types]{TRealPoint}
\lmath{-24pt}
\begin{itemize}
	\item[\declarationitem{Declaration}\hfill]

\begin{verbatim}
TRealPoint = record
  X: Float;
  Y: Float;
end;
\end{verbatim}
\item[\descriptiontitle{Description}]
Represents point on a cartesian plane. Unit \hyperref[uRealPoints]{uRealPoints} defines operations over TRealPoint as a vector in 2-dimantional space.
\end{itemize}
\subsubsection{TIntegerPoint}\label{types:tintegerpoint}\index[types]{TIntegerPoint}
\lmath{-24pt}
\begin{itemize}
	\item[\declarationitem{Declaration}\hfill]
	
	\begin{verbatim}
	PIntegerPoint = ^TIntegerPoint
	TIntegerPoint = record
	  X: Integer;
	  Y: Integer;
	end;
	\end{verbatim}
	\item[\descriptiontitle{Description}]
	Represents point on a cartesian plane, for example on a screen. 
\end{itemize}

\subsubsection{Complex}\label{utypes-complex}\index[types]{Complex}
\begin{itemize}
	\item[\declarationitem{Declaration}\hfill]
	\begin{verbatim}
	Complex = record
	  X: Float;
	  Y: Float;
	end;
	\end{verbatim}
	\item[\descriptiontitle{Description}]
Represents Complex number. Unit \hyperref[ucomplex]{uComplex} defines operations and functions with this type.
\end{itemize}
\subsubsection{RNG{\_}Type}\index[types]{RNG{\_}Type}
\label{utypes-RNG_Type}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			RNG{\_}Type = (...);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Random number generators. See chapter \ref{package-lmRandoms} for its use.
	\item[\textbf{Values}]
	\begin{description}
		\item[\texttt{RNG{\_}MWC}] Multiply{-}With{-}Carry
		\item[\texttt{RNG{\_}MT}] Mersenne Twister
		\item[\texttt{RNG{\_}UVAG}] Universal Virtual Array Generator
	\end{description}
\end{itemize}

\subsubsection{TRegMode}
\label{utypes-TRegMode}
\index[types]{TRegMode}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			TRegMode = (...);}
	\end{flushleft}
	\item[\descriptiontitle{Description}]
	Curve fit. Defines regression mode (weighted, unweighted); see Chapter \ref{package-lmRegression}.
	
	\item[\textbf{Values}]
	\begin{description}
		\item[\texttt{OLS}]  
		\item[\texttt{WLS}] Regression mode
	\end{description}
\end{itemize}
\subsubsection{TOptAlgo}
\label{utypes-TOptAlgo}
\index[types]{TOptAlgo}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			TOptAlgo = (...);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Optimization algorithms for nonlinear regression (chapter \ref{package-lmRegression}).
		\item[\textbf{Values}]
	\begin{description}
		\item[\texttt{NL{\_}MARQ}] Marquardt algorithm
		\item[\texttt{NL{\_}SIMP}] Simplex algorithm
		\item[\texttt{NL{\_}BFGS}] BFGS algorithm
		\item[\texttt{NL{\_}SA}] Simulated annealing
		\item[\texttt{NL{\_}GA}] Genetic algorithm
	\end{description}
\end{itemize}

\subsubsection{StatClass}\label{sec:statclass}\index[types]{StatClass}
\begin{itemize}
	\item[\declarationitem{Declaration}\hfill]
	\begin{verbatim}
StatClass = record  { Statistical class }
  Inf : Float;           { Lower bound }
  Sup : Float;           { Upper bound }
  N   : Integer;         { Number of values }
  F   : Float;           { Frequency }
  D   : Float;           { Density }
end;
	\end{verbatim}
	\item[\descriptiontitle{Description}]
This type represents a class (bin) in a statistical distribution and is used by function \hyperref[udistrib]{distrib} and several other functions from \code{lmMathStat} package. See file \href{DMath.pdf}{DMath.pdf}, Section~16.5 and 16.6 and chapter \ref{package-lmMathStat} for details. 
\end{itemize}

\subsubsection{TRegTest}\label{sec:tregtest}\index[types]{TRegTest}
\begin{itemize}
	\item[\declarationitem{Declaration}\hfill]
	\begin{verbatim}
TRegTest = record      { Test of regression }
  Vr       : Float;    { Residual variance }
  R2       : Float;    { Coefficient of determination }
  R2a      : Float;    { Adjusted coeff. of determination }
  F        : Float;    { Variance ratio (explained/residual) }
  Nu1, Nu2 : Integer;  { Degrees of freedom }
end;
	\end{verbatim}
	\item[\descriptiontitle{Description}]
This type is used by \code{RegTest} and \code{WRegTest} functions from \code{lmMathStat} package. See \href{DMath.pdf}{DMath.pdf},~17.6.2 and Chapter \ref{package-lmMathStat}.
\end{itemize}

\subsubsection{TRealPointVector}
\lmath{-24pt}
\label{utypes-TRealPointVector}
\index[types]{TRealPointVector}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			TRealPointVector =  array of TRealPoint;}
		
	\end{flushleft}
	
\end{itemize}
\subsubsection{TVector}
\label{utypes-TVector}\index[types]{TVector}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			TVector     = array of Float;}
		
	\end{flushleft}
	
\end{itemize}
\subsubsection{TIntVector}
\label{utypes-TIntVector}
\index[types]{TIntVector}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			TIntVector  = array of Integer;}
		
	\end{flushleft}
	
\end{itemize}
\subsubsection{TCompVector}
\label{utypes-TCompVector}
\index[types]{TCompVector}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			TCompVector = array of Complex;}
		
	\end{flushleft}
	
\end{itemize}
\subsubsection{TBoolVector}
\label{utypes-TBoolVector}
\index[types]{TBoolVector}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			TBoolVector = array of Boolean;}
		
	\end{flushleft}
	
\end{itemize}
\subsubsection{TStrVector}
\label{utypes-TStrVector}
\index[types]{TStrVector}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			TStrVector  = array of String;}
		
	\end{flushleft}
\end{itemize}
\subsubsection{TCompOperator}
\label{utypes-TCompOperator}
\index[types]{TCompOperator}
\lmatha{-20pt}
\begin{itemize}
	\item[\declarationitem{Declaration}\hfill]
	\code{TCompOperator = (LT, LE, EQ, GE, GT, NE);}
	\item[\descriptiontitle{Description}] This type is used as a parameter in some comparators for element-wise functions with TVector and TMatrix. See \ref{sec:unit-uvecutils}.
\end{itemize}
\subsubsection{TMatrix}
\label{utypes-TMatrix}
\index[types]{TMatrix}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			TMatrix     = array of TVector;}
		
	\end{flushleft}
	
\end{itemize}
\subsubsection{TIntMatrix}
\label{utypes-TIntMatrix}
\index[types]{TIntMatrix}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			TIntMatrix  = array of TIntVector;}
		
	\end{flushleft}
	
\end{itemize}
\subsubsection{TCompMatrix}
\label{utypes-TCompMatrix}
\index[types]{TCompMatrix}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			TCompMatrix = array of TCompVector;}
		
	\end{flushleft}
	
\end{itemize}
\subsubsection{TBoolMatrix}
\label{utypes-TBoolMatrix}
\index[types]{TBoolMatrix}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			TBoolMatrix = array of TBoolVector;}
		
	\end{flushleft}
	
\end{itemize}
\subsubsection{TStrMatrix}
\label{utypes-TStrMatrix}
\index[types]{TStrMatrix}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			TStrMatrix  = array of TStrVector;}
		
	\end{flushleft}
	
\end{itemize}
\subsubsection{TFunc}
\label{utypes-TFunc}
\index[types]{TFunc}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			TFunc = function(X : Float) : Float;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Function of one variable
	
\end{itemize}
\subsubsection{TFuncNVar}
\label{utypes-TFuncNVar}
\index[types]{TFuncNVar}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			TFuncNVar = function(X : TVector) : Float;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Function of several variables
	
\end{itemize}
\subsubsection{TEquations}
\label{utypes-TEquations}
\index[types]{TEquations}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			TEquations = procedure(X, F : TVector);}
	\end{flushleft}
	\item[\descriptiontitle{Description}]
	Nonlinear equation system. Used in equation solvers.
\end{itemize}
\subsubsection{TDiffEqs}
\label{utypes-TDiffEqs}
\index[types]{TDiffEqs}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			TDiffEqs = procedure(X : Float; Y, Yp : TVector);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Differential equation system
	
\end{itemize}
\subsubsection{TJacobian}
\label{utypes-TJacobian}
\index[types]{TJacobian}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			TJacobian = procedure(X : TVector; D : TMatrix);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Jacobian
	
\end{itemize}
\subsubsection{TGradient}
\label{utypes-TGradient}
\index[types]{TGradient}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			TGradient = procedure(X, G : TVector);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Gradient
	
\end{itemize}
\subsubsection{THessGrad}
\label{utypes-THessGrad}
\index[types]{THessGrad}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			THessGrad = procedure(X, G : TVector; H : TMatrix);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Hessian and Gradient
	
\end{itemize}
\subsubsection{TParamFunc}
\lmath{-24pt}
\label{utypes-TParamFunc}
\index[types]{TParamFunc}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			TParamFunc = function(X : Float; Params : Pointer) : Float;}
	\end{flushleft}
\end{itemize}
\subsubsection{TComparator}
\label{utypes-TComparator}\index[types]{TComparator}
\lmatha{-24pt}
\begin{itemize}
	\item[\declarationitem{Declaration}\hfill]
	\code{TComparator = function(V1, V2 : float) : boolean;}
	\item[\descriptiontitle{Description}]Function for general comparisons of \code{Float}. Used for example in the element-wise procedures and functions over \code{TVector} and \code{TMatrix}. See \ref{sec:unit-uvecutils}.
\end{itemize}
\subsubsection{TStatClassVector}
\label{utypes-TStatClassVector}
\index[types]{TStatClassVector}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			TStatClassVector = array of StatClass;}
		
	\end{flushleft}
	
\end{itemize}


\subsubsection{TRegFunc}
\label{utypes-TRegFunc}
\index[types]{TRegFunc}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			TRegFunc = function(X : Float; B : TVector) : Float;}
	\end{flushleft}
	\item[\descriptiontitle{Description}]
	Regression function
\end{itemize}
\subsubsection{TDerivProc}
\label{utypes-TDerivProc}
\index[types]{TDerivProc}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			TDerivProc = procedure(X, Y : Float; B, D : TVector);}
	\end{flushleft}
	\par
	\item[\descriptiontitle{Description}]
	Procedure to compute the derivatives of the regression function with respect to the regression parameters.
\end{itemize}
\subsubsection{TCobylaObjectProc}\lmatha{-28pt}
\index[types]{TCobylaObjectProc}\label{utypes_TCobylaObjectProc}
\begin{itemize}
	\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
	\code{TCobylaObjectProc = procedure (N, M : integer; const X : TVector; out F : Float; CON : TVector);}
	\end{flushleft}
	\item[\descriptiontitle{Description}]
	Objective function supplied to COBYLA minimization algorythm.
	\code{N} is number of arguments to be adjusted;
	\code{M} is number of constraints;
	TVector \code{X[N]} is the current vector of variables.
	TVector \code{Con[M+2]} is vector of constraint values. The subroutine should return values of the objective and constraint functions in \code{F} and \code{CON[1],CON[2],\dots,CON[M]}. \code{Con[M+1]} and \code{Con[M+2]} are used internally. Note that we are trying to adjust \code{X} so that \code{F(X)} is as small as possible subject to the constraint functions
	being nonnegative. Importantly, constraints can be violated during the calculation!
\end{itemize}
\subsubsection{TMintVar}
\label{utypes-TMintVar}
\index[types]{TMintVar}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			TMintVar = (...);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Variable of the integrated Michaelis equation: Time, Substrate conc., Enzyme conc.\item[\textbf{Values}]
	\begin{description}
		\item[\texttt{Var{\_}T}]  
		\item[\texttt{Var{\_}S}]  
		\item[\texttt{Var{\_}E}]  
	\end{description}
\end{itemize}
\subsubsection{Str30}
\label{utypes-Str30}
\index[types]{Str30}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			Str30  = String[30];}
	\end{flushleft}
	\item[\descriptiontitle{Description}]
	 Graphics	
\end{itemize}
\subsubsection{TScale}
\label{utypes-TScale}
\index[types]{TScale}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			TScale = (...);}
	\end{flushleft}
	\item[\descriptiontitle{Description}]
	\item[\textbf{Values}]
	\begin{description}
		\item[\texttt{LinScale}]  
		\item[\texttt{LogScale}]  
	\end{description}
\end{itemize}

\subsubsection{TGrid}
\label{utypes-TGrid}
\index[types]{TGrid}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			TGrid = (...);}
	\end{flushleft}
	\item[\descriptiontitle{Description}]
	\item[\textbf{Values}]
	\begin{description}
		\item[\texttt{NoGrid}]  
		\item[\texttt{HorizGrid}]  
		\item[\texttt{VertiGrid}]  
		\item[\texttt{BothGrid}]  
	\end{description}
\end{itemize}

\subsubsection{TArgC}
\label{utypes-TArgC}
\index[types]{TArgC}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			TArgC = 1..MaxArg;}
	\end{flushleft}
\end{itemize}

\subsubsection{TWrapper}
\label{utypes-TWrapper}
\index[types]{TWrapper}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			TWrapper = function(ArgC : TArgC; ArgV : TVector) : Float;}
	\end{flushleft}
\end{itemize}

\subsection{Constants}
\subsubsection{Pi}
\label{utypes-Pi}\index[const]{Pi}
\index[const]{Pi}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			Pi         = 3.14159265358979323846;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	$\pi$
	
\end{itemize}
\subsubsection{Ln2}\index[const]{Ln2}
\label{utypes-Ln2}
\index[const]{Ln2}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			Ln2        = 0.69314718055994530942;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	$\ln(2)$
	
\end{itemize}
\subsubsection{Ln10}\index[const]{Ln10}
\label{utypes-Ln10}
\index[const]{Ln10}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			Ln10       = 2.30258509299404568402;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	ln(10)
	
\end{itemize}
\subsubsection{LnPi}\index[const]{LnPi}
\label{utypes-LnPi}
\index[const]{LnPi}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			LnPi       = 1.14472988584940017414;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	$\ln(\pi)$
	
\end{itemize}
\subsubsection{InvLn2}
\label{utypes-InvLn2}\index[const]{InvLn2}
\index[const]{InvLn2}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			InvLn2     = 1.44269504088896340736;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	$1/\ln(2)$
	
\end{itemize}
\subsubsection{InvLn10}
\label{utypes-InvLn10}\index[const]{InvLn2}
\index[const]{InvLn10}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			InvLn10    = 0.43429448190325182765;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	$1/\ln(10)$
	
\end{itemize}
\subsubsection{TwoPi}
\label{utypes-TwoPi}
\index[const]{TwoPi}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			TwoPi      = 6.28318530717958647693;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	$2\,\pi$
	
\end{itemize}
\subsubsection{PiDiv2}
\label{utypes-PiDiv2}
\index[const]{PiDiv2}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			PiDiv2     = 1.57079632679489661923;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	$\pi/2$
	
\end{itemize}
\subsubsection{SqrtPi}
\label{utypes-SqrtPi}
\index[const]{SqrtPi}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			SqrtPi     = 1.77245385090551602730;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	$\sqrt{\pi}$
	
\end{itemize}
\subsubsection{Sqrt2Pi}
\label{utypes-Sqrt2Pi}
\index[const]{Sqrt2Pi}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			Sqrt2Pi    = 2.50662827463100050242;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
$\sqrt{2\pi}$
	
\end{itemize}
\subsubsection{InvSqrt2Pi}
\label{utypes-InvSqrt2Pi}
\index[const]{InvSqrt2Pi}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			InvSqrt2Pi = 0.39894228040143267794;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	$1/\sqrt{2\pi}$
	
\end{itemize}
\subsubsection{LnSqrt2Pi}
\label{utypes-LnSqrt2Pi}
\index[const]{LnSqrt2Pi}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			LnSqrt2Pi  = 0.91893853320467274178;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	$\ln(\sqrt(2\pi))$
	
\end{itemize}
\subsubsection{Ln2PiDiv2}
\label{utypes-Ln2PiDiv2}
\index[const]{Ln2PiDiv2}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			Ln2PiDiv2  = 0.91893853320467274178;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	$\ln(2\pi)/2$
	
\end{itemize}
\subsubsection{Sqrt2}
\label{utypes-Sqrt2}
\index[const]{Sqrt2}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			Sqrt2      = 1.41421356237309504880;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	$\sqrt{2}$
	
\end{itemize}
\subsubsection{Sqrt2Div2}
\label{utypes-Sqrt2Div2}
\index[const]{Sqrt2Div2}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			Sqrt2Div2  = 0.70710678118654752440;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	$\sqrt{2}/2$
	
\end{itemize}
\subsubsection{Gold}
\label{utypes-Gold}
\index[const]{Gold}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			Gold       = 1.61803398874989484821;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
$$
Golden Mean = \frac{1 + \sqrt{5}}{2}
$$
	
\end{itemize}
\subsubsection{CGold}
\label{utypes-CGold}
\index[const]{CGold}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			CGold      = 0.38196601125010515179;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	2 {-} GOLD
	
\end{itemize}
\subsubsection{MachEp}
\label{utypes-MachEp}
\index[const]{MachEp}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			MachEp   = 2.220446049250313E-16;}
	\end{flushleft}
	\par
	\item[\descriptiontitle{Description}]
	Floating point precision: $2^{-52}$
\end{itemize}
\subsubsection{MaxNum}
\label{utypes-MaxNum}
\index[const]{MaxNum}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			MaxNum   = 1.797693134862315E+308;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Max. floating point number: $2^{1024}$
	
\end{itemize}
\subsubsection{MinNum}
\label{utypes-MinNum}
\index[const]{MinNum}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			MinNum   = 2.225073858507202E-308;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Min. floating point number: $2^{-1022}$
	
\end{itemize}
\subsubsection{MaxLog}
\label{utypes-MaxLog}
\index[const]{MaxLog}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			MaxLog   = 709.7827128933840;}
		
	\end{flushleft}
\item[\descriptiontitle{Description}]
Max. argument for Exp = Ln(MaxNum)	
\end{itemize}
\subsubsection{MinLog}
\label{utypes-}
\index[const]{MinLog}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			MinLog   = -708.3964185322641;}
	\end{flushleft}
\item[\descriptiontitle{Description}]
Min. argument for Exp = Ln(MinNum)	
\end{itemize}
\subsubsection{MaxFac}
\label{utypes-MaxFac}
\index[const]{MaxFac}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			MaxFac   = 170;}
		
	\end{flushleft}
\item[\descriptiontitle{Description}]
Max. argument for Factorial	
\end{itemize}
\subsubsection{MaxGam}
\label{utypes-MaxGam}
\index[const]{MaxGam}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			MaxGam   = 171.624376956302;}
	\end{flushleft}
\item[\descriptiontitle{Description}]
Max. argument for Gamma	
\end{itemize}
\subsubsection{MaxLgm}
\label{utypes-MaxLgm}
\index[const]{MaxLgm}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			MaxLgm   = 2.556348E+305;}
	\end{flushleft}
\item[\descriptiontitle{Description}]
Max. argument for LnGamma	
\end{itemize}
\subsubsection{NaN}
\lmath{-24pt}
\label{utypes-NaN}
\index[const]{NaN}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			NaN = 0.0/0.0;}
	\end{flushleft}
\end{itemize}
\subsubsection{Infinity}
\lmath{-24pt}
\label{utypes-Infinity}
\index[const]{Infinity}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			Infinity = 1.0/0.0;}
		
	\end{flushleft}
	
\end{itemize}
\subsubsection{NegInfinity}
\lmath{-24pt}
\label{utypes-NegInfinity}
\index[const]{NegInfinity}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			NegInfinity = -1.0/0.0;}
		
	\end{flushleft}
	
\end{itemize}
\subsubsection{C{\_}infinity}
\label{utypes-C_infinity}
\index[const]{C{\_}infinity}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			C{\_}infinity : Complex = (X : MaxNum; Y : 0.0);}
		
	\end{flushleft}
	
\end{itemize}
\subsubsection{C{\_}zero}
\label{utypes-C_zero}
\index[const]{C{\_}zero}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			C{\_}zero     : Complex = (X : 0.0;    Y : 0.0);}
		
	\end{flushleft}
	
\end{itemize}
\subsubsection{C{\_}one}
\label{utypes-C_one}
\index[const]{C{\_}one}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			C{\_}one      : Complex = (X : 1.0;    Y : 0.0);}
		
	\end{flushleft}
	
\end{itemize}
\subsubsection{C{\_}i}
\label{utypes-C_i}
\index[const]{C{\_}i}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			C{\_}i        : Complex = (X : 0.0;    Y : 1.0);}
		
	\end{flushleft}
	
\end{itemize}
\subsubsection{C{\_}pi}
\label{utypes-C_pi}
\index[const]{C{\_}pi}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			C{\_}pi       : Complex = (X : Pi;     Y : 0.0);}
		
	\end{flushleft}
	
\end{itemize}
\subsubsection{C{\_}pi{\_}div{\_}2}
\label{utypes-C_pi_div_2}
\index[const]{C{\_}pi{\_}div{\_}2}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			C{\_}pi{\_}div{\_}2 : Complex = (X : PiDiv2; Y : 0.0);}
		
	\end{flushleft}
	
\end{itemize}
\subsubsection{MaxSize}
\label{utypes-MaxSize}
\index[const]{MaxSize}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			MaxSize = 32767;}\footnote{All values of machine constants are given for \code{Float = Double}}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Max. array size: $2^{15}-1$
	
\end{itemize}
\subsubsection{MaxArg}
\label{utypes-MaxArg}
\index[const]{MaxArg}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			MaxArg = 26;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Max number of arguments for a function
\end{itemize}
\subsection{Variables}
\subsubsection{DefaultZeroEpsilon}
\label{utypes-DefaultZeroEpsilon}\index[const]{DefaultZeroEpsilon}
\begin{itemize}
\item[\declarationitem{Declaration}\hfill]
\code{DefaultZeroEpsilon: Float = MachEp / 8;}
\item[\descriptiontitle{Description}]This value is used in functions IsZero, IsNegative and IsPositive for approximate comparison with zero. Set it according to the scale of your calculations using procedure SetZeroEpsilon (see \ref{utypes-SetZeroEpsilon}).
\end{itemize}
\subsubsection{DefaultEpsilon}\label{utypes-defaultepsilon}
\begin{itemize}
\label{utype-DefaultEpsilon}\index[const]{DefaultEpsilon}
\item[\declarationitem{Declaration}\hfill]
\code{DefaultEpsilon: Float = MachEp;}
\item[\descriptiontitle{Description}]
This value is used for comparison of floats in function \hyperref[utypes-SameValue]{SameValue}. The function scales it according to the scale of the values of the floats been compared. Set it to the scale of your values with procedure \hyperref[utypes-setepsilon]{SetEpsilon}.
\end{itemize}
\subsection{Functions and Procedures}
\subsubsection{IsZero}
\lmath{-24pt}
\label{utypes-IsZero}
\index[proc]{IsZero}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
		\code{
			function IsZero(F: Float; Epsilon: Float = -1): Boolean;}
	\item[\descriptiontitle{Description}]
Compares to zero using epsilon. If Epsilon is {-}1, DefaultEpsilon as set with prior call to \hyperref[utypes-SetZeroEpsilon]{SetZeroEpsilon} is used. if \code{SetZeroEpsilon} was not called, $MachEp / 8$ is used.	
\end{itemize}
\subsubsection{IsNan}\label{utypes-IsNan}
\index[proc]{IsNan}\lmath{-24pt}
\begin{itemize}
	\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function IsNan(F : Float): Boolean;}
	\end{flushleft}
	\item[\descriptiontitle{Description}]
	Test if given value is NAN
\end{itemize}
\subsubsection{SameValue}
\lmath{-24pt}
\label{utypes-SameValue}
\index[proc]{SameValue}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function SameValue(A, B: Float; epsilon : float): Boolean; overload;\\
			function SameValue(A, B: Float): Boolean; overload;}
	\end{flushleft}
	\item[\descriptiontitle{Description}]
	Tests for approximate equality of two floats. First function returns true if $\left| A-B \right| < \left| \epsilon \right| $. Second one uses relative test: it returns true if $\left| A-B \right| < \left| \epsilon \cdot \mathrm{max}(A,B) \right| $ where $\epsilon$ is \code{DefaultEpsilon} which can be set by call to \hyperref[utypes-SetZeroEpsilon]{\mbox{SetEpsilon}} procedure. if \code{SetEpsilon} was not called, DefaultEpsilon = \hyperref[utypes-MachEp]{MachEp}.
\end{itemize}
\subsubsection{SetAutoInit}
\label{utypes-SetAutoInit}
\index[proc]{SetAutoInit}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure SetAutoInit(AutoInit : Boolean);}
	\end{flushleft}
	\par
	\item[\descriptiontitle{Description}]
	Sets the auto{-}initialization of arrays
	
\end{itemize}
\subsubsection{DimVector}\lmath{-24pt}
\label{utypes-DimVector}
\index[proc]{DimVector}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure DimVector(var V : TVector; Ub : Integer);\\
			procedure DimVector(var V : TIntVector; Ub : Integer);\\
			procedure DimVector(var V : TCompVector; Ub : Integer); \\
			procedure DimVector(var V: TRealPointVector; Ub : Integer); \\
			procedure DimVector(var V : TBoolVector; Ub : Integer); \\
			procedure DimVector(var V : TStrVector; Ub : Integer); overload;}
	\end{flushleft}
	\item[\descriptiontitle{Description}]
	Creates a vector V[0..Ub] based on a type corresponding to a parameter (Float, Integer, Complex, \hyperref[types:trealpoint]{RealPoint}, Boolean; Strings. In DMath, procedures with different names were used; LMath uses overloading).
\end{itemize}
\subsubsection{DimMatrix}\lmath{-24pt}
\label{utypes-DimMatrix}
\index[proc]{DimMatrix}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure DimMatrix(var A : TMatrix; Ub1, Ub2 : Integer); \\
			procedure DimMatrix(var A : TIntMatrix; Ub1, Ub2 : Integer); \\
			procedure DimMatrix(var A : TCompMatrix; Ub1, Ub2 : Integer);\\
			procedure DimMatrix(var A : TBoolMatrix; Ub1, Ub2 : Integer); \\
			procedure DimMatrix(var A : TStrMatrix; Ub1, Ub2 : Integer); overload;}
	\end{flushleft}
	\item[\descriptiontitle{Description}]
	Creates a matrix A[0..Ub1, 0..Ub2] of corresponding type (Float; Integer; Complex; Boolean; String. In DMath, procedures with different names were used; LMath uses overloading).
\end{itemize}
\subsubsection{SetEpsilon}\label{utypes-setepsilon}
\lmath{-24pt}
\index[proc]{SetEpsilon}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure SetEpsilon(AEpsilon: float);}
		
	\end{flushleft}
	\par
	\item[\descriptiontitle{Description}]
	Sets default epsilon for \hyperref[utypes-SameValue]{SameValue}
\end{itemize}
\subsubsection{SetZeroEpsilon}
\lmath{-24pt}
\label{utypes-SetZeroEpsilon}
\index[proc]{SetZeroEpsilon}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure SetZeroEpsilon(AZeroEpsilon: Float);}
	\end{flushleft}
	\par
	\item[\descriptiontitle{Description}]
	Sets default epsilon for comparison of a number to rero (\hyperref[utypes-IsZero]{IsZero} function) and to compare two numbers near zero.
\end{itemize}

\section{Unit uErrors}
\index[unit]{uErrors}
\subsection{Constants}
\label{uErrors}\hypertarget{genmath}{uerror}Error constants are defined here.

Error codes for mathematical functions:
\begin{description}
	\item[MathOK, FOk, MatOk, OptOK] No error
	\item[FDomain] Argument domain error \label{uErrors-FDomain}
	\item[FSing] Function singularity \label{uErrors-FSing}
	\item[FOverflow] Overflow range error \label{uErrors-FOverflow}
	\item[FUnderflow] Underflow range error \label{uErrors-FUnderflow}
	\item[FTLoss] Total loss of precision \label{uErrors-FTLoss}
	\item[FPLoss] Partial loss of precision \label{uErrors-FPLoss}
\end{description}
Error codes for mathematical functions:
\begin{description}
	\item[MatNonConv] Non{-}convergence \label{uErrors-MatNonConv}
	\item[MatSing]	Quasi{-}singular matrix \label{uErrors-MatSing}
	\item[MatErrDim] Non{-}compatible dimensions \label{uErrors-MatErrDim}
	\item[MatNotPD] Matrix not positive definite \label{uErrors-MatNotPD}
\end{description}
Error codes for optimization and nonlinear equations:
\begin{description}
	\item[OptNonConv] Non{-}convergence \label{uErrors-OptNonConv}
	\item[OptSing] Quasi{-}singular hessian matrix \label{uErrors-OptSing}
	\item[OptBigLambda] Too high Marquardt parameter \label{uErrors-OptBigLambda}
\end{description}
Error codes for nonlinear regression
\begin{description}
	\item[NLMaxPar]	Maximal number of parameters exceeded \label{uErrors-NLMaxPar}
	\item[NLNullPar] Initial parameter equal to zero \label{uErrors-NLNullPar}
\end{description}
Error codes for Cobyla algorithm:
\begin{description}
	\item[cobMaxFunc] Return from subroutine Cobyla because the maxfun limit has been reached
	\item[cobRoundErrors] Return from procedure Cobyla because rounding errors are becoming damaging.
	\item[cobDegenerate] Degenerate gradient
\end{description}
Error codes for linear programming:
\begin{description}
	\item[lpBadConstraintCount] Bad input constraint counts
	\item[lpBadSimplexTableau] Bad input tableau
	\item[lpBadVariablesCount] Bad variables count
\end{description}
\subsubsection{ErrorMessage}
\lmath{-24pt}
\label{uErrors-ErrorMessage}
\index[const]{ErrorMessage}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			ErrorMessage : array[0..15] of String =
			('No error',\\
			'Argument domain error',\\
			'Function singularity',\\
			'Overflow range error',\\
			'Underflow range error',\\
			'Total loss of precision',\\
			'Partial loss of precision',\\
			'Non-convergence',\\
			'Quasi-singular matrix',\\
			'Non-compatible dimensions',\\
			'Matrix not positive definite',\\
			'Non-convergence',\\
			'Quasi-singular hessian matrix',\\
			'Too high Marquardt parameter',\\
			'Max. number of parameters exceeded',\\
			'Initial parameter equal to zero',\\
     		'Return from subroutine Cobyla because the maxfun limit has been reached',\\
			'Return from procedure Cobyla because rounding errors are becoming damaging.',\\
			'Degenerate gradient',\\
			'LinSimplex:bad input constraint counts',\\
			'Bad input tableau in LinSimplex',\\
			'LinSimplex: bad variables count'\\
			);}
	\end{flushleft}
\item[\descriptiontitle{Description}] Array of messages corresponding to standard error codes defined in this unit. Elements of this array are returned by \hyperref[uErrors-MathErrMessage]{MathErrMessage} function.	
\end{itemize}
\subsection{Functions and Procedures}
\subsubsection{SetErrCode}\lmath{-24pt}
\label{uErrors-SetErrCode}
\index[proc]{SetErrCode}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure SetErrCode(ErrCode : Integer; EMessage:string = '');}
	\end{flushleft}
	\item[\descriptiontitle{Description}]
	Sets the error code and optionally error message. If error message is empty and \code{ErrorCode} is one of standard codes 
defined in this unit, corresponding standard message from \hyperref[uErrors-ErrorMessage]{ErrorMessage} array is used. Optional argument EMessage was introduced in LMath.
\end{itemize}
\subsubsection{DefaultVal}\lmath{-24pt}
\label{uErrors-DefaultVal}
\index[proc]{DefaultVal}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function DefaultVal(ErrCode : Integer; DefVal : Float; EMessage:string = '') : Float;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Sets error code and default function value. Optional argument EMessage introduced in LMath.
\end{itemize}
\subsubsection{MathErr}
\label{uErrors-MathErr}
\index[proc]{MathErr}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function MathErr : Integer;}
	\end{flushleft}
	\item[\descriptiontitle{Description}]
	Returns error code.
\end{itemize}
\subsubsection{MathErrMessage}
\lmath{-24pt}
\label{uErrors-MathErrMessage}
\index[proc]{MathErrMessage}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function MathErrMessage : string;}
	\end{flushleft}
	\item[\descriptiontitle{Description}]
	Returns error message.
\end{itemize}

\section{Unit uminmax}
\label{uminmax}
\index[unit]{uminmax}
\subsection{Description}
Minimum, maximum, sign and exchange. 
\subsection{Functions and Procedures}
\subsubsection{Min}\lmath{-24pt}
\label{uminmax-Min}
\index[proc]{Min}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function Min(X, Y : Float) : Float; overload;\\
			function Min(X, Y : Integer) : Integer; overload;}
	\end{flushleft}
	\item[\descriptiontitle{Description}]
	Minimum of 2 values. Universal Min function instead of IMin and FMin introduced in LMath.
\end{itemize}
\subsubsection{Max}\lmath{-24pt}
\label{uminmax-Max}
\index[proc]{Max}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function Max(X, Y : Float) : Float; overload;\\
			function Max(X,Y : integer) : integer; overload;}
	\end{flushleft}
	\item[\descriptiontitle{Description}]
	Maximum of 2 values. 	Minimum of 2 values. Universal Max function instead of IMax and FMax introduced in LMath.
	
\end{itemize}
\subsubsection{Sgn}
\label{uminmax-Sgn}
\index[proc]{Sgn}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function Sgn(X : Float) : Integer; overload;}
	\end{flushleft}
	\item[\descriptiontitle{Description}]
	Sign (returns 1 if X = 0)
\end{itemize}
\subsubsection{Sgn0}
\label{uminmax-Sgn0}
\index[proc]{Sgn0}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function Sgn0(X : Float) : Integer;}
	\end{flushleft}
	\item[\descriptiontitle{Description}]
	Sign (returns 0 if X = 0)	
\end{itemize}
\subsubsection{DSgn}
\label{uminmax-DSgn}
\index[proc]{DSgn}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function DSgn(A, B : Float) : Float;}
	\end{flushleft}
	\par
	\item[\descriptiontitle{Description}]
	 if b negative, result is -A otherwize result is A.
\end{itemize}
\subsubsection{Sign}
\lmath{-24pt}
\label{uminmax-Sign}
\index[proc]{Sign}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function Sign(X: Float):integer; inline;}
	\end{flushleft}
	\item[\descriptiontitle{Description}]
	Compatibility with Math unit. Same as \code{Sgn0}. 
\end{itemize}
\subsubsection{IsNegative, IsPositive}
\begin{itemize}
	\item[\declarationitem{Declaration}\hfill]
	\code{function IsNegative(X: float):boolean;\\
	function IsNegative(X: Integer):boolean;\\
	function IsPositive(X: float):boolean;\\
	function IsPositive(X: Integer):boolean;}
	\item[\descriptiontitle{Description}]
	With float, IsPositive returns true if X $>$ \hyperref[utypes-DefaultZeroEpsilon]{DefaultZeroEpsilon} and IsNegative returns true if X $<$ -DefaultZeroEpsilon.
\end{itemize} 
\subsubsection{Swap}\lmath{-24pt}
\label{uminmax-Swap}
\index[proc]{Swap}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure Swap(var X, Y : Float); overload;\\
			procedure Swap(var X, Y : Integer); overload;}
	\end{flushleft}
	\item[\descriptiontitle{Description}]
	Exchange 2 arguments.
\end{itemize}
\section{Unit uround}
\label{uround}
\index[unit]{uround}
\subsection{Description}
Rounding functions. Based on FreeBASIC version contributed by R. Keeling 
\subsection{Functions and Procedures}
\subsubsection{RoundTo}
\label{uround-RoundTo}
\index[proc]{RoundTo}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function RoundTo(X : Float; N : Integer) : Float;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Rounds X to N decimal places
	
\end{itemize}
\subsubsection{Ceil}
\label{uround-Ceil}
\index[proc]{Ceil}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function Ceil(X : Float) : Integer;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Ceiling function
	
\end{itemize}
\subsubsection{Floor}
\label{uround-Floor}
\index[proc]{Floor}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function Floor(X : Float) : Integer;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Floor function
	
\end{itemize}
\section{Unit umath}
\label{umath}
\index[unit]{umath}
\subsection{Description}
Logarithms, exponentials and power 
\subsection{Functions and Procedures}
\subsubsection{Expo}
\label{umath-Expo}
\index[proc]{Expo}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function Expo(X : Float) : Float;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Exponential
	
\end{itemize}
\subsubsection{Exp2}
\label{umath-Exp2}
\index[proc]{Exp2}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function Exp2(X : Float) : Float;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	$2^X$
	
\end{itemize}
\subsubsection{Exp10}
\label{umath-Exp10}
\index[proc]{Exp10}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function Exp10(X : Float) : Float;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	$10^X$
	
\end{itemize}
\subsubsection{Log}
\label{umath-Log}
\index[proc]{Log}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function Log(X : Float) : Float;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Natural logarithm
	
\end{itemize}
\subsubsection{Log2}
\label{umath-Log2}
\index[proc]{Log2}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function Log2(X : Float) : Float;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	$\log_2(X)$
	
\end{itemize}
\subsubsection{Log10}
\label{umath-Log10}
\index[proc]{Log10}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function Log10(X : Float) : Float;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Decimal logarithm
	
\end{itemize}
\subsubsection{LogA}
\label{umath-LogA}
\index[proc]{LogA}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function LogA(X, A : Float) : Float;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	$log_A(X)$
	
\end{itemize}
\subsubsection{IntPower}
\label{umath-IntPower}
\index[proc]{IntPower}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function IntPower(X : Float; N : Integer) : Float;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	$X^N$, $N$ is integer.
	
\end{itemize}
\subsubsection{Power}
\label{umath-Power}
\index[proc]{Power}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function Power(X, Y : Float) : Float;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	$X^Y,\ X\ge 0$
	
\end{itemize}
\subsubsection{Operators}
Operator ** (power) is defined. Base is float, exponent may be integer or float. \lmath{-12pt}
\section{Unit ugamma}
\label{ugamma}
\index[unit]{ugamma}
\subsection{Description}
Gamma function and related functions. Translated from C code in Cephes library (\href{http://www.moshier.net}{http://www.moshier.net}) \subsection{Functions and Procedures}
\subsubsection{SgnGamma}
\label{ugamma-SgnGamma}
\index[proc]{SgnGamma}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function SgnGamma(X : Float) : Integer;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	SgnGamma(X : Float) : Integer; Sign of Gamma function
	
\end{itemize}
\subsubsection{Stirling}
\label{ugamma-Stirling}
\index[proc]{Stirling}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function Stirling(X : Float) : Float;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Stirling(X : Float) : Float; Stirling's formula for the Gamma function
	
\end{itemize}
\subsubsection{StirLog}
\label{ugamma-StirLog}
\index[proc]{StirLog}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function StirLog(X : Float) : Float;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	StirLog(X : Float) : Float; Approximate Ln(Gamma) by Stirling's formula, for X {$>$}= 13
	
\end{itemize}
\subsubsection{Gamma}
\label{ugamma-Gamma}
\index[proc]{Gamma}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function Gamma(X : Float) : Float;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Gamma(X : Float) : Float; Gamma function
	
\end{itemize}
\subsubsection{LnGamma}
\label{ugamma-LnGamma}
\index[proc]{LnGamma}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function LnGamma(X : Float) : Float;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	LnGamma(X : Float) : Float; natural logarithm of Gamma function
	
\end{itemize}
\section{Unit uigamma}
\label{uigamma}
\index[proc]{uigamma}
\subsection{Description}
Incomplete Gamma function and related functions. Translated from C code in Cephes library (\href{http://www.moshier.net}{http://www.moshier.net}) \subsection{Functions and Procedures}
\subsubsection{IGamma}
\label{uigamma-IGamma}
\index[proc]{IGamma}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function IGamma(A, X : Float) : Float;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Incomplete Gamma function.
	
\end{itemize}
\subsubsection{JGamma}
\label{uigamma-JGamma}
\index[proc]{JGamma}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function JGamma(A, X : Float) : Float;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Complement of incomplete Gamma function
	
\end{itemize}
\subsubsection{Erf}
\label{uigamma-Erf}
\index[proc]{Erf}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function Erf(X : Float) : Float;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Error function
	
\end{itemize}
\subsubsection{Erfc}
\label{uigamma-Erfc}
\index[proc]{Erfc}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function Erfc(X : Float) : Float;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Complement of error function
	
\end{itemize}
\section{Unit udigamma}
\label{udigamma}
\index[unit]{udigamma}
\subsection{Description}
DiGamma and TriGamma functions. \\ Contributed by Philip Fletcher (FLETCHP@WESTAT.com) 
\subsection{Functions and Procedures}
\subsubsection{DiGamma}
\label{udigamma-DiGamma}
\index[proc]{DiGamma}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function DiGamma(X : Float ) : Float;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Calculates the Digamma or Psi function = 
	$$
	\frac{d(\ln(\Gamma(X)))}{dX}
	$$
	Parameters: Input, real X, the argument of the Digamma function, $X>0$. Output, real Digamma, the value of the Digamma function at X.
	
\end{itemize}
\subsubsection{TriGamma}
\label{udigamma-TriGamma}
\index[proc]{TriGamma}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function TriGamma(X : Float ) : Float;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Trigamma calculates the Trigamma or Psi Prime function =
	$$
	\frac{d^2(\ln(\Gamma(X)))}{(dX)^2}
	$$
\end{itemize}

\section{Unit ubeta}
\label{ubeta}
\index[unit]{ubeta}
\subsection{Description}
Beta function 
\subsection{Functions and Procedures}
\subsubsection{Beta}
\label{ubeta-Beta}
\index[proc]{Beta}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
\begin{flushleft}
\code{
function Beta(X, Y : Float) : Float;}

\end{flushleft}

\par
\item[\descriptiontitle{Description}]
Beta(X, Y : Float) : Float; Computes Beta(X, Y) = 
$$
\frac{\Gamma(X) \cdot \Gamma(Y)}{\Gamma(X + Y)}
$$
\end{itemize}

\section{Unit uibeta}
\label{uibeta}
\index[unit]{uibeta}
\subsection{Description}
Incomplete Beta function.\\ Translated from C code in Cephes library (\href{http://www.moshier.net}{http://www.moshier.net}) \subsection{Functions and Procedures}
\subsubsection{IBeta}
\label{uibeta-IBeta}
\index[proc]{IBeta}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function IBeta(A, B, X : Float) : Float;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Incomplete Beta function
	
\end{itemize}
\section{Unit ulambert}
\label{ulambert}
\index[unit]{ulambert}
\subsection{Description}
Lambert's function \\Translated from Fortran code by Barry et al. (\href{http://www.netlib.org/toms/743}{http://www.netlib.org/toms/743}) 
\subsection{Functions and Procedures}
\subsubsection{LambertW}
\label{ulambert-LambertW}
\index[proc]{LambertW}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function LambertW(X : Float; UBranch, Offset : Boolean) : Float;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Lambert's W function: $Y=\textrm{W}(X) \Longrightarrow X=Y\,\euler^Y,\quad X\ge -1/\euler$ \\
	X is Lambert's function argument; \\
	UBranch must be set to True for computing the upper branch:\\
	 ($X\ge-1/\euler,\ \textrm{W}(X) \ge -1$);\\
	UBranch is false for computing the lower branch:\\
	  ($-1/\euler \le X < 0,\ \textrm{W}(X) \le -1$);\\
	Offset must be set to true for computing $\textrm{W}(X - 1/\euler),\quad X\ge 0$,
	False for computing \textrm{W}(X).   
	
\end{itemize}

\section{Unit ufact}
\label{ufact}
\index[unit]{ufact}
\subsection{Description}
Factorial 
\subsection{Functions and Procedures}
\subsubsection{Fact}
\label{ufact-Fact}
\index[proc]{Fact}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function Fact(N : Integer) : Float;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Fact(N : Integer) : Float; N!
	
\end{itemize}

\section{Unit utrigo}
\label{utrigo}
\index[unit]{utrigo}
\subsection{Description}
Trigonometric functions 
\subsection{Functions and Procedures}
\subsubsection{Pythag}
\label{utrigo-Pythag}
\index[proc]{Pythag}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function Pythag(X, Y : Float) : Float;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	$\sqrt{X^2+Y^2}$
	
\end{itemize}
\subsubsection{FixAngle}
\label{utrigo-FixAngle}
\index[proc]{FixAngle}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function FixAngle(Theta : Float) : Float;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Set Theta in $-\pi..\pi$
	
\end{itemize}
\subsubsection{Tan}
\label{utrigo-Tan}
\index[proc]{Tan}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function Tan(X : Float) : Float;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Tangent
	
\end{itemize}
\subsubsection{ArcSin}
\label{utrigo-ArcSin}
\index[proc]{ArcSin}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function ArcSin(X : Float) : Float;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Arc sinus
	
\end{itemize}
\subsubsection{ArcCos}
\label{utrigo-ArcCos}
\index[proc]{ArcCos}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function ArcCos(X : Float) : Float;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Arc cosinus
	
\end{itemize}
\subsubsection{ArcTan2}
\label{utrigo-ArcTan2}
\index[proc]{ArcTan2}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function ArcTan2(Y, X : Float) : Float;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Angle (Ox, OM) with M(X,Y)
	
\end{itemize}

\section{Unit uhyper}
\label{uhyper}
\index[unit]{uhyper}
\subsection{Description}
Hyperbolic functions 
\subsection{Functions and Procedures}
\subsubsection{Sinh}
\label{uhyper-Sinh}
\index[proc]{Sinh}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function Sinh(X : Float) : Float;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Hyperbolic sine
	
\end{itemize}
\subsubsection{Cosh}
\label{uhyper-Cosh}
\index[proc]{Cosh}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function Cosh(X : Float) : Float;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Hyperbolic cosine
	
\end{itemize}
\subsubsection{Tanh}
\label{uhyper-Tanh}
\index[proc]{Tanh}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function Tanh(X : Float) : Float;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Hyperbolic tangent
	
\end{itemize}
\subsubsection{ArcSinh}
\label{uhyper-ArcSinh}
\index[proc]{ArcSinh}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function ArcSinh(X : Float) : Float;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Inverse hyperbolic sine
	
\end{itemize}
\subsubsection{ArcCosh}
\label{uhyper-ArcCosh}
\index[proc]{ArcCosh}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function ArcCosh(X : Float) : Float;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Inverse hyperbolic cosine
	
\end{itemize}
\subsubsection{ArcTanh}
\label{uhyper-ArcTanh}
\index[proc]{ArcTanh}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function ArcTanh(X : Float) : Float;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Inverse hyperbolic tangent
	
\end{itemize}
\subsubsection{SinhCosh}
\label{uhyper-SinhCosh}
\index[proc]{SinhCosh}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure SinhCosh(X : Float; out SinhX, CoshX : Float);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Sinh {\&} Cosh
	
\end{itemize}


\section{Unit ucomplex}
\label{ucomplex}
\index[unit]{ucomplex}
\subsection{Description}
Complex number library \\
Based on ComplexMath Delphi library by E. F. Glynn\\ \href{http://www.efg2.com/Lab/Mathematics/Complex/index.html}{http://www.efg2.com/Lab/Mathematics/Complex/index.html} \\Later ideas from uComplex unit by Pierre M\"uller were used. 
\subsection{Operators} \lmath{-24pt}
Following operators over complex numbers or real and complex numbers defined: :=, +, -, *, /, =.
\subsection{Procedures and functions}
\subsubsection{Cmplx}
\label{ucomplex-Cmplx}
\index[proc]{Cmplx}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
\begin{flushleft}
\code{
function Cmplx(X, Y : Float) : Complex;}
\end{flushleft}
\item[\descriptiontitle{Description}]
Returns the complex number X + iY
\end{itemize}
\subsubsection{Polar}
\label{ucomplex-Polar}
\index[proc]{Polar}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
\begin{flushleft}
\code{
function Polar(R, Theta : Float) : Complex;}
\end{flushleft}
\item[\descriptiontitle{Description}]
Returns the complex number
$R\,(\cos(\theta)+i\,\sin(\theta)$
\end{itemize}
\subsubsection{CFloat}
\label{ucomplex-CFloat}
\index[proc]{CFloat}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
\begin{flushleft}
\code{
function CFloat(Z : Complex) : Float;}

\end{flushleft}

\par
\item[\descriptiontitle{Description}]
Returns the Float part of Z

\end{itemize}
\subsubsection{CImag}
\label{ucomplex-CImag}
\index[proc]{CImag}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
\begin{flushleft}
\code{
function CImag(Z : Complex) : Float;}

\end{flushleft}

\par
\item[\descriptiontitle{Description}]
Returns the imaginary part of Z

\end{itemize}
\subsubsection{CSgn}
\label{ucomplex-CSgn}
\index[proc]{CSgn}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
\begin{flushleft}
\code{
function CSgn(Z : Complex) : Integer;}

\end{flushleft}

\par
\item[\descriptiontitle{Description}]
Complex sign

\end{itemize}
\subsubsection{Swap}
\label{ucomplex-Swap}
\index[proc]{Swap}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
\begin{flushleft}
\code{
procedure Swap(var X, Y : Complex); overload;}

\end{flushleft}

\par
\item[\descriptiontitle{Description}]
Exchanges two complex numbers

\end{itemize}
\subsubsection{SameValue}
\label{ucomplex-samevalue}
\index[proc]{SameValue}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
\begin{flushleft}
\code{
function samevalue(z1, z2 : complex) : boolean; overload;}

\end{flushleft}

\par
\item[\descriptiontitle{Description}]
compares two compex numbers using relative epsilon

\end{itemize}
\subsubsection{CAbs}
\label{ucomplex-CAbs}
\index[proc]{CAbs}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
\begin{flushleft}
\code{
function CAbs(Z : Complex) : Float;}

\end{flushleft}

\par
\item[\descriptiontitle{Description}]
Modulus of Z

\end{itemize}
\subsubsection{CAbs2}
\label{ucomplex-CAbs2}
\index[proc]{CAbs2}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
\begin{flushleft}
\code{
function CAbs2(Z : Complex) : Float;}

\end{flushleft}

\par
\item[\descriptiontitle{Description}]
Squared modulus of Z

\end{itemize}
\subsubsection{CArg}
\label{ucomplex-CArg}
\index[proc]{CArg}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
\begin{flushleft}
\code{
function CArg(Z : Complex) : Float;}

\end{flushleft}

\par
\item[\descriptiontitle{Description}]
Argument of Z

\end{itemize}
\subsubsection{CConj}
\label{ucomplex-CConj}
\index[proc]{CConj}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
\begin{flushleft}
\code{
function CConj(Z : Complex) : Complex;}

\end{flushleft}

\par
\item[\descriptiontitle{Description}]
Complex conjugate

\end{itemize}
\subsubsection{CSqr}
\label{ucomplex-CSqr}
\index[proc]{CSqr}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
\begin{flushleft}
\code{
function CSqr(Z : Complex) : Complex;}

\end{flushleft}

\par
\item[\descriptiontitle{Description}]
Complex square

\end{itemize}
\subsubsection{CInv}
\label{ucomplex-CInv}
\index[proc]{CInv}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
\begin{flushleft}
\code{
function CInv(Z : Complex) : Complex;}

\end{flushleft}

\par
\item[\descriptiontitle{Description}]
Complex inverse

\end{itemize}
\subsubsection{CSqrt}
\label{ucomplex-CSqrt}
\index[proc]{CSqrt}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
\begin{flushleft}
\code{
function CSqrt(Z : Complex) : Complex;}

\end{flushleft}

\par
\item[\descriptiontitle{Description}]
Principal part of complex square root

\end{itemize}
\subsubsection{CLn}
\label{ucomplex-CLn}
\index[proc]{CLn}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
\begin{flushleft}
\code{
function CLn(Z : Complex) : Complex;}

\end{flushleft}

\par
\item[\descriptiontitle{Description}]
Principal part of complex logarithm

\end{itemize}
\subsubsection{CExp}
\label{ucomplex-CExp}
\index[proc]{CExp}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
\begin{flushleft}
\code{
function CExp(Z : Complex) : Complex;}

\end{flushleft}

\par
\item[\descriptiontitle{Description}]
Complex exponential

\end{itemize}
\subsubsection{CRoot}
\label{ucomplex-CRoot}
\index[proc]{CRoot}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
\begin{flushleft}
\code{
function CRoot(Z : Complex; K, N : Integer) : Complex;}

\end{flushleft}

\par
\item[\descriptiontitle{Description}]
All N{-}th roots: $Z^{1/N},\quad K=0..N-1$
\end{itemize}
\subsubsection{CPower}
\label{ucomplex-CPower}
\index[proc]{CPower}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
\begin{flushleft}
\code{
function CPower(A, B : Complex) : Complex;}

\end{flushleft}

\par
\item[\descriptiontitle{Description}]
Power with complex exponent

\end{itemize}
\subsubsection{CIntPower}
\label{ucomplex-CIntPower}
\index[proc]{CIntPower}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
\begin{flushleft}
\code{
function CIntPower(A : Complex; N : Integer) : Complex;}

\end{flushleft}

\par
\item[\descriptiontitle{Description}]
Power with integer exponent

\end{itemize}
\subsubsection{CRealPower}
\label{ucomplex-CRealPower}
\index[proc]{CRealPower}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
\begin{flushleft}
\code{
function CRealPower(A : Complex; X : Float) : Complex;}

\end{flushleft}

\par
\item[\descriptiontitle{Description}]
Power with Float exponent

\end{itemize}
\subsubsection{CPoly}
\label{ucomplex-CPoly}
\index[proc]{CPoly}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
\begin{flushleft}
\code{
function CPoly(Z : Complex; Coef : TVector; Deg : Integer) : Complex;}

\end{flushleft}

\par
\item[\descriptiontitle{Description}]
Evaluate polynom with compex argument

\end{itemize}
\subsubsection{CSin}
\label{ucomplex-CSin}
\index[proc]{CSin}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
\begin{flushleft}
\code{
function CSin(Z : Complex) : Complex;}

\end{flushleft}

\par
\item[\descriptiontitle{Description}]
Complex sine

\end{itemize}
\subsubsection{CCos}
\label{ucomplex-CCos}
\index[proc]{CCos}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
\begin{flushleft}
\code{
function CCos(Z : Complex) : Complex;}

\end{flushleft}

\par
\item[\descriptiontitle{Description}]
Complex cosine

\end{itemize}
\subsubsection{CSinCos}
\label{ucomplex-CSinCos}
\index[proc]{CSinCos}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
\begin{flushleft}
\code{
procedure CSinCos(Z : Complex; out SinZ, CosZ : Complex);}

\end{flushleft}

\par
\item[\descriptiontitle{Description}]
Complex sine and cosine

\end{itemize}
\subsubsection{CTan}
\label{ucomplex-CTan}
\index[proc]{CTan}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
\begin{flushleft}
\code{
function CTan(Z : Complex) : Complex;}

\end{flushleft}

\par
\item[\descriptiontitle{Description}]
Complex tangent

\end{itemize}
\subsubsection{CArcSin}
\label{ucomplex-CArcSin}
\index[proc]{CArcSin}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
\begin{flushleft}
\code{
function CArcSin(Z : Complex) : Complex;}

\end{flushleft}

\par
\item[\descriptiontitle{Description}]
Complex arc sine

\end{itemize}
\subsubsection{CArcCos}
\label{ucomplex-CArcCos}
\index[proc]{CArcCos}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
\begin{flushleft}
\code{
function CArcCos(Z : Complex) : Complex;}

\end{flushleft}

\par
\item[\descriptiontitle{Description}]
Complex arc cosine

\end{itemize}
\subsubsection{CArcTan}
\label{ucomplex-CArcTan}
\index[proc]{CArcTan}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
\begin{flushleft}
\code{
function CArcTan(Z : Complex) : Complex;}

\end{flushleft}

\par
\item[\descriptiontitle{Description}]
Complex arc tangent

\end{itemize}
\subsubsection{CSinh}
\label{ucomplex-CSinh}
\index[proc]{CSinh}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
\begin{flushleft}
\code{
function CSinh(Z : Complex) : Complex;}

\end{flushleft}

\par
\item[\descriptiontitle{Description}]
Complex hyperbolic sine

\end{itemize}
\subsubsection{CCosh}
\label{ucomplex-CCosh}
\index[proc]{CCosh}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
\begin{flushleft}
\code{
function CCosh(Z : Complex) : Complex;}

\end{flushleft}

\par
\item[\descriptiontitle{Description}]
Complex hyperbolic cosine

\end{itemize}
\subsubsection{CSinhCosh}
\label{ucomplex-CSinhCosh}
\index[proc]{CSinhCosh}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
\begin{flushleft}
\code{
procedure CSinhCosh(Z : Complex; out SinhZ, CoshZ : Complex);}
\end{flushleft}

\par
\item[\descriptiontitle{Description}]
Complex hyperbolic sine and cosine

\end{itemize}
\subsubsection{CTanh}
\label{ucomplex-CTanh}
\index[proc]{CTanh}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
\begin{flushleft}
\code{
function CTanh(Z : Complex) : Complex;}

\end{flushleft}

\par
\item[\descriptiontitle{Description}]
Complex hyperbolic tangent

\end{itemize}
\subsubsection{CArcSinh}
\label{ucomplex-CArcSinh}
\index[proc]{CArcSinh}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
\begin{flushleft}
\code{
function CArcSinh(Z : Complex) : Complex;}

\end{flushleft}

\par
\item[\descriptiontitle{Description}]
Complex hyperbolic arc sine

\end{itemize}
\subsubsection{CArcCosh}
\label{ucomplex-CArcCosh}
\index[proc]{CArcCosh}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
\begin{flushleft}
\code{
function CArcCosh(Z : Complex) : Complex;}

\end{flushleft}

\par
\item[\descriptiontitle{Description}]
Complex hyperbolic arc cosine

\end{itemize}
\subsubsection{CArcTanh}
\label{ucomplex-CArcTanh}
\index[proc]{CArcTanh}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
\begin{flushleft}
\code{
function CArcTanh(Z : Complex) : Complex;}

\end{flushleft}

\par
\item[\descriptiontitle{Description}]
Complex hyperbolic arc tangent

\end{itemize}
\subsubsection{CLnGamma}
\label{ucomplex-CLnGamma}
\index[proc]{CLnGamma}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
\begin{flushleft}
\code{
function CLnGamma(Z : Complex) : Complex;}

\end{flushleft}

\par
\item[\descriptiontitle{Description}]
Logarithm of Gamma function

\end{itemize}

\section{Unit uIntervals}\lmath{-24pt}
\subsection{Description}
This unit defines type TInterval which represents an interval on a real numbers axis and defines functions to find if a given value belongs to the interval, if two intervals intersect and to find the intersection, or if one interval is completely contained in another one. Length method of TInterval record returnes the difference between borders of the interval. This entire unit was introduced in LMath.
\label{uIntervals}
\index[unit]{uIntervals}
\subsection{Types}
\subsubsection{TInterval record}
\begin{itemize}\label{uIntervals.TInterval}\index[types]{TInterval}
\item[\declarationitem{Declaration}]
\begin{flushleft}
\code{\\
	TInterval = record \\
		\hspace{1cm}Lo:Float;\\
		\hspace{1cm}Hi:Float;\\
		\hspace{1cm}function Length:float\\
	end;}
\end{flushleft}
\end{itemize}
\subsection{Functions and Procedures}
\subsubsection{IntervalsIntersect}
\label{uIntervals-IntervalsIntersect}
\index[proc]{IntervalsIntersect}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
\begin{flushleft}
\code{
function IntervalsIntersect\\
\hspace{3cm}(Lo1, Hi1, Lo2, Hi2:Float):boolean;\\[6pt]
function IntervalsIntersect\\
\hspace{3cm}(Lo1, Hi1, Lo2, Hi2:Integer):boolean;\\[6pt]
function IntervalsIntersect\\
\hspace{3cm}(Interval1, Interval2:TInterval):boolean;}
\end{flushleft}
\item[\descriptiontitle{Description}]
returns \code{true} if intervals \code{[Lo1; Hi1]} and \code{[Lo2; Hi2]} or \code{Interval1, Interval2} intersect.
\end{itemize}
\subsubsection{Contained}
\label{uIntervals-Contained}
\index[proc]{Contained}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
\begin{flushleft}
\code{
function Contained(ContainedInterval, ContainingInterval : TInterval) : boolean;}
\end{flushleft}
\item[\descriptiontitle{Description}]
True if \code{ContainedInterval} is completely inside containing i.e. \code{ContainedInterval.Lo {$>$} ContainingInterval.Lo and ContainedInterval.Hi {$<$} ContainingInterval.Hi}

\end{itemize}
\subsubsection{Intersection}
\label{uIntervals-Intersection}
\index[proc]{Intersection}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
\begin{flushleft}
\code{
function Intersection(Interval1, Interval2 : TInterval) : TInterval;}
\end{flushleft}

\item[\descriptiontitle{Description}]
Returns intersection of \code{Interval1} and \code{Interval2}. If no connection, result is (0;0).
\end{itemize}

\subsubsection{Inside}
\label{uIntervals-Inside}
\index[proc]{Inside}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
\begin{flushleft}
\code{
function Inside(V:Float; AInterval:TInterval):boolean;\\
function Inside(V:float; ALo, AHi:float):boolean; overload;}
\end{flushleft}
\item[\descriptiontitle{Description}]
True if \code{V} is inside interval defined by its borders (\code{ALo, AHi}, similar to Math.InRange) or by \code{AInterval}.
\end{itemize}

\subsubsection{IntervalDefined}
\label{uIntervals-IntervalDefined}
\index[proc]{IntervalDefined}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
\begin{flushleft}
\code{
function IntervalDefined(AInterval:TInterval):boolean;}
\end{flushleft}

\item[\descriptiontitle{Description}]
True if \code{AInterval.Lo {$<$} AInterval.Hi}.
\end{itemize}

\subsubsection{DefineInterval}
\label{uIntervals-DefineInterval}
\index[proc]{DefineInterval}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
\begin{flushleft}
\code{
function DefineInterval(ALo,AHi:Float):TInterval;}
\end{flushleft}
\item[\descriptiontitle{Description}]
Constructor of TInterval from ALo and AHi.
\end{itemize}

\subsubsection{MoveInterval}
\label{uIntervals-MoveInterval}
\index[proc]{MoveInterval}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function MoveInterval(V:float; var AInterval:TInterval);}
	\end{flushleft}
	\item[\descriptiontitle{Description}]
	Move interval \textit{by} a value (it is added to both Lo and Hi).
\end{itemize}

\subsubsection{MoveIntervalTo}
\label{uIntervals-MoveIntervalTo}
\index[proc]{MoveInterval}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure MoveIntervalTo(V:Float; var AInterval:TInterval);}
	\end{flushleft}
	\item[\descriptiontitle{Description}]
	Move interval \textit{to} a value (Lo is set to this value, Hi adjusted such that length remains constant).
\end{itemize}

\section{Unit uRealPoints}\lmath{-24pt}
\label{uRealPoints}
\index[unit]{uRealPoints}
\subsection{Description}
uRealPoints introduces operations over TRealPoint as over vectors on 2-dimensional Cartesian plane. Introduced in LMath.
\subsection{Operators} 
Following operators are defined:
+, -, * (scalar multiplication); * (dot product). 
\subsection{Functions and Procedures}
\subsubsection{SameValue}
\label{uRealPoints-SameValue}
\index[proc]{SameValue}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
\begin{flushleft}
\code{
function SameValue(P1,P2:TRealPoint; epsilonX:float = -1; epsilonY:float = -1):boolean; overload; inline;}
\end{flushleft}
\par
\item[\descriptiontitle{Description}]
Comparison of TRealPoint using epsilon; epsilon for X and for Y are defined separately. If epsilon is {-}1, default value as defined by SetEpsilon will be used. If SetEpsilon was not used, it is MachEp
\end{itemize}
\subsubsection{rpPoint}
\label{uRealPoints-rpPoint}
\index[proc]{rpPoint}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
\begin{flushleft}
\code{
function rpPoint(AX, AY:float):TRealPoint;}
\end{flushleft}
\par
\item[\descriptiontitle{Description}]
Constructor of TRealPoint from two floats.
\end{itemize}

\subsubsection{rpSum}
\label{uRealPoints-rpSum}
\index[proc]{rpSum}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
\begin{flushleft}
\code{
function rpSum(P1,P2:TRealPoint):TRealPoint;}
\end{flushleft}
\par
\item[\descriptiontitle{Description}]
Summation of TRealPoint.
\end{itemize}

\subsubsection{rpSubtr}
\label{uRealPoints-rpSubtr}
\index[proc]{rpSubtr}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
\begin{flushleft}
\code{
function rpSubtr(P1, P2:TRealPoint):TRealPoint;}
\end{flushleft}
\par
\item[\descriptiontitle{Description}]
Subtraction of TRealPoint.
\end{itemize}

\subsubsection{rpMul}
\label{uRealPoints-rpMul}
\index[proc]{rpMul}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
\begin{flushleft}
\code{
function rpMul(P:TRealPoint; S:Float):TRealPoint;}
\end{flushleft}
\par
\item[\descriptiontitle{Description}]
Multiplication of TRealPoint by Scalar.
\end{itemize}

\subsubsection{rpDot}
\label{uRealPoints-rpDot}
\index[proc]{rpDot}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
\begin{flushleft}
\code{
function rpDot(P1, P2:TRealPoint):Float;}
\end{flushleft}
\par
\item[\descriptiontitle{Description}]
Dot product of TRealPoint.
\end{itemize}

\subsubsection{rpLength}
\label{uRealPoints-Length}
\index[proc]{Length}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
\begin{flushleft}
\code{
function rpLength(P:TRealPoint):Float;}
\end{flushleft}
\par
\item[\descriptiontitle{Description}]
Length of vector, represented by TRealPoint.
\end{itemize}

\subsubsection{Distance}
\label{uRealPoints-Distance}
\index[proc]{Distance}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
\begin{flushleft}
\code{
function Distance(P1, P2:TRealPoint):Float;}
\end{flushleft}
\par
\item[\descriptiontitle{Description}]
Distance between two TRealPoint on cartesian plane.
\end{itemize}

\section{Unit uIntPoints}
\index[unit]{uIntPoints}\lmath{-24pt}
\subsection{Description}
Unit \code{uIntPoints} introduces operations over \code{TIntegerPoint}
\subsection{Procedures and functions}
\subsubsection{ipPoint}
\label{ipPoint}\index[proc]{ipPoint}
\begin{itemize}
	\item[\declarationitem{Declaration}\hfill]
	\code{function ipPoint(AX, AY:integer):TIntegerPoint;}
	\item[\descriptiontitle{Description}]Constructor of \code{TIntegerPoint} from two integers.
\end{itemize}
\subsubsection{ipSum,ipSubtr}
\label{ipSubtr}\index[proc]{ipSubtr}\index[proc]{ipSum}
\begin{itemize}
	\item[\declarationitem{Declaration}\hfill]
	\code{function ipSum(P1,P2:TIntegerPoint):TIntegerPoint;\\
		function ipSubtr(P1, P2:TIntegerPoint):TIntegerPoint;}
	\item[\descriptiontitle{Description}]Element-wise substraction and summation of \code{TIntegerPoint}.
\end{itemize}
\subsubsection{ipMul}
\label{ipMul}\index[proc]{ipMul}
\begin{itemize}
	\item[\declarationitem{Declaration}\hfill]
	\code{function ipMul(P:TIntegerPoint; S:integer):TIntegerPoint;}
	\item[\descriptiontitle{Description}]Multiply elements of TIntegerPoint with Float.
\end{itemize}
\subsection{Operators}
\subsubsection{+,-}
Summation or substraction of two TIntegerPoint.
\subsubsection{*}
Multiply components of TIntegerPoint with a Float. 
\section{Unit uScaling}
\label{uScaling}
\index[unit]{uScaling}
\subsection{Description}
Compute an appropriate interval for a set of values. 
\subsection{Functions and Procedures}
\subsubsection{FindScale}
\label{uScaling-FindScale}
\index[proc]{FindScale}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
\begin{flushleft}
\code{
procedure FindScale(X1, X2 : Float; MinDiv, MaxDiv : Integer; out Min, Max, Step : Float);}

\end{flushleft}

\par
\item[\descriptiontitle{Description}]
Determines an interval [Min, Max] including the values from X1 to X2, and a subdivision Step of this interval. Input parameters : X1, X2 = min. {\&} max. Values to be included MinDiv = minimum nb of subdivisions MaxDiv = maximum nb of subdivisions. Output parameters : Min, Max, Step.

\end{itemize}
\subsubsection{AutoScale}
\label{uScaling-AutoScale}
\index[proc]{AutoScale}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
\begin{flushleft}
\code{
procedure AutoScale(X : TVector; Lb, Ub : Integer; Scale : TScale; out XMin, XMax, XStep : Float);}
\end{flushleft}
\par
\item[\descriptiontitle{Description}]
Finds an appropriate scale for plotting the data in X[Lb..Ub]
\end{itemize}

\chapter[Package lmLineAlgebra]{Package lmLineAlgebra: Operations with Vectors and Matrices}\label{package-lmLineAlgebra}
\section{Description}
This package includes procedures for linear algebra: operations with vectors, matrices, systems of linear equations.
\section{Unit uMatrix}
\lmath{-28pt}
\label{umatrix}\index[unit]{umatrix} 
\subsection{Description}
This unit introduces several basic functions  and defines several operators over vectors and matrices.  Functions which have \code{Ziel = nil} default parameter, place result in \code{Ziel} and return it as a result. If \code{Ziel} is nil, it is allocated, otherwise it must have a size sufficient to accomodate the result. For vectors, length of \code{Ziel} must be at least \code{Ub+1}, for matrices it must be at least \code{[Lb..Ub1,Lb..Ub2]}.
\subsection{Functions and Procedures}
\subsubsection{VecFloatAdd,VecFloatSubstr,VecFloatMul,VecFloatDiv}
\label{VecFloatAdd}\index[proc]{VecFloatAdd}\index[proc]{VecFloatSubstr}\index[proc]{VecFloatMul}\index[proc]{VecFloatDiv}
\begin{itemize}
	\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
	\code{function VecFloatAdd(V:TVector; R:Float; Lb, Ub : integer; Ziel : TVector = nil): TVector;\\
	function VecFloatSubstr(V:TVector; R:Float; Lb, Ub : integer; Ziel : TVector = nil): TVector;\\
	function VecFloatDiv(V:TVector; R:Float; Lb, Ub : integer; Ziel : TVector = nil): TVector;\\
	function VecFloatMul(V:TVector; R:Float; Lb, Ub : integer;  Ziel : TVector = nil): TVector;}
	\end{flushleft}
	\item[\descriptiontitle{Description}]
	Every of these functions adds, substracts, multiplies or divides every element of the vector \code{V} with float \code{R}, beginning from element \code{Lb} and to element \code{Ub}. To modify original \code{V}, make \code{Ziel = V}. 
\end{itemize} 
\subsubsection{MatFloatAdd,MatFloatSubstr,MatFloatMul,MatFloatDiv}
\index[proc]{MatFloatAdd}\index[proc]{MatFloatSubstr}\index[proc]{MatFloatMul}\index[proc]{MatFloatDiv}\label{MatFloatDiv}
\begin{itemize}
	\item[\declarationitem{Declaration}\hfill]\begin{flushleft}
\code{	function MatFloatAdd(M:TMatrix; R:Float; Lb, Ub1, Ub2 : integer; Ziel : TMatrix = nil) : TMatrix;}\\
	\code{function MatFloatSubstr(M:TMatrix; R:Float; Lb, Ub1, Ub2 : integer; Ziel : TMatrix = nil) : TMatrix;}\\
	\code{function MatFloatDiv(M:TMatrix; R:Float; Lb, Ub1, Ub2 : integer; Ziel : TMatrix = nil) : TMatrix;}\\
	\code{function MatFloatMul(M:TMatrix; R:Float; Lb, Ub1, Ub2 : integer; Ziel : TMatrix = nil) : TMatrix;}
	\end{flushleft}
	\item[\descriptiontitle{Description}]These functions are similar to \code{VecFloat*}, but are defined for matrix. Operation is done element-wize for submatrix \code{M[Lb..Ub1,Lb..Ub2]}.
\end{itemize}
\subsubsection{VecAdd,VecSubstr,VecElemMul,VecDiv}
\label{VecAdd}\index[proc]{VecAdd}\index[proc]{VecSubstr}\index[proc]{VecElemMul}\index[proc]{VecDiv}
\begin{itemize}
	\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
	\code{function VecAdd(V1,V2:TVector; Ziel : TVector = nil): TVector;}\\
	\code{function VecSubstr(V1,V2:TVector; Ziel : TVector = nil): TVector;}\\
	\code{function VecElemMul(V1,V2:TVector; Ziel : TVector = nil): TVector;}\\
	\code{function VecDiv(V1,V2:TVector; Ziel : TVector = nil): TVector;}
	\end{flushleft}
	\item[\descriptiontitle{Description}]
	Another set of element-wise functions. This time, element of second vector is added to, substracted from, multiplied with or is a divider of each element of a first vector, beginning from 0 to High(V1). VecDiv checks if V2[0] = 0. If yes, operation is fulfilled from 1 to High(V1). 
\end{itemize} 
\subsubsection{VecDotProd}
\index[proc]{VecDotProd}\label{VecDotProd}
\begin{itemize}
	\item[\declarationitem{Declaration}\hfill]
	\code{function VecDotProd(V1,V2:TVector; Lb, Ub : integer) : float;}
	\item[\descriptiontitle{Description}]Dot product of the vectors \code{V1} and \code{V2}.
\end{itemize}
\subsubsection{VecOuterProd}
\label{VecOuterProd}\index[proc]{VecOuterProd}
\begin{itemize}
	\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
	\code{function VecOuterProd(V1, V2:TVector; Lb, Ub1, Ub2 : integer; Ziel : TMatrix = nil):TMatrix;}
	\end{flushleft}
	\item[\descriptiontitle{Description}]Outer product of the vectors \code{V1} and \code{V2}. Result is placed into \code{Ziel}; if it is \code{nil}, it is allocated. 
\end{itemize}
\subsubsection{VecCrossProd}
\index[proc]{VecCrossProd}\label{VecCrossProd}
\begin{itemize}
\item[\declarationitem{Declaration}\hfill]\begin{flushleft}\code{function VecCrossProd(V1, V2:TVector; Lb: integer; Ziel :TVector = nil):TVector;}
\end{flushleft}
\item[\descriptiontitle{Description}] Cross product of two vectors.
\end{itemize}
\subsubsection{VecEucLength}
\label{VecEucLength}\index[proc]{VecEucLength}
\begin{itemize}
\item[\declarationitem{Declaration}\hfill]\code{function VecEucLength(V:TVector; LB, Ub : integer) : float;}
\item[\descriptiontitle{Description}]Returns euclidian length of a vector (dot product with itself).
\end{itemize}
\subsubsection{MatVecMul}
\index[proc]{MatVecMul}\label{MatVecMul}
\begin{itemize}
	\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
	\code{function MatVecMul(M:TMatrix; V:TVector; LB: integer; Ziel: TVector = nil): TVector;}
	\end{flushleft}
	\item[\descriptiontitle{Description}]Product of vector \code{V} and matrix \code{M}. Length of matrix rows must be equal to length of \code{V}.
\end{itemize}
\subsubsection{MatMul}
\label{MatMul}\index[proc]{MatMul}
\begin{itemize}
\item[\declarationitem{Declaration}\hfill]
\code{function MatMul(A, B, Ziel: TMatrix; LB : integer) : TMatrix;}
\item[\descriptiontitle{Description}] Product of matrix \code{A} with matrix \code{B}. Length of row in B must be equal to length of column in \code{A}.
\end{itemize}
\subsubsection{MatTranspose}
\index[proc]{MatTranspose}\label{MatTranspose}
\begin{itemize}
\item[\declarationitem{Declaration}\hfill]\code{function MatTranspose(M, Ziel:TMatrix; LB: integer) : TMatrix;}
\item[\descriptiontitle{Description}] Transposes a matrix \code{M}. If \code{Ziel} is not \code{nil}, length of its columns must be equal to length of rows in \code{M} and vice versa.
\end{itemize}
\subsubsection{MatTransposeInPlace}
\label{MatTransposeInPlace}\index[proc]{MatTransposeInPlace}
\begin{itemize}
\item[\declarationitem{Declaration}\hfill]\code{procedure MatTransposeInPlace(M:TMatrix; Lb, Ub : integer);}
\item[\descriptiontitle{Description}]Transpose square matrix and place result in itself.
\end{itemize}
\subsection{Operators}
Operators \code{+,-,*,/} are defined for \code{TVector} and \code{Float} as well as for \code{TMatrix} and \code{Float}. They add the float to every element of the vector or matrix.

Operators \code{+,-} are defined for two vectors. They must be of equal length; these are element-wize operations too.
 
\section{Unit ugausjor}
\label{ugausjor}
\index[unit]{ugausjor}
\subsection{Description}
Solution of a system of linear equations by Gauss{-}Jordan method
\subsection{Functions and Procedures}
\subsubsection{GaussJordan}
\label{ugausjor-GaussJordan}
\index[proc]{GaussJordan}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure GaussJordan(A : TMatrix; Lb, Ub1, Ub2 : Integer; var Det : Float);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Transforms a matrix according to the Gauss{-}Jordan method.
	
	Input parameters: \code{A} = system matrix; \code{Lb} = lower matrix bound in both dimentions; \code{Ub1, Ub2} = upper matrix bounds.
	
	Output parameters: \code{A} = transformed matrix; \code{Det} = determinant of \code{A}.
	
	Possible results: \code{MatOk}: No error; \code{MatErrDim}: Non{-}compatible dimensions; \code{MatSing}: Singular matrix.
	
\end{itemize}
\section{Unit ulineq}
\label{ulineq}
\index[unit]{ulineq}
\subsection{Description}
Solution of a system of linear equations with a single constant vector by Gauss{-}Jordan method. 
\subsection{Functions and Procedures}
\subsubsection{LinEq}
\label{ulineq-LinEq}
\index[proc]{LinEq}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure LinEq(A : TMatrix; B : TVector; Lb, Ub : Integer; out Det : Float);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Solves a linear system with the Gauss{-}Jordan method.
	
	Input parameters: \code{A} = system matrix; \code{B} = constant vector; \code{Lb, Ub} = lower and upper array bounds.
	
	Output parameters: \code{A} = inverse matrix; \code{B} = solution vector; \code{Det} = determinant of \code{A}.
	
	Possible results: \code{MatOk}: No error; \code{MatSing}: Singular matrix.
	
\end{itemize}
\section{Unit ubalance}
\label{ubalance}
\index[unit]{ubalance}
\subsection{Description}
Balances a matrix and tries to isolate eigenvalues. 
\subsection{Functions and Procedures}
\subsubsection{Balance}
\label{ubalance-Balance}
\index[proc]{Balance}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure Balance( A : TMatrix; Lb, Ub : Integer; out I{\_}low, I{\_}igh : Integer; Scale : TVector);}
	\end{flushleft}
	\par
	\item[\descriptiontitle{Description}]
	A contains the input matrix to be balanced. \code{Lb, Ub} are the lowest and highest indices of the elements of \code{A}. On output: \code{A} contains the balanced matrix. \code{I{\_}low} and \code{I{\_}igh} are two integers such that $\textbf{A}_{i,j}$ is equal to zero if (1) $i > j$ and (2) $j \in Lb,\dots,I\!\_low{-}1$ or $i \in I\!\_igh+1,\dots,Ub$.
	
	Scale contains information determining the  permutations and scaling factors used.
	
\end{itemize}
\section{Unit ubalbak}
\label{ubalbak}
\index[unit]{ubalbak}
\subsection{Description}
Back transformation of eigenvectors. 
\subsection{Functions and Procedures}
\subsubsection{BalBak}
\label{ubalbak-BalBak}
\index[proc]{BalBak}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure BalBak(Z : TMatrix; Lb, Ub, I{\_}low, I{\_}igh : Integer; Scale : TVector; M : Integer);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	This procedure is a translation of the EISPACK subroutine Balbak. This procedure forms the eigenvectors of a real general matrix by back transforming those of the corresponding balanced matrix determined by Balance. 
	
	On input: \code{Z} contains the real and imaginary parts of the eigenvectors to be back transformed. \code{Lb, Ub} are the lowest and highest indices of the elements of \code{Z} \code{I{\_}low} and \code{I{\_}igh} are integers determined by \code{Balance}. \code{Scale} contains information determining the permutations and scaling factors used by \code{Balance}. \code{M} is the index of the latest column of \code{Z} to be back transformed.
	
	On output: \code{Z }contains the real and imaginary parts of the transformed eigenvectors in its columns Lb..M.
	
\end{itemize}
\section{Unit ucholesk}
\label{ucholesk}
\index[unit]{ucholesk}
\subsection{Description}
Cholesky factorization of a positive definite symmetric matrix
\subsection{Functions and Procedures}
\subsubsection{Cholesky}
\label{ucholesk-Cholesky}
\index[proc]{Cholesky}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure Cholesky(A, L : TMatrix; Lb, Ub : Integer);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Cholesky decomposition. Factors the symmetric positive definite matrix \textbf{A} as a product \textbf{LL'} where \textbf{L} is a lower triangular matrix. This procedure may be used as a test of positive definiteness.
	
	Possible results: \code{MatOk}: No error; \code{MatNotPD}: Matrix not positive definite.
	
\end{itemize}

\section{Unit uelmhes}
\label{uelmhes}
\index[unit]{uelmhes}
\subsection{Description}
Reduction of a square matrix to upper Hessenberg form. 
\subsection{Functions and Procedures}
\subsubsection{ElmHes}
\label{uelmhes-ElmHes}
\index[proc]{ElmHes}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure ElmHes(A : TMatrix; Lb, Ub, I{\_}low, I{\_}igh : Integer; I{\_}int : TIntVector);}
	\end{flushleft}
\end{itemize}
\section{Unit ueltran}
\label{ueltran}
\index[unit]{ueltran}
\subsection{Description}
Save transformations used by ElmHes. 
\subsection{Functions and Procedures}
\subsubsection{Eltran}
\label{ueltran-Eltran}
\index[proc]{Eltran}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure Eltran(A : TMatrix; Lb, Ub, I{\_}low, I{\_}igh : Integer; I{\_}int : TIntVector; Z : TMatrix);}
	\end{flushleft}
	\item[\descriptiontitle{Description}]
	On input:
	
	\code{A} contains the multipliers which were used in the reduction by \code{Elmhes} in its lower triangle below the subdiagonal.
	
	\code{Lb, Ub} are the lowest and highest indices of the elements of \code{A}.
	
	\code{I{\_}low} and \code{I{\_}igh} are integers determined by the balancing procedure Balance. If Balance has not been used, set \code{I{\_}low}=\code{Lb}, \code{I{\_}igh}=\code{Ub}.
	
	\code{I{\_}int} contains information on the rows and columns interchanged in the reduction by \code{Elmhes}. Only elements I\code{{\_}low} through \code{I{\_}igh} are used.
	
	On output:
	
	\code{Z }contains the transformation matrix produced in the reduction by \code{Elmhes}.
	
\end{itemize}

\section{Unit uhqr}
\label{uhqr}
\index[unit]{uhqr}
\subsection{Description}
Eigenvalues of a real upper Hessenberg matrix by the QR method.
\subsection{Functions and Procedures}
\subsubsection{Hqr}
\label{uhqr-Hqr}
\index[proc]{Hqr}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure Hqr(H : TMatrix; Lb, Ub, I{\_}low, I{\_}igh : Integer; Lambda : TCompVector);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	On input:
	
	\code{H} contains the upper Hessenberg matrix.
	
	\code{Lb, Ub} are the lowest and highest indices of the elements of\code{ H}.
	
	\code{I{\_}low} and \code{I{\_}igh} are integers determined by the balancing subroutine \hyperref[ubalance]{Balance}. If \code{Balance} has not been used, set \code{I{\_}low} = \code{Lb}, \code{I{\_}igh} = \code{Ub}.
	
	On output:
	
	H has been destroyed.
	
	\code{Wr} and \code{Wi} contain the real and imaginary parts, respectively, of the eigenvalues. The eigenvalues are unordered except that complex conjugate pairs of values appear consecutively with the eigenvalue having the positive imaginary part first.
	
	The function returns an error code: \code{MathOK} for normal return, {-}j if the limit of $30N$ iterations is exhausted while the j{-}th eigenvalue is being sought. (N being the size of the matrix). The eigenvalues should be correct for indices j+1,...,\code{Ub}.
	
\end{itemize}
\section{Unit uhqr2}
\label{uhqr2}
\index[unit]{uhqr2}
\subsection{Description}
Eigenvalues and eigenvectors of a real upper Hessenberg matrix.
\subsection{Functions and Procedures}
\subsubsection{Hqr2}
\label{uhqr2-Hqr2}
\index[proc]{Hqr2}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure Hqr2(H : TMatrix; Lb, Ub, I{\_}low, I{\_}igh : Integer; Lambda : TCompVector; Z : TMatrix);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	On input:
	
	\code{H} contains the upper Hessenberg matrix.
	
	\code{Lb, Ub} are the lowest and highest indices of the elements of \code{H}.
	
	\code{I{\_}low} and \code{I{\_}igh} are integers determined by the balancing subroutine \hyperref[ubalance]{Balance}. If \code{Balance} has not been used, set \code{I{\_}low=Lb}, \code{I{\_}igh=Ub}.
	
	\code{Z} contains the transformation matrix produced by \code{Eltran} after the reduction by \code{Elmhes}, if performed. If the eigenvectors of the Hessenberg matrix are desired, \code{Z} must contain the identity matrix.
	
	On output:
	
	\code{H} has been destroyed.
	
	\code{Wr} and\code{ Wi} contain the real and imaginary parts, respectively, of the eigenvalues. The eigenvalues are unordered except that complex conjugate pairs of values appear consecutively with the eigenvalue having the positive imaginary part first.
	
	\code{Z} contains the real and imaginary parts of the eigenvectors. If the i{-}th eigenvalue is real, the i{-}th column of \code{Z} contains its eigenvector. If the i{-}th eigenvalue is complex with positive imaginary part, the i{-}th and (i+1){-}th columns of \code{Z} contain the real and imaginary parts of its eigenvector. The eigenvectors are unnormalized. If an error exit is made, none of the eigenvectors has been found.
	
	The function returns an error code: zero for normal return, {-}j if the limit of $30N$ iterations is exhausted while the j{-}th eigenvalue is being sought (N being the size of the matrix). The eigenvalues should be correct for indices j+1,...,\code{Ub}.
	
\end{itemize}
\section{Unit ujacobi}
\label{ujacobi}
\index[unit]{ujacobi}
\subsection{Description}
Eigenvalues and eigenvectors of a symmetric matrix \subsection{Functions and Procedures}
\subsubsection{Jacobi}
\label{ujacobi-Jacobi}
\index[proc]{Jacobi}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure Jacobi(A : TMatrix; Lb, Ub, MaxIter : Integer; Tol : Float; Lambda : TVector; V : TMatrix);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Eigenvalues and eigenvectors of a symmetric matrix by the iterative method of Jacobi.
	
	Input parameters: \code{A} = matrix; \code{Lb} = index of first matrix element; \code{Ub} = index of last matrix element; \code{MaxIter} = maximum number of iterations; \code{Tol} = required precision.
	
	Output parameters: \code{Lambda} = eigenvalues in decreasing order; \code{V} = matrix of eigenvectors (columns).
	
	Possible results: \code{MatOk}, \code{MatNonConv}.
	
	The eigenvectors are normalized, with their first component {$>$} 0 This procedure destroys the original matrix \code{A}.
	
\end{itemize}

\section{Unit ulu}
\label{ulu}
\index[unit]{ulu}
\subsection{Description}
LU decomposition 
\subsection{Functions and Procedures}
\subsubsection{LU{\_}Decomp}
\label{ulu-LU_Decomp}
\index[proc]{LU{\_}Decomp}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure LU{\_}Decomp(A : TMatrix; Lb, Ub : Integer);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	LU decomposition. Factors the square matrix \textbf{A} as a product \textbf{LU}, where \textbf{L} is a lower triangular matrix (with unit diagonal terms) and \textbf{U} is an upper triangular matrix. This routine is used in conjunction with \code{LU{\_}Solve} to solve a system of equations.
	
	Input parameters: \code{A} = matrix; \code{Lb} = index of first matrix element; \code{Ub} = index of last matrix element.
	
	Output parameter: \code{A} = contains the elements of \code{L} and \code{U}.
	
	Possible results: \code{MatOk}, \code{MatSing}.
	
	NB: This procedure destroys the original matrix \code{A}.
	
\end{itemize}
\subsubsection{LU{\_}Solve}
\label{ulu-LU_Solve}
\index[proc]{LU{\_}Solve}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure LU{\_}Solve(A : TMatrix; B : TVector; Lb, Ub : Integer; X : TVector);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Solves a system of equations whose matrix has been transformed by \code{LU{\_}Decomp}.
	
	Input parameters: \code{A} = result from \code{LU{\_}Decomp}; \code{B} = constant vector; \code{Lb, Ub} = as in \code{LU{\_}Decomp}.
	
	Output parameter: \code{X} = solution vector.
	
\end{itemize}
\section{Unit uqr}
\label{uqr}
\index[unit]{uqr}
\subsection{Description}
QR decomposition

Ref.: 'Matrix Computations' by Golub {\&} Van Loan Pascal implementation contributed by Mark Vaughan. 
\subsection{Functions and Procedures}
\subsubsection{QR{\_}Decomp}
\label{uqr-QR_Decomp}
\index[proc]{QR{\_}Decomp}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure QR{\_}Decomp(A : TMatrix; Lb, Ub1, Ub2 : Integer; R : TMatrix);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	QR decomposition. Factors the matrix \textbf{A} (n x m, with $n ge m$) as a product \textbf{QR} where \textbf{Q} is a $n \times m$ column{-}orthogonal matrix, and \textbf{R} a $m \times m$ upper triangular matrix. This routine is used in conjunction with \code{QR{\_}Solve} to solve a system of equations.
	
	Input parameters: \code{A} = matrix; \code{Lb} = index of first matrix element; \code{Ub1} = index of last matrix element in 1st dimention; \code{Ub2} = index of last matrix element in 2nd dimention.
	
	Output parameter: \code{A} = contains the elements of \textbf{Q}; \code{R} = upper triangular matrix.
	
	Possible results: \code{MatOk}, \code{MatErrDim}, \code{MatSing}.
	
	NB: This procedure destroys the original matrix\code{ A}.
	
\end{itemize}
\subsubsection{QR{\_}Solve}
\label{uqr-QR_Solve}
\index[proc]{QR{\_}Solve}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure QR{\_}Solve(Q, R : TMatrix; B : TVector; Lb, Ub1, Ub2 : Integer; X : TVector);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	QR decomposition. Factors the matrix \textbf{A} ($n \times m$, with $n \ge m $) as a product \textbf{QR} where \textbf{Q} is a ($n \times m$) column{-}orthogonal matrix, and \textbf{R} a ($m \times m$) upper triangular matrix. This routine is used in conjunction with QR{\_}Solve to solve a system of equations.
	
	Input parameters : \code{A} = matrix; \code{Lb} = index of first matrix element; \code{Ub1} = index of last matrix element in 1st dimention; \code{Ub2} = index of last matrix element in 2nd dimention.
	
	Output parameter: \code{A} = contains the elements of \textbf{Q}; \code{R} = upper triangular matrix.
	
	Possible results: \code{MatOk, MatErrDim, MatSing}.
	
	NB: This procedure destroys the original matrix \code{A}
	
\end{itemize}
\section{Unit usvd}
\label{usvd}
\index[unit]{usvd}
\subsection{Description}
Singular value decomposition 
\subsection{Functions and Procedures}
\subsubsection{SV{\_}Decomp}
\label{usvd-SV_Decomp}
\index[proc]{SV{\_}Decomp}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure SV{\_}Decomp(A : TMatrix; Lb, Ub1, Ub2 : Integer; S : TVector; V : TMatrix);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Singular value decomposition. Factors the matrix \textbf{A} ($n \times m$, with $n \ge m$) as a product \textbf{USV'} where \textbf{U} is a ($n \times m$) column-orthogonal matrix, \textbf{S} a ($m \times m$) diagonal matrix with elements $ \ge 0$ (the singular values) and \textbf{V} a ($m \times m$) orthogonal matrix. This routine is used in conjunction with \code{SV{\_}Solve} to solve a system of equations.
	
	Input parameters: \code{A} = matrix; \code{Lb} = index of first matrix element; \code{Ub1} = index of last matrix element in 1st dimention; \code{Ub2} = index of last matrix element in 2nd dimention.
	
	Output parameters: \code{A} = contains the elements of \code{U}; \code{S} = vector of singular values; \code{V} = orthogonal matrix.
	
	Possible results: \code{MatOk}: No error; \code{MatNonConv}: Non-convergence; \code{MatErrDim}: Non-compatible dimensions ($n < m$).
	
	NB: This procedure destroys the original matrix \code{A}.
	
\end{itemize}
\subsubsection{SV{\_}SetZero}
\label{usvd-SV_SetZero}
\index[proc]{SV{\_}SetZero}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure SV{\_}SetZero(S : TVector; Lb, Ub : Integer; Tol : Float);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Sets the singular values to zero if they are lower than a specified threshold.
	
	Input parameters: \code{S} = vector of singular values; \code{Tol} = relative tolerance. Threshold value will be $Tol \cdot \textrm{Max}(S)$; \code{Lb} = index of first vector element; \code{Ub} = index of last vector element.
	
	Output parameter : \code{S} = modified singular values.
	
\end{itemize}
\subsubsection{SV{\_}Solve}
\label{usvd-SV_Solve}
\index[proc]{SV{\_}Solve}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure SV{\_}Solve(U : TMatrix; S : TVector; V : TMatrix; B : TVector; Lb, Ub1, Ub2 : Integer; X : TVector);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Solves a system of equations by singular value decomposition, after the matrix has been transformed by \hyperref[usvd-SV_Decomp]{SV{\_}Decomp}, and the lowest singular values have been set to zero by \code{SV{\_}SetZero}.
	
	Input parameters: \code{U, S, V} = vector and matrices from \code{SV{\_}Decomp};\code{ B} = constant vector; \code{Lb, Ub1, Ub2} = as in \code{SV{\_}Decomp}.
	
	Output parameter: 
	\code{X} = solution vector = 
	$$
	\textbf{V} \cdot \textbf{Diag}(1/s_i) \cdot \textbf{U'B},\  \textrm{for}\ s_i \ne 0
	$$
\end{itemize}
\subsubsection{SV{\_}Approx}
\label{usvd-SV_Approx}
\index[proc]{SV{\_}Approx}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure SV{\_}Approx(U : TMatrix; S : TVector; V : TMatrix; Lb, Ub1, Ub2 : Integer; A : TMatrix);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Approximates a matrix \textbf{A} by the product \textbf{USV'}, after the lowest singular values have been set to zero by \hyperref[usvd-SV_SetZero]{SV{\_}SetZero}.
	
	Input parameters: \code{U, S, V} = vector and matrices from \code{SV{\_}Decomp}; \code{Lb, Ub1, Ub2} = as in \code{SV{\_}Decomp}.
	
	Output parameter: \code{A} = approximated matrix.
	
\end{itemize}
\section{Unit ueigsym}
\label{ueigsym}
\index[unit]{ueigsym}
\subsection{Description}
Eigenvalues and eigenvectors of a symmetric matrix (SVD method).
\subsection{Functions and Procedures}
\subsubsection{EigenSym}
\label{ueigsym-EigenSym}
\index[proc]{EigenSym}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure EigenSym(A : TMatrix; Lb, Ub : Integer; Lambda : TVector; V : TMatrix);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Eigenvalues and eigenvectors of a symmetric matrix by singular value decomposition.
	
	Input parameters: \code{A} = matrix; \code{Lb} = index of first matrix element; \code{Ub} = index of last matrix element.
	
	Output parameters: \code{Lambda} = eigenvalues in decreasing order; \code{V} = matrix of eigenvectors (columns).
	
	Possible results : \code{MatOk, MatNonConv}.
	
	The eigenvectors are normalized, with their first component $ > 0$. This procedure destroys the original matrix \code{A}.
	
\end{itemize}
\section{Unit ueigval}
\label{ueigval}
\index[unit]{ueigval}
\subsection{Description}
Eigenvalues of a general square matrix
\subsection{Functions and Procedures}
\subsubsection{EigenVals}
\label{ueigval-EigenVals}
\index[proc]{EigenVals}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure EigenVals(A : TMatrix; Lb, Ub : Integer; Lambda : TCompVector);}
		
	\end{flushleft}
	
\end{itemize}
\section{Unit ueigvec}
\label{ueigvec}
\index[unit]{ueigvec}
\subsection{Description}
Eigenvalues and eigenvectors of a general square matrix. 
\subsection{Functions and Procedures}
\subsubsection{EigenVect}
\label{ueigvec-EigenVect}
\index[proc]{EigenVect}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure EigenVect(A : TMatrix; Lb, Ub : Integer; Lambda : TCompVector; V : TMatrix);}
		
	\end{flushleft}
	
\end{itemize}
\chapter[Package lmPolynoms]{Package lmPolynoms: Units to Solve and Explore Polynomials}\label{package-lmPolynoms}
\section{Description}
This package contains several units to find polynom roots and critical points, and to evaluate polynomials and rational fractions.
\section{Unit upolynom}
\label{upolynom}
\index[unit]{upolynom}
\subsection{Description}
Evaluates polynomials and rational fractions. 
\subsection{Functions and Procedures}
\subsubsection{Poly}
\label{upolynom-Poly}
\index[proc]{Poly}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function Poly(X : Float; Coef : TVector; Deg : Integer) : Float;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Evaluates the polynomial : $P(X) = Coef_0 + Coef_1 X + Coef_2 X^2 + \dots + Coef_{Deg} X^{Deg}$
\end{itemize}
\subsubsection{RFrac}
\label{upolynom-RFrac}
\index[proc]{RFrac}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function RFrac(X : Float; Coef : TVector; Deg1, Deg2 : Integer) : Float;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Evaluates the rational fraction :
	$$F(X) = \frac{ Coef_0 + Coef_1 X + Coef_2 X^2 + \dots + Coef_{Deg} X^{Deg}}{ 1 + Coef_{Deg+1} X + Coef_{Deg+3} X^2 + \dots + Coef_{Deg+Deg2} X^{Deg}}$$
\end{itemize}
\section{Unit urootpol}
\label{urootpol}
\index[unit]{urootpol}
\subsection{Description}
Find roots of an arbitrary polynomial. If $Deg \le 4$, finds analytical solution using units \code{urtpol1..urtpol4}, otherwise finds them numerically from the companion matrix.
\subsection{Functions and Procedures}
\subsubsection{RootPol}
\label{urootpol-RootPol}
\index[proc]{RootPol}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function RootPol(Coef : TVector; Deg : Integer; Z : TCompVector) : Integer;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Solves the polynomial equation:\\ 
	$Coef_0 + Coef_1 X + Coef_2 X^2 + \dots + Coef_{Deg} X^{Deg} = 0$
	
	Returns number of real roots. If an error occurred during the search for the i-th root, the function returns
	(-i). The roots should be correct for indices (i+1)..Deg. The roots are unordered.
\end{itemize}

\section{Unit urtpol1}
\label{urtpol1}
\index[unit]{urtpol1}
Linear equation 
\subsection{Functions and Procedures}
\subsubsection{RootPol1}
\label{urtpol1-RootPol1}
\index[proc]{RootPol1}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function RootPol1(A, B : Float; var X : Float) : Integer;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Solves the linear equation $A + B X = 0$. Returns 1 if no error ($B \ne 0$); -1 if X is undetermined ($A = B = 0$); -2 if no solution ($A \ne 0,\ B = 0$).
\end{itemize}
\section{Unit urtpol2}
\label{urtpol2}
\index[unit]{urtpol2}
\subsection{Description}Roots of Quadratic equation.
\subsection{Functions and Procedures}
\subsubsection{RootPol2}
\label{urtpol2-RootPol2}
\index[proc]{RootPol2}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function RootPol2(Coef : TVector; Z : TCompVector) : Integer;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Solves the quadratic equation:\\ 
	$Coef_0 + Coef_1 * X + Coef_2 X^2 = 0$
	
\end{itemize}
\section{Unit urtpol3}
\label{urtpol3}
\index[unit]{urtpol3}
\subsection{Description}
Cubic equation
\subsection{Functions and Procedures}
\subsubsection{RootPol3}
\label{urtpol3-RootPol3}
\index[proc]{RootPol3}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function RootPol3(Coef : TVector; Z : TCompVector) : Integer;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Solves the cubic equation:\\
	$Coef_0 + Coef_1 X + Coef_2 X^2 + Coef_3 X^3 = 0$
	
\end{itemize}
\section{Unit urtpol4}
\label{urtpol4}
\index[unit]{urtpol4}
\subsection{Description} Roots of a quartic equation
\subsection{Functions and Procedures}
\subsubsection{RootPol4}
\label{urtpol4-RootPol4}
\index[proc]{RootPol4}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function RootPol4(Coef : TVector; Z : TCompVector) : Integer;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Solves the quartic equation:\\
	$Coef_0 + Coef_1 X + Coef_2 X^2 + Coef_3 X^3 + Coef_4 X^4 = 0$
	
\end{itemize}
\section{Unit ucrtptpol}\label{unit-ucrtptpol}\lmath{-24pt}
\subsection{Description}
This unit defines routines to find a derivative of a polynomial and its critical points. Introduced in LMath.
\label{ucrtptpol}
\index[unit]{ucrtptpol}
\subsection{Functions and Procedures}
\subsubsection{DerivPolynom}
\label{ucrtptpol-DerivPolynom}
\index[proc]{DerivPolynom}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure DerivPolynom(Coef:TVector; Deg:integer; DCoef:TVector; out DDeg:integer);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Finds derivative of a polynomial, which is polynomial of lesser degree. Input parameters: Coef: coefficients of polynomial; Deg: degree of polynomial. Output: DCoef: coefficients of derivative polynomial; DDeg: degree of derivative polynom (Deg - 1).
	
\end{itemize}
\subsubsection{CriticalPoints}
\label{ucrtptpol-CriticalPoints}
\index[proc]{CriticalPoints}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function CriticalPoints(Coef:TVector; Deg:integer; CtrPoints: TRealPointVector; PointTypes: TIntVector):integer;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Finds extrema of polynomial.  Input: Coef: coefficients of polynomial; Deg: degree of polynomial. Output: CRTPoints: Critical points; $CRTPoints_i.X$ is abscissa, $CRTPoints_i.Y$ is function value at each of $CrtPoints_i$; Types: type of critical points: -1: it is minimum, 0: no extremum; +1: maximum. Returns number of critical points.
	
\end{itemize}
\section{Unit upolutil}
\label{upolutil}
\index[unit]{upolutil}
\subsection{Description}
Utility functions to handle roots of polynomials
\subsection{Functions and Procedures}
\subsubsection{SetRealRoots}
\label{upolutil-SetRealRoots}
\index[proc]{SetRealRoots}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function SetRealRoots(Deg : Integer; Z : TCompVector; Tol : Float) : Integer;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Set the imaginary part of a root to zero if it is less than a fraction Tol of its real part. This root is therefore considered real. The function returns the total number of real roots.
	
\end{itemize}
\subsubsection{SortRoots}
\label{upolutil-SortRoots}
\index[proc]{SortRoots}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure SortRoots(Deg : Integer; Z : TCompVector);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Sort roots so that:
	
	(1) The Nr real roots are stored in elements [1..Nr] of vector Z, in increasing order.
	
	(2) The complex roots are stored in elements [(Nr + 1)..Deg] of vector Z and are unordered.
\end{itemize}
\chapter[Package lmIntegrals]{Package lmIntegrals: Numeric Integrating and Solving Differential Equations}\label{package-lmIntegrals}
\section{Unit ugausleg}
\label{ugausleg}
\index[unit]{ugausleg}
\subsection{Description}
Gauss-Legendre integration
\subsection{Functions and Procedures}
\subsubsection{GausLeg}
\label{ugausleg-GausLeg}
\index[proc]{GausLeg}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function GausLeg(Func : TFunc; A, B : Float) : Float;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Computes the integral of function Func from A to B
	by the Gauss-Legendre method
\end{itemize}
\subsubsection{GausLeg0}
\label{ugausleg-GausLeg0}
\index[proc]{GausLeg0}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function GausLeg0(Func : TFunc; B : Float) : Float;}
	\end{flushleft}
	\item[\descriptiontitle{Description}]
	Computes the integral of function Func from 0 to B
	by the Gauss-Legendre method
\end{itemize}
\subsubsection{Convol}
\label{ugausleg-Convol}
\index[proc]{Convol}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function Convol(Func1, Func2 : TFunc; T : Float) : Float;}
	\end{flushleft}
	\item[\descriptiontitle{Description}]
	Computes the convolution product of two functions Func1 and Func2 at time T by the Gauss-Legendre method.
\end{itemize}
\section{Unit urkf}
\label{urkf}
\index[unit]{urkf}
\subsection{Description}
Numerical integration of a system of differential equations by the Runge{-}Kutta{-}Fehlberg (RKF) method.\\
Adapted from a Fortran{-}90 program available at:\\ \href{http://www.csit.fsu.edu/~burkardt/f_src/rkf45/rkf45.f90}{http://www.csit.fsu.edu/~burkardt/f{\_}src/rkf45/rkf45.f90}\\ 
\subsection{Functions and Procedures}
\subsubsection{RKF45}
\label{urkf-RKF45}
\index[proc]{RKF45}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure RKF45(F : TDiffEqs; Neqn : Integer; Y, Yp : TVector; var T : Float; Tout, RelErr, AbsErr : Float; var Flag : Integer);}
	\end{flushleft}
	\item[\descriptiontitle{Description}]
	RKF45 carries out the Runge-Kutta-Fehlberg method.
	
	This routine is primarily designed to solve non-stiff and mildly stiff
	differential equations when derivative evaluations are inexpensive.
	It should generally not be used when the user is demanding
	high accuracy.
	
	This routine integrates a system of Neqn first-order ordinary
	differential equations of the form:
	$$\frac{dY_i}{dT} = \textrm{F}(T,Y_1,Y_2,...,Y_Neqn)$$
	where the $Y_1..Y_{Neqn}$ are given at $T$.
	
	Typically the subroutine is used to integrate from $T$ to $T{out}$ but it
	can be used as a one-step integrator to advance the solution a
	single step in the direction of $T{out}$.  On return, the parameters in
	the call list are set for continuing the integration.  The user has
	only to call again (and perhaps define a new value for $T{out}$).
	
	Before the first call, the user must
	\begin{itemize}
		\item supply the F in form: \code{procedure(X : Float; Y, Yp : TVector)}\ to evaluate the right hand side;
		\item initialize the parameters:
		\code{Neqn, Y[1:Neqn], T, Tout, RelErr, AbsErr, Flag}.
		In particular, \code{T} should initially be the starting point for integration,
		\code{Y} should be the value of the initial conditions, and \code{Flag}\ should
		normally be +1.
	\end{itemize}
	
	Normally, the user only sets the value of \code{Flag}\ before the first call, and
	thereafter, the program manages the value.  On the first call, \code{Flag}\ should
	normally be +1 (or -1 for single step mode.)  On normal return, \code{Flag}\ will
	have been reset by the program to the value of 2 (or -2 in single
	step mode), and the user can continue to call the routine with that
	value of \code{Flag}.
	
	(When the input magnitude of \code{Flag}\ is 1, this indicates to the program
	that it is necessary to do some initialization work.  An input magnitude
	of 2 lets the program know that that initialization can be skipped,
	and that useful information was computed earlier.)
	
	The routine returns with all the information needed to continue
	the integration.  If the integration reached \code{Tout}, the user need only
	define a new \code{Tout} and call again.  In the one-step integrator
	mode, returning with \code{Flag}\ = -2, the user must keep in mind that
	each step taken is in the direction of the current TOUT.  Upon
	reaching \code{Tout}, indicated by the output value of FLAG switching to 2,
	the user must define a new \code{Tout} and reset \code{Flag}\ to -2 to continue
	in the one-step integrator mode.
	
	In some cases, an error or difficulty occurs during a call.  In that case,
	the output value of \code{Flag}\ is used to indicate that there is a problem
	that the user must address.  These values include:
	\begin{itemize}
		\item 3, integration was not completed because the input value of \code{RelErr}, the
		relative error tolerance, was too small.  \code{RelErr} has been increased
		appropriately for continuing.  If the user accepts the output value of
		\code{RelErr}, then simply reset \code{Flag}\ to 2 and continue.
		\item 4, integration was not completed because more than \code{MAXNFE} (3000) derivative
		evaluations were needed.  This is approximately \code{(MAXNFE}/6) steps.
		The user may continue by simply calling again.  The function counter
		will be reset to 0, and another \code{MAXNFE} function evaluations are allowed.
		\item 5, integration was not completed because the solution vanished,
		making a pure relative error test impossible.  The user must use
		a non-zero \code{AbsErr} to continue.  Using the one-step integration mode
		for one step is a good way to proceed.
		\item 6, integration was not completed because the requested accuracy
		could not be achieved, even using the smallest allowable stepsize.
		The user must increase the error tolerances \code{AbsErr} or \code{RelErr} before
		continuing.  It is also necessary to reset \code{Flag}\ to 2 (or -2 when
		the one-step integration mode is being used).  The occurrence of
		\code{Flag}\ = 6 indicates a trouble spot.  The solution is changing
		rapidly, or a singularity may be present.  It often is inadvisable
		to continue.
		\item 7, it is likely that this routine is inefficient for solving
		this problem.  Too much output is restricting the natural stepsize
		choice.  The user should use the one-step integration mode with
		the stepsize determined by the code.  If the user insists upon
		continuing the integration, reset \code{Flag}\ to 2 before calling
		again.  Otherwise, execution will be terminated.
		\item 8, invalid input parameters, indicates one of the following:
		$Neqn \le 0$;\\
		T = Tout and $|Flag| \ne 1$;\\
		$RelErr < 0$ or $AbsErr < 0$;\\
		Flag = 0  or Flag not in [-2..8].
	\end{itemize}
	Modified:
	
	27 March 2004
	
	Author:
	
	H A Watts and L F Shampine,
	Sandia Laboratories,
	Albuquerque, New Mexico.
	
	Reference:
	
	E. Fehlberg,
	Low-order Classical Runge-Kutta Formulas with Stepsize Control,
	NASA Technical Report R-315.
	
	L F Shampine, H A Watts, S Davenport,
	Solving Non-stiff Ordinary Differential Equations - The State of the Art,
	SIAM Review,
	Volume 18, pages 376-411, 1976.
	
	Parameters: 
	\begin{itemize}
		\item Input, F, a user-supplied function to evaluate the derivatives Y(T), of the form:\code{ procedure(X : Float; Y, Yp : TVector);}
		\item Input, \code{Neqn}, the number of equations to be integrated;
		\item Input/output, \code{Y[1..Neqn]}, the current solution vector at T; 
		\item Output, \code{YP[1..Neqn]}, the current value of the derivative of the dependent variable. The user should not set or alter this information;
		\item Input/output, T, the current value of the independent variable;
		\item Input, \code{Tout}, the output point at which solution is desired. \code{Tout} = T is allowed on the first call only, in which case the routine returns with Flag = 2 if continuation is possible.
		\item Input/output, \code{RelErr, AbsErr,} the relative and absolute error tolerances for the local error test. At each step the code requires: 
		$$abs(local error) \le RelErr * abs(Y) + AbsErr$$ for each component of the local error and the solution vector Y. \code{RelErr} cannot be "too small". If the routine believes \code{RelErr} has been set too small, it will reset \code{RelErr} to an acceptable value and return immediately for user action.
		\item Input/output, \code{Flag}, indicator for status of integration. On the first call, set \code{Flag}\ to +1 for normal use, or to -1 for single step mode. On return, a value of 2 or -2 indicates normal progress, while any other value indicates a problem that should be addressed.
	\end{itemize}
\end{itemize}
\section{Unit utrapint}
\label{utrapint}
\index[unit]{utrapint}
\subsection{Description}
Trapezoidal integration 
\subsection{Functions and Procedures}
\subsubsection{TrapInt}
\label{utrapint-TrapInt}
\index[proc]{TrapInt}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function TrapInt(X, Y : TVector; N : Integer) : Float;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Integration by trapezoidal rule, from (X[0], Y[0]) to (X[N], Y[N])
	
\end{itemize}
\subsubsection{ConvTrap}
\label{utrapint-ConvTrap}
\index[proc]{ConvTrap}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure ConvTrap(Func1, Func2 : TFunc; T, Y : TVector; N : Integer);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Computes the convolution product of 2 functions Func1 and Func2 by the trapezoidal rule over an array T[0..N] of equally spaced abscissas, with T[0] = 0. The result is returned in Y[0..N]
	
\end{itemize}
\chapter[Package lmRandoms]{Package lmRandoms: Random Numbers From Different Intervals and Distrubutions}\label{package-lmRandoms}
\section{Unit uranmt}
\label{uranmt}
\index[unit]{uranmt}
\subsection{Description}
Mersenne Twister Random Number Generator 

A C{-}program for MT19937, with initialization improved 2002/1/26. Coded by Takuji Nishimura and Makoto Matsumoto.

Adapted for DMath by Jean Debord {-} Feb. 2007

Before using, initialize the state by using init{\_}genrand(seed) or init{\_}by{\_}array(\allowbreak init{\_}key, key{\_}length) (respectively InitMT and InitMTbyArray in the TPMath version).

Copyright (C) 1997 {-} 2002, Makoto Matsumoto and Takuji Nishimura, All rights reserved.

Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
\begin{enumerate}
	\item Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
	
	\item Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
	
	\item The names of its contributors may not be used to endorse or promote products derived from this software without specific prior written permission.
\end{enumerate}

Any feedback is very welcome.\\ \href{http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/emt.html}{http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/emt.html} email: m{-}mat @ math.sci.hiroshima{-}u.ac.jp (remove space) 
\subsection{Functions and Procedures}
\subsubsection{InitMT}
\label{uranmt-InitMT}
\index[proc]{InitMT}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure InitMT(Seed : Integer);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Initializes MT generator with a seed
	
\end{itemize}
\subsubsection{InitMTbyArray}
\label{uranmt-InitMTbyArray}
\index[proc]{InitMTbyArray}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure InitMTbyArray(InitKey : MTKeyArray; KeyLength : Word);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Initialize MT generator with an array InitKey[0..(KeyLength {-} 1)]
	
\end{itemize}
\subsubsection{IRanMT}
\label{uranmt-IRanMT}
\index[proc]{IRanMT}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function IRanMT : Integer;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Generates a Random number on [{-}2{\^{}}31 .. 2{\^{}}31 {-} 1] interval
	
\end{itemize}
\subsection{Types}
\subsubsection{MTKeyArray}
\label{uranmt-MTKeyArray}
\index[const]{MTKeyArray}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			MTKeyArray = array[0..623] of Cardinal;}
		
	\end{flushleft}
	
\end{itemize}
\section{Unit uranmwc}
\label{uranmwc}
\index[unit]{uranmwc}
\subsection{Description}
Marsaglia's Multiply{-}With{-}Carry random number generator 
\subsection{Functions and Procedures}
\subsubsection{InitMWC}
\label{uranmwc-InitMWC}
\index[proc]{InitMWC}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure InitMWC(Seed : Integer);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Initializes the 'Multiply with carry' random number generator.
	
\end{itemize}
\subsubsection{IRanMWC}
\label{uranmwc-IRanMWC}
\index[proc]{IRanMWC}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function IRanMWC : Integer;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Returns a 32 bit random number in [{-}2{\^{}}31 ; 2{\^{}}31{-}1]
	
\end{itemize}
\section{Unit uranuvag}
\label{uranuvag}
\index[unit]{uranuvag}
\subsection{Description}
UVAG The Universal Virtual Array Generator by Alex Hay zenjew@hotmail.com Adapted to DMath by Jean Debord 

In practice, Cardinal (6{-}7 times the output of Word) is the IntType of choice, but to demonstrate UVAG's scalability here, IntType can be defined as any integer data type. IRanUVAG globally provides (as rndint) an effectively infinite sequence of IntTypes, uniformly distributed (0, 2{\^{}}(8*sizeof(IntType)){-}1). Output (bps) is dependent solely on IntSize=sizeof(IntType) and CPU speed. UVAG cycles at twice the speed of the 64{-}bit Mersenne Twister in a tenth the memory, tests well in DIEHARD, ENT and NIST and has a huge period. It is suitable for cryptographic purposes in that state(n) is not determinable from state(n+1). Most attractive is that it uses integers of any size and requires an array of only 255 + sizeof(IntType) bytes. Thus it is easily adapted to 128 bits and beyond with negligible memory increase. Lastly, seeding is easy. From near zero entropy (s[]=0, rndint {$>$} 0), UVAG bootstraps itself to full entropy in under 300 cycles. Very robust, no bad seeds.
\subsection{Functions and Procedures}
\subsubsection{InitUVAGbyString}
\label{uranuvag-InitUVAGbyString}
\index[proc]{InitUVAGbyString}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure InitUVAGbyString(KeyPhrase : string);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Initializes the generator with a string
	
\end{itemize}
\subsubsection{InitUVAG}
\label{uranuvag-InitUVAG}
\index[proc]{InitUVAG}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure InitUVAG(Seed : Integer);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Initializes the generator with an integer
	
\end{itemize}
\subsubsection{IRanUVAG}
\label{uranuvag-IRanUVAG}
\index[proc]{IRanUVAG}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function IRanUVAG : Integer;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Returns a 32{-}bit random integer
	
\end{itemize}
\section{Unit urandom}
\label{urandom}
\index[unit]{urandom}
\subsection{Description}
Random number generators 
\subsection{Functions and Procedures}
\subsubsection{SetRNG}
\label{urandom-SetRNG}
\index[proc]{SetRNG}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure SetRNG(RNG : RNG{\_}Type);}
	\end{flushleft}
	\item[\descriptiontitle{Description}]
	Select generator and set default initialization: RNG{\_}MWC = Multiply{-}With{-}Carry; RNG{\_}MT = Mersenne Twister; RNG{\_}UVAG = Universal Virtual Array Generator.
\end{itemize}
\subsubsection{InitGen}
\label{urandom-InitGen}
\index[proc]{InitGen}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure InitGen(Seed : Integer);}
	\end{flushleft}
	\item[\descriptiontitle{Description}]
	Initialize generator.
\end{itemize}
\subsubsection{IRanGen}
\label{urandom-IRanGen}
\index[proc]{IRanGen}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function IRanGen : Integer;}
	\end{flushleft}
	\par
	\item[\descriptiontitle{Description}]
	32{-}bit random integer in $[-2^{31}..2^{31}-1]$.
\end{itemize}
\subsubsection{IRanGen31}
\label{urandom-IRanGen31}
\index[proc]{IRanGen31}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function IRanGen31 : Integer;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	31-bit random integer in $[0..2^{31}-1]$.
	
\end{itemize}
\subsubsection{RanGen1}
\label{urandom-RanGen1}
\index[proc]{RanGen1}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function RanGen1 : Float;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	32-bit random real in [0,1].
	
\end{itemize}
\subsubsection{RanGen2}
\label{urandom-RanGen2}
\index[proc]{RanGen2}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function RanGen2 : Float;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	32-bit random real in [0,1).
	
\end{itemize}
\subsubsection{RanGen3}
\label{urandom-RanGen3}
\index[proc]{RanGen3}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function RanGen3 : Float;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	32-bit random real in (0,1).
	
\end{itemize}
\subsubsection{RanGen53}
\label{urandom-RanGen53}
\index[proc]{RanGen53}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function RanGen53 : Float;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	53-bit random real in [0,1).
	
\end{itemize}
\section{Unit urangaus}
\label{urangaus}
\index[unit]{urangaus}
\subsection{Description}
Gaussian random numbers
\subsection{Functions and Procedures}
\subsubsection{RanGaussStd}
\label{urangaus-RanGaussStd}
\index[proc]{RanGaussStd}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function RanGaussStd : Float;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Computes 2 random numbers from the standard normal distribution, returns one and saves the other for the next call.
	
\end{itemize}
\subsubsection{RanGauss}
\label{urangaus-RanGauss}
\index[proc]{RanGauss}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function RanGauss(Mu, Sigma : Float) : Float;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Returns a random number from a Gaussian distribution with mean Mu and standard deviation Sigma.
	
\end{itemize}

\section{Unit uranmult}
\label{uranmult}
\index[unit]{uranmult}
\subsection{Description} Random number from a multinormal distribution.
\subsection{Functions and Procedures}
\subsubsection{RanMult}
\label{uranmult-RanMult}
\index[proc]{RanMult}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure RanMult(M : TVector; L : TMatrix; Lb, Ub : Integer; X : TVector);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Generates a random vector X from a multinormal distribution. M is the mean vector, L is the Cholesky factor (lower triangular) of the variance{-}covariance matrix.
	
\end{itemize}
\subsubsection{RanMultIndep}
\label{uranmult-RanMultIndep}
\index[proc]{RanMultIndep}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure RanMultIndep(M, S : TVector; Lb, Ub : Integer; X : TVector);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Generates a random vector X from a multinormal distribution with uncorrelated variables. M is the mean vector, S is the vector of standard deviations.
	
\end{itemize}


\chapter[Package lmMathStat]{Package lmMathStat: Distributions and Hypothesis Testing}\label{package-lmMathStat}
\section{Unit umeansd}
\label{umeansd}
\index[unit]{umeansd}
\subsection{Description}
Mean and standard deviations
\subsection{Functions and Procedures}
\subsubsection{Min}
\label{umeansd-Min}
\index[proc]{Min}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function Min(X : TVector; Lb, Ub : Integer) : Float;}
	\end{flushleft}
	\item[\descriptiontitle{Description}]
	Minimum of sample X
\end{itemize}
\subsubsection{Max}
\label{umeansd-Max}
\index[proc]{Max}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function Max(X : TVector; Lb, Ub : Integer) : Float;}
	\end{flushleft}
	\item[\descriptiontitle{Description}]
	Maximum of sample X
\end{itemize}
\subsubsection{Sum}\label{umeansd-sum} \lmath{-24pt}
\begin{itemize}
	\item[\declarationitem{Declaration}\hfill]
	\code{function Sum(X:TVector; Lb, Ub : integer) : Float;}
	\item[\descriptiontitle{Description}]
	Sum of sample X.
\end{itemize}
\subsubsection{Mean}
\label{umeansd-Mean}
\index[proc]{Mean}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function Mean(X : TVector; Lb, Ub : Integer) : Float;}
	\end{flushleft}
	\item[\descriptiontitle{Description}]
	Mean of sample X
\end{itemize}
\subsubsection{StDev}
\label{umeansd-StDev}
\index[proc]{StDev}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function StDev(X : TVector; Lb, Ub : Integer; M : Float) : Float;}
	\end{flushleft}
	\item[\descriptiontitle{Description}]
	Standard deviation estimated from sample X
\end{itemize}
\subsubsection{StDevP}
\label{umeansd-StDevP}
\index[proc]{StDevP}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function StDevP(X : TVector; Lb, Ub : Integer; M : Float) : Float;}
	\end{flushleft}
	\item[\descriptiontitle{Description}]
	Standard deviation of population
\end{itemize}
\section{Unit umeansd{\_}md}\lmath{-24pt}
\label{umeansd_md}
\index[unit]{umeansd{\_}md}
\subsection{Description}
Mean and standard deviations, aware of missing data. Completely written for LMath.
\subsection{Functions and Procedures}
\subsubsection{Undefined}
\label{umeansd_md-Undefined}
\index[proc]{Undefined}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function Undefined(F:Float):boolean;}
	\end{flushleft}
	\item[\descriptiontitle{Description}]
	returns true if F is NAN or Missing data
\end{itemize}
\subsubsection{SetMD}
\label{umeansd_md-SetMD}
\index[proc]{SetMD}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure SetMD(aMD:float);}
	\end{flushleft}
	\item[\descriptiontitle{Description}]
	set missing data code
\end{itemize}
\subsubsection{FirstDefined}
\label{umeansd_md-FirstDefined}
\index[proc]{FirstDefined}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function FirstDefined(X:TVector; Lb,Ub:Integer):integer;}
	\end{flushleft}
	\item[\descriptiontitle{Description}]
	Finds first defined element in array
\end{itemize}
\subsubsection{ValidN}
\label{umeansd_md-ValidN}
\index[proc]{ValidN}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function ValidN(X:TVector; Lb, Ub:Integer):integer;}
	\end{flushleft}
	\item[\descriptiontitle{Description}]
	valid (defined) number of elements in array
\end{itemize}
\subsubsection{Min}
\label{umeansd_md-Min}
\index[proc]{Min}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function Min(X : TVector; Lb, Ub : Integer) : Float;}
	\end{flushleft}
	\item[\descriptiontitle{Description}]
	Minimum of sample X
\end{itemize}
\subsubsection{Max}
\label{umeansd_md-Max}
\index[proc]{Max}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function Max(X : TVector; Lb, Ub : Integer) : Float;}
	\end{flushleft}
	\item[\descriptiontitle{Description}]
	Maximum of sample X
\end{itemize}
\subsubsection{Mean}
\label{umeansd_md-Mean}
\index[proc]{Mean}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function Mean(X : TVector; Lb, Ub : Integer) : Float;}
	\end{flushleft}
	\item[\descriptiontitle{Description}]
	Mean of sample X
\end{itemize}
\subsubsection{StDev}
\label{umeansd_md-StDev}
\index[proc]{StDev}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function StDev(X : TVector; Lb, Ub : Integer) : Float;}
	\end{flushleft}
	\item[\descriptiontitle{Description}]
	Standard deviation estimated from sample X
\end{itemize}
\subsubsection{StDevP}
\label{umeansd_md-StDevP}
\index[proc]{StDevP}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function StDevP(X : TVector; Lb, Ub : Integer) : Float;}
	\end{flushleft}
	\item[\descriptiontitle{Description}]
	Standard deviation of population
\end{itemize}
\subsection{Variables}
\subsubsection{MissingData}
\label{umeansd_md-MissingData}
\index[var]{MissingData}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			MissingData: Float = NAN;}
	\end{flushleft}
\end{itemize}
\section{Unit umedian}
\label{umedian}
\index[unit]{umedian}
\subsection{Description}
Median 
\subsection{Functions and Procedures}
\subsubsection{Median}
\label{umedian-Median}
\index[proc]{Median}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function Median(X : TVector; Lb, Ub : Integer) : Float;}
	\end{flushleft}
	\item[\descriptiontitle{Description}]
	Returns median for vector X
\end{itemize}
\section{Unit udistrib}
\label{udistrib}
\index[unit]{udistrib}
\subsection{Description}
Statistical distribution 
\subsection{Functions and Procedures}
\subsubsection{DimStatClassVector}
\label{udistrib-DimStatClassVector}
\index[proc]{DimStatClassVector}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function DimStatClassVector(out C : TStatClassVector; A, B, H : float):integer;}
	\end{flushleft}
	\item[\descriptiontitle{Description}]
	Allocates an array of statistical classes (histogram bins).
	\code{A} is lower border of histogram; \code{B} is upper border; \code{H} is bin width.
	Function calculates number of bins and allocates them. Number of bins is returned. If allocation is impossible, nil is returned.
\end{itemize}
\subsubsection{Distrib}
\label{udistrib-Distrib}
\index[proc]{Distrib}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure Distrib(X : TVector; Lb, Ub : Integer; A, B, H : Float; C : TStatClassVector);}
	\end{flushleft}
	\item[\descriptiontitle{Description}]
	Distributes the values of array X[Lb..Ub] into M classes with equal width H, according to the following scheme:
	\begin{verbatim}
	C[1]    C[2]                    C[M]
	]-------]-------].......]-------]-------]
	A      A+H     A+2H                     B
	\end{verbatim}	
	such that $ B = A + M H$
	
\end{itemize}
\section{Unit uskew}
\label{uskew}
\index[unit]{uskew}
\subsection{Description}
Skewness and kurtosis
\subsection{Functions and Procedures}
\subsubsection{Skewness}
\label{uskew-Skewness}
\index[proc]{Skewness}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function Skewness(X : TVector; Lb, Ub : Integer; M, Sigma : Float) : Float;}
	\end{flushleft}
\end{itemize}
\subsubsection{Kurtosis}
\label{uskew-Kurtosis}
\index[proc]{Kurtosis}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function Kurtosis(X : TVector; Lb, Ub : Integer; M, Sigma : Float) : Float;}
	\end{flushleft}
\end{itemize}
\section{Unit ubinom}
\label{ubinom}
\index[unit]{ubinom}
\subsection{Description}
Binomial distribution 
\subsection{Functions and Procedures}
\subsubsection{Binomial}
\label{ubinom-Binomial}
\index[proc]{Binomial}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function Binomial(N, K : Integer) : Float;}
	\end{flushleft}
	\item[\descriptiontitle{Description}]
	Binomial coefficient $\binom{N}{K}$
\end{itemize}
\subsubsection{PBinom}
\label{ubinom-PBinom}
\index[proc]{PBinom}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function PBinom(N : Integer; P : Float; K : Integer) : Float;}
	\end{flushleft}
	\item[\descriptiontitle{Description}]
	Probability of binomial distribution
\end{itemize}
\section{Unit upoidist}
\label{upoidist}
\index[unit]{upoidist}
\subsection{Description}
Poisson distribution 
\subsection{Overview}
\begin{description}
	\item[\texttt{PPoisson}]
\end{description}
\subsection{Functions and Procedures}
\subsubsection{PPoisson}
\label{upoidist-PPoisson}
\index[proc]{PPoisson}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function PPoisson(Mu : Float; K : Integer) : Float;}
	\end{flushleft}
	\item[\descriptiontitle{Description}]
	Probability of Poisson distribution. Probability to observe K if mean is $\mu$.
\end{itemize}

\section{Unit uexpdist}
\label{uexpdist}
\index[unit]{uexpdist}
\subsection{Description}
Exponential distribution 
\subsection{Functions and Procedures}
\subsubsection{DExpo}
\label{uexpdist-DExpo}
\index[proc]{DExpo}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function DExpo(A, X : Float) : Float;}
	\end{flushleft}
	\item[\descriptiontitle{Description}]
	Density of exponential distribution with parameter A.
\end{itemize}
\subsubsection{FExpo}
\label{uexpdist-FExpo}
\index[proc]{FExpo}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function FExpo(A, X : Float) : Float;}
	\end{flushleft}
	\item[\descriptiontitle{Description}]
	Cumulative probability function for exponential distribution with parameter A.
\end{itemize}
\section{Unit unormal}
\label{unormal}
\index[unit]{unormal}
\subsection{Description}
Density of standard normal distribution. 
\subsection{Functions and Procedures}
\subsubsection{DNorm}
\label{unormal-DNorm}
\index[proc]{DNorm}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function DNorm(X : Float) : Float;}
	\end{flushleft}
	\item[\descriptiontitle{Description}]
	Density of standard normal distribution
\end{itemize}
\subsubsection{DGaussian}\lmath{-24pt}
\label{unormal-DGaussian}
\index[proc]{DGaussian}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function DGaussian(X, Mean, Sigma: float) : float;}
	\end{flushleft}
	\item[\descriptiontitle{Description}]
	Density of gaussian distribution with orbitrary math. expectation Mean and standard deviation Sigma.
\end{itemize}
\section{Unit uinvnorm}
\label{uinvnorm}
\index[unit]{uinvnorm}
\subsection{Description}
Inverse of Normal distribution function. 
Translated from C code in Cephes library (\href{http://www.moshier.net}{http://www.moshier.net}) \subsection{Functions and Procedures}
\subsubsection{InvNorm}
\label{uinvnorm-InvNorm}
\index[proc]{InvNorm}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function InvNorm(P : Float) : Float;}
	\end{flushleft}
	\item[\descriptiontitle{Description}]
	Inverse of Normal distribution function
	
	Returns the argument, X, for which the area under the Gaussian probability density function (integrated from $-\infty$ to X) is equal to P.
\end{itemize}
\section{Unit uigmdist}
\label{uigmdist}
\index[unit]{uigmdist}
\subsection{Description}
Probability functions related to the incomplete Gamma function 
\subsection{Functions and Procedures}
\subsubsection{FGamma}
\label{uigmdist-FGamma}
\index[proc]{FGamma}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function FGamma(A, B, X : Float) : Float;}
	\end{flushleft}
	\item[\descriptiontitle{Description}]
	Cumulative probability for Gamma distribution with parameters A and B.
\end{itemize}
\subsubsection{FPoisson}
\label{uigmdist-FPoisson}
\index[proc]{FPoisson}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function FPoisson(Mu : Float; K : Integer) : Float;}
	\end{flushleft}
	\item[\descriptiontitle{Description}]
	Cumulative probability for Poisson distribution.
\end{itemize}
\subsubsection{FNorm}
\label{uigmdist-FNorm}
\index[proc]{FNorm}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function FNorm(X : Float) : Float;}
	\end{flushleft}
	\item[\descriptiontitle{Description}]
	Cumulative probability for standard normal distribution.
\end{itemize}
\subsubsection{PNorm}
\label{uigmdist-PNorm}
\index[proc]{PNorm}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function PNorm(X : Float) : Float;}
	\end{flushleft}
	\item[\descriptiontitle{Description}]
	Prob($|U| > X$) for standard normal distribution.
\end{itemize}
\subsubsection{FKhi2}
\label{uigmdist-FKhi2}
\index[proc]{FKhi2}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function FKhi2(Nu : Integer; X : Float) : Float;}
	\end{flushleft}
	\item[\descriptiontitle{Description}]
	Cumulative prob. for $\chi^2$ distrib. with Nu d.o.f.
\end{itemize}
\subsubsection{PKhi2}
\label{uigmdist-PKhi2}
\index[proc]{PKhi2}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function PKhi2(Nu : Integer; X : Float) : Float;}
	\end{flushleft}
	\item[\descriptiontitle{Description}]
	Prob(Khi2 {$>$} X) for $\chi^2$ distribution with Nu d.o.f.
\end{itemize}
\section{Unit ugamdist}
\label{ugamdist}
\index[unit]{ugamdist}
\subsection{Description}
Probability functions related to the Gamma function 
\subsection{Functions and Procedures}
\subsubsection{DBeta}
\label{ugamdist-DBeta}
\index[proc]{DBeta}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function DBeta(A, B, X : Float) : Float;}
	\end{flushleft}
	\item[\descriptiontitle{Description}]
	Density of Beta distribution with parameters A and B.
\end{itemize}
\subsubsection{DGamma}
\label{ugamdist-DGamma}
\index[proc]{DGamma}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function DGamma(A, B, X : Float) : Float;}
	\end{flushleft}
	\item[\descriptiontitle{Description}]
	Density of Gamma distribution with parameters A and B.
\end{itemize}
\subsubsection{DKhi2}
\label{ugamdist-DKhi2}
\index[proc]{DKhi2}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function DKhi2(Nu : Integer; X : Float) : Float;}
	\end{flushleft}
	\item[\descriptiontitle{Description}]
	Density of $\chi^2$ distribution with Nu d.o.f.
\end{itemize}
\subsubsection{DStudent}
\label{ugamdist-DStudent}
\index[proc]{DStudent}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function DStudent(Nu : Integer; X : Float) : Float;}
	\end{flushleft}
	\item[\descriptiontitle{Description}]
	Density of Student distribution with Nu d.o.f.
\end{itemize}
\subsubsection{DSnedecor}
\label{ugamdist-DSnedecor}
\index[proc]{DSnedecor}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function DSnedecor(Nu1, Nu2 : Integer; X : Float) : Float;}
	\end{flushleft}
	\item[\descriptiontitle{Description}]
	Density of Fisher{-}Snedecor distribution with Nu1 and Nu2 d.o.f.
\end{itemize}
\section{Unit uibtdist}
\label{uibtdist}
\index[unit]{uibtdist}
\subsection{Description}
Probability functions related to the incomplete Beta function.
\subsection{Functions and Procedures}
\subsubsection{FBeta}
\label{uibtdist-FBeta}
\index[proc]{FBeta}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function FBeta(A, B, X : Float) : Float;}
	\end{flushleft}
	\item[\descriptiontitle{Description}]
	Cumulative probability for Beta distrib. with param. A and B
\end{itemize}
\subsubsection{FBinom}
\label{uibtdist-FBinom}
\index[proc]{FBinom}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function FBinom(N : Integer; P : Float; K : Integer) : Float;}
	\end{flushleft}
	\item[\descriptiontitle{Description}]
	Cumulative probability for binomial distrib.
\end{itemize}
\subsubsection{FStudent}
\label{uibtdist-FStudent}
\index[proc]{FStudent}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function FStudent(Nu : Integer; X : Float) : Float;}
	\end{flushleft}
	\item[\descriptiontitle{Description}]
	Cumulative probability for Student distrib. with Nu d.o.f.
\end{itemize}
\subsubsection{PStudent}
\label{uibtdist-PStudent}
\index[proc]{PStudent}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function PStudent(Nu : Integer; X : Float) : Float;}
	\end{flushleft}
	\item[\descriptiontitle{Description}]
	Prob(|t| {$>$} X) for Student distrib. with Nu d.o.f.
\end{itemize}
\subsubsection{FSnedecor}
\label{uibtdist-FSnedecor}
\index[proc]{FSnedecor}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function FSnedecor(Nu1, Nu2 : Integer; X : Float) : Float;}
	\end{flushleft}
	\item[\descriptiontitle{Description}]
	Cumulative prob. for Fisher{-}Snedecor distrib. with Nu1 and Nu2 d.o.f.
\end{itemize}
\subsubsection{PSnedecor}
\label{uibtdist-PSnedecor}
\index[proc]{PSnedecor}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function PSnedecor(Nu1, Nu2 : Integer; X : Float) : Float;}
	\end{flushleft}
	\item[\descriptiontitle{Description}]
	Prob(F {$>$} X) for Fisher{-}Snedecor distrib. with Nu1 and Nu2 d.o.f.
\end{itemize}

\section{Unit uinvbeta}
\label{uinvbeta}
\index[unit]{uinvbeta}
\subsection{Description}
Inverses of incomplete Beta function, Student and F{-}distributions.\\
Translated from C code in Cephes library (\href{http://www.moshier.net}{http://www.moshier.net}) 
\subsection{Functions and Procedures}
\subsubsection{InvBeta}
\label{uinvbeta-InvBeta}
\index[proc]{InvBeta}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function InvBeta(A, B, Y : Float) : Float;}
	\end{flushleft}
	\par
	\item[\descriptiontitle{Description}]
	Inverse of incomplete Beta function. Given P, the function finds X such that IBeta(A, B, X) = Y
\end{itemize}
\subsubsection{InvStudent}
\label{uinvbeta-InvStudent}
\index[proc]{InvStudent}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function InvStudent(Nu : Integer; P : Float) : Float;}
	\end{flushleft}
	\item[\descriptiontitle{Description}]
	Inverse of Student's t{-}distribution function Given probability P, finds the argument X such that FStudent(Nu, X) = P
\end{itemize}
\subsubsection{InvSnedecor}
\label{uinvbeta-InvSnedecor}
\index[proc]{InvSnedecor}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function InvSnedecor(Nu1, Nu2 : Integer; P : Float) : Float;}
	\end{flushleft}
	\item[\descriptiontitle{Description}]
	Inverse of Snedecor's F{-}distribution function Given probability P, finds the argument X such that FSnedecor(Nu1, Nu2, X) = P
\end{itemize}
\section{Unit uinvgam}
\label{uinvgam}
\index[unit]{uinvgam}
\subsection{Description}
Inverses of incomplete Gamma function and $\chi^2$ distribution.\\ Translated from C code in Cephes library (\href{http://www.moshier.net}{http://www.moshier.net}) 
\subsection{Functions and Procedures}
\subsubsection{InvGamma}
\label{uinvgam-InvGamma}
\index[proc]{InvGamma}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function InvGamma(A, P : Float) : Float;}
	\end{flushleft}
	\item[\descriptiontitle{Description}]
	Given P, the function finds X such that IGamma(A, X) = P It is best valid in the right{-}hand tail of the distribution, P {$>$} 0.5
\end{itemize}
\subsubsection{InvKhi2}
\label{uinvgam-InvKhi2}
\index[proc]{InvKhi2}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function InvKhi2(Nu : Integer; P : Float) : Float;}
	\end{flushleft}
	\item[\descriptiontitle{Description}]
	Inverse of Khi{-}2 distribution function
	
	Returns the argument, X, for which the area under the Khi{-}2 probability density function (integrated from 0 to X) is equal to P.
\end{itemize}

\section{Unit ustudind}
\label{ustudind}
\index[unit]{ustudind}
\subsection{Description}
Student t{-}test for independent samples. \subsection{Overview}
\begin{description}
	\item[\texttt{StudIndep}]
\end{description}
\subsection{Functions and Procedures}
\subsubsection{StudIndep}
\label{ustudind-StudIndep}
\index[proc]{StudIndep}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure StudIndep(N1, N2 : Integer; M1, M2, S1, S2 : Float; var T : Float; var DoF : Integer);}
	\end{flushleft}
	\item[\descriptiontitle{Description}]
	Student t{-}test for independent samples.
	
	Input parameters: N1, N2 = samples sizes; M1, M2 = samples means; S1, S2 = samples SD's (computed with StDev); Output parameters: T = Student's t; DoF = degrees of freedom.
	
\end{itemize}
\section{Unit ustdpair}
\label{ustdpair}
\index[unit]{ustdpair}
\subsection{Description}
Student t{-}test for paired samples. 
\subsection{Overview}
\begin{description}
	\item[\texttt{StudPaired}]
\end{description}
\subsection{Functions and Procedures}
\subsubsection{StudPaired}
\label{ustdpair-StudPaired}
\index[proc]{StudPaired}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure StudPaired(X, Y : TVector; Lb, Ub : Integer; var T : Float; var DoF : Integer);}
	\end{flushleft}
	\item[\descriptiontitle{Description}]
	Student t{-}test for paired samples.
	
	Input parameters: X, Y = samples; Lb, Ub = lower and upper bounds. Output parameters: T = Student's t; DoF = degrees of freedom.
\end{itemize}

\section{Unit uanova1}
\label{uanova1}
\index[unit]{uanova1}
\subsection{Description}
One{-}way analysis of variance. 
\subsection{Functions and Procedures}
\subsubsection{AnOVa1}
\label{uanova1-AnOVa1}
\index[proc]{AnOVa1}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure AnOVa1(Ns : Integer; N : TIntVector; M, S : TVector; var V{\_}f, V{\_}r, F : Float; var DoF{\_}f, DoF{\_}r : Integer);}
	\end{flushleft}
	\item[\descriptiontitle{Description}]
	Input parameters: Ns = number of samples; N = samples sizes; M = samples means; S = samples SD's (computed with StDev). Output parameters: V{\_}f, V{\_}r = variances (factorial, residual)L F = ratio Vf / Vr; DoF{\_}f, DoF{\_}r = degrees of freedom.
\end{itemize}
\section{Unit uanova2}
\label{uanova2}
\index[unit]{uanova2}
\subsection{Description}
Two{-}way analysis of variance 
\subsection{Functions and Procedures}
\subsubsection{AnOVa2}
\label{uanova2-AnOVa2}
\index[proc]{AnOVa2}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure AnOVa2(NA, NB, Nobs : Integer; M, S : TMatrix; V, F : TVector; DoF : TIntVector);}
	\end{flushleft}
	\item[\descriptiontitle{Description}]
	Input parameters : NA = number of modalities for factor A; NB = number of modalities for factor B; Nobs = number of observations for each sample; M = matrix of means (factor A as lines, factor B as columns); S = matrix of standard deviations. Output parameters: V = variances (factor A, factor B, interaction, residual); F = variance ratios (factor A, factor B, interaction); DoF = degrees of freedom (factor A, factor B, interaction, residual).
\end{itemize}
\section{Unit ubartlet}
\label{ubartlet}
\index[unit]{ubartlet}
\subsection{Description}
Bartlett's test (comparison of several variances) 
\subsection{Overview}
\begin{description}
	\item[\texttt{Bartlett}]
\end{description}
\subsection{Functions and Procedures}
\subsubsection{Bartlett}
\label{ubartlet-Bartlett}
\index[proc]{Bartlett}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure Bartlett(Ns : Integer; N : TIntVector; S : TVector; var Khi2 : Float; var DoF : Integer);}
	\end{flushleft}
	\item[\descriptiontitle{Description}]
	Input parameters: Ns = number of samples; N = samples sizes; S = samples SD's (computed with StDev). Output parameters: Khi2 = Bartlett's $\chi^2$; DoF = degrees of freedom.
\end{itemize}


\section{Unit ukhi2}
\label{ukhi2}
\index[unit]{ukhi2}
\subsection{Description}
$\chi^2$ test
\subsection{Functions and Procedures}
\subsubsection{Khi2{\_}Conform}
\label{ukhi2-Khi2_Conform}
\index[proc]{Khi2{\_}Conform}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure Khi2{\_}Conform(N{\_}cls : Integer; N{\_}estim : Integer; Obs : TIntVector; Calc : TVector; out Khi2 : Float; out DoF : Integer);}
	\end{flushleft}
	\item[\descriptiontitle{Description}]
	$\chi^2$ test for conformity. N{\_}cls is the number of classes; N{\_}estim the number of estimated parameters; Obs[1..N{\_}cls] and Calc[1..N{\_}cls] the observed and theoretical distributions. The statistic is returned in Khi2 and the number of d. o. f. in DoF.
\end{itemize}
\subsubsection{Khi2{\_}Indep}
\label{ukhi2-Khi2_Indep}
\index[proc]{Khi2{\_}Indep}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure Khi2{\_}Indep(N{\_}lin : Integer; N{\_}col : Integer; Obs : TIntMatrix; out Khi2 : Float; out DoF : Integer);}
	\end{flushleft}
	\item[\descriptiontitle{Description}]
	Khi{-}2 test for independence N{\_}lin and N{\_}col are the numbers of lines and columns Obs[1..N lin, 1..N col] is the matrix of observed distributions. The statistic is returned in G and the number of d. o. f. in DoF.
\end{itemize}

\section{Unit usnedeco}
\label{usnedeco}
\index[unit]{usnedeco}
\subsection{Description}
Snedecor's F{-}test (comparison of two variances). 
\subsection{Functions and Procedures}
\subsubsection{Snedecor}
\label{usnedeco-Snedecor}
\index[proc]{Snedecor}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure Snedecor(N1, N2 : Integer; S1, S2 : Float; var F : Float; var DoF1, DoF2 : Integer);}
	\end{flushleft}
	\par
	\item[\descriptiontitle{Description}]
	Snedecor's F{-}test (comparison of two variances).
	
	Input parameters: N1, N2 = samples sizes; S1, S2 = samples SD's (computed with StDev). Output parameters: F = Snedecor's F; DoF1, DoF2 = degrees of freedom.
\end{itemize}

\section{Unit uwoolf}
\label{uwoolf}
\index[unit]{uwoolf}
\subsection{Description}
Woolf test
\subsection{Functions and Procedures}
\subsubsection{Woolf{\_}Conform}
\label{uwoolf-Woolf_Conform}
\index[proc]{Woolf{\_}Conform}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure Woolf{\_}Conform(N{\_}cls : Integer; N{\_}estim : Integer; Obs : TIntVector; Calc : TVector; out G : Float; out DoF : Integer);}
	\end{flushleft}
	\item[\descriptiontitle{Description}]
	Woolf test for conformity. N{\_}cls is the number of classes; N{\_}estim is the number of estimated parameters; Obs[1..N{\_}cls] and Calc[1..N{\_}cls] are the observed and theoretical distributions. The statistic is returned in G and the number of d. o. f. in DoF.
\end{itemize}
\subsubsection{Woolf{\_}Indep}
\label{uwoolf-Woolf_Indep}
\index[proc]{Woolf{\_}Indep}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure Woolf{\_}Indep(N{\_}lin : Integer; N{\_}col : Integer; Obs : TIntMatrix; out G : Float; out DoF : Integer);}
	\end{flushleft}
	\item[\descriptiontitle{Description}]
	Woolf test for independence. N{\_}lin and N{\_}col are the numbers of lines and columns; Obs[1..N{\_}lin, 1..N{\_}col] is the matrix of observed distributions. The statistic is returned in G and the number of d. o. f. in DoF.
\end{itemize}
\section{Unit unonpar}
\label{unonpar}
\index[unit]{unonpar}
\subsection{Description}
Non{-}parametric tests
\subsection{Functions and Procedures}
\subsubsection{Mann{\_}Whitney}
\label{unonpar-Mann_Whitney}
\index[proc]{Mann{\_}Whitney}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure Mann{\_}Whitney(N1, N2 : Integer; X1, X2 : TVector; out U, Eps : Float);}
	\end{flushleft}
	\item[\descriptiontitle{Description}]
	Mann{-}Whitney test N1 and N2 are the sample sizes X1[1..N1] and X2[1..N2] are the two samples. The procedure returns Mann{-}Whitney's statistic in U and the associated normal variable in Eps.
\end{itemize}
\subsubsection{Wilcoxon}
\label{unonpar-Wilcoxon}
\index[proc]{Wilcoxon}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure Wilcoxon(X, Y : TVector; Lb, Ub : Integer; out Ndiff : Integer; out T, Eps : Float);}
	\end{flushleft}
	\item[\descriptiontitle{Description}]
	Wilcoxon test X[Lb..Ub] and Y[Lb..Ub] are the two samples. Output: the number of non{-}zero differences in Ndiff, Wilcoxon\'s statistic in T 
	and the associated normal variable in Eps.
\end{itemize}
\subsubsection{Kruskal{\_}Wallis}
\label{unonpar-Kruskal_Wallis}
\index[proc]{Kruskal{\_}Wallis}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure Kruskal{\_}Wallis(Ns : Integer; N : TIntVector; X : TMatrix; out H : Float; out DoF : Integer);}
	\end{flushleft}
	\item[\descriptiontitle{Description}]
	Kruskal{-}Wallis test Ns is the number of samples, N[1..Ns] is the vector of sizes and X the sample matrix (with the samples as columns). Output: Kruskal{-}Wallis statistic in H and the number of d. o. f. in DoF.
\end{itemize}


\section{Unit upca}
\label{upca}
\index[unit]{upca}
\subsection{Description}
Principal component analysis 
\subsection{Functions and Procedures}
\subsubsection{VecMean}
\label{upca-VecMean}
\index[proc]{VecMean}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure VecMean(X : TMatrix; Lb, Ub, Nvar : Integer; M : TVector);}
	\end{flushleft}
	\par
	\item[\descriptiontitle{Description}]
	Computes the mean vector (M) from matrix X.
	
	Input : X[Lb..Ub, 1..Nvar] = matrix of variables. Output : M[1..Nvar] = mean vector.
\end{itemize}
\subsubsection{VecSD}
\label{upca-VecSD}
\index[proc]{VecSD}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure VecSD(X : TMatrix; Lb, Ub, Nvar : Integer; M, S : TVector);}
	\end{flushleft}
	\item[\descriptiontitle{Description}]
	Computes the vector of standard deviations (S) from matrix X.
	
	Input : X, Lb, Ub, Nvar, M. Output : S[1..Nvar].
	
\end{itemize}
\subsubsection{MatVarCov}
\label{upca-MatVarCov}
\index[proc]{MatVarCov}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure MatVarCov(X : TMatrix; Lb, Ub, Nvar : Integer; M : TVector; V : TMatrix);}
	\end{flushleft}
	\item[\descriptiontitle{Description}]
	Computes the variance{-}covariance matrix (V) from matrix X.
	
	Input : X, Lb, Ub, Nvar, M Output : V[1..Nvar, 1..Nvar]
\end{itemize}
\subsubsection{MatCorrel}
\label{upca-MatCorrel}
\index[proc]{MatCorrel}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure MatCorrel(V : TMatrix; Nvar : Integer; R : TMatrix);}
	\end{flushleft}
	\item[\descriptiontitle{Description}]
	Computes the correlation matrix (R) from the variance{-}covariance matrix (V).
	
	Input : V, Nvar Output : R[1..Nvar, 1..Nvar]
\end{itemize}
\subsubsection{PCA}
\label{upca-PCA}
\index[proc]{PCA}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure PCA(R : TMatrix; Nvar : Integer; Lambda : TVector; C, Rc : TMatrix);}
	\end{flushleft}
	\item[\descriptiontitle{Description}]
	Performs a principal component analysis of the correlation matrix R.
	
	Input: R[1..Nvar, 1..Nvar] = Correlation matrix. 
	
	Output: Lambda[1..Nvar] = Eigenvalues of the correlation matrix (in descending order); C[1..Nvar, 1..Nvar] = Eigenvectors of the correlation matrix (stored as columns); Rc[1..Nvar, 1..Nvar] = Correlations between principal factors and variables (Rc[I,J] is the correlation coefficient between variable I and factor J). NB : This procedure destroys the original matrix R.
	
\end{itemize}
\subsubsection{ScaleVar}
\label{upca-ScaleVar}
\index[proc]{ScaleVar}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure ScaleVar(X : TMatrix; Lb, Ub, Nvar : Integer; M, S : TVector; Z : TMatrix);}
	\end{flushleft}
	\item[\descriptiontitle{Description}]
	Scales a set of variables by subtracting means and dividing by SD's.
	
	Input : X, Lb, Ub, Nvar, M, S Output : Z[Lb..Ub, 1..Nvar] = matrix of scaled variables.
	
\end{itemize}
\subsubsection{PrinFac}
\label{upca-PrinFac}
\index[proc]{PrinFac}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure PrinFac(Z : TMatrix; Lb, Ub, Nvar : Integer; C, F : TMatrix);}
	\end{flushleft}
	\item[\descriptiontitle{Description}]
	Computes principal factors. Input: Z[Lb..Ub, 1..Nvar] = matrix of scaled variables; C[1..Nvar, 1..Nvar] = matrix of eigenvectors from PCA. Output : F[Lb..Ub, 1..Nvar] = matrix of principal factors.
\end{itemize}

\section{Unit ucorrel}
\label{ucorrel}
\index[unit]{ucorrel}
\subsection{Description}
Correlation coefficient
\subsection{Functions and Procedures}
\subsubsection{Correl}
\label{ucorrel-Correl}
\index[proc]{Correl}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function Correl(X, Y : TVector; Lb, Ub : Integer) : Float;}
	\end{flushleft}
	\item[\descriptiontitle{Description}]
	Correlation coefficient between samples X and Y.
\end{itemize}
\chapter[Package lmOptimum]{Package lmOptimum: Algorithms of \\ Optimization }\label{package-lmOptimum}
\section{Description}
This package contains a collection of algorithm to minimize function of one or several variables. 

\noindent In the calls to all optimization procedures, function of one variable must be defined as 

\code{function MyFunc(X:float):float;} 

\noindent which corresponds to \hyperref[utypes-TFunc]{TFunc} type; initial minimum guess value usually must be supplied in X:float parameter.

\noindent Function of several variables must be defined as 

\code{function MyFunc(X:TVector):Float;}

\noindent which corresponds to \hyperref[utypes-TFuncNVar]{TFuncNVar} type; initial guess for minimum is supplied in X:TVector parameter.
\section{Unit uminbrak}
\label{uminbrak}
\index[unit]{uminbrak}
\subsection{Description}
Brackets a minimum of a function 
\subsection{Functions and Procedures}
\subsubsection{MinBrack}
\label{uminbrak-MinBrack}
\index[proc]{MinBrack}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure MinBrack(Func : TFunc; var A, B, C: Float; out Fa, Fb, Fc : Float);}
	\end{flushleft}
	\item[\descriptiontitle{Description}]
	Given two points (A, B) this procedure finds a triplet (A, B, C) such that: (i) A {$<$} B {$<$} C (ii) A, B, C are within the golden ratio (iii) $\textrm{Func}(B) < \textrm{Func}(A)$ and $\textrm{Func}(B) < \textrm{Func}(C)$. The corresponding function values are returned in \code{Fa}, \code{Fb}, \code{Fc}.
\end{itemize}
\subsubsection{SetBrakConstrain}
\label{uminbrak-SetBrakConstrain}
\index[proc]{SetBrakConstrain}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure SetBrakConstrain(L, R: Float);}
	\end{flushleft}
	\item[\descriptiontitle{Description}]
	Set initial constrain, such that function minimum will be searched only within [L,R] interval. 	
\end{itemize}
\section{Unit ugoldsrc}
\label{ugoldsrc}
\index[unit]{ugoldsrc}
\subsection{Description}
Minimization of a function of one variable by Golden Search method.
\subsection{Functions and Procedures}
\subsubsection{GoldSearch}
\label{ugoldsrc-GoldSearch}
\index[proc]{GoldSearch}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure GoldSearch(Func : TFunc; A, B : Float; MaxIter : Integer; Tol : Float; var Xmin, Ymin : Float);}
	\end{flushleft}
	\item[\descriptiontitle{Description}]
	Performs a golden search for the minimum of function Func.
	
	Input parameters: Func = objective function; A, B = two points near the minimum; MaxIter = maximum number of iterations; Tol = required precision (should not be less than the square root of the machine precision).
	
	Output parameters: Xmin, Ymin = coordinates of minimum.
	
	Possible results : OptOk, OptNonConv.
	
\end{itemize}
\section{Unit usimplex}
\label{usimplex}
\index[unit]{usimplex}
\subsection{Description}
Function minimization by the simplex method 
\subsection{Functions and Procedures}
\subsubsection{SaveSimplex}
\label{usimplex-SaveSimplex}
\index[proc]{SaveSimplex}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure SaveSimplex(FileName : string);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Opens a file to save the Simplex iterations.
	
\end{itemize}
\subsubsection{Simplex}
\label{usimplex-Simplex}
\index[proc]{Simplex}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure Simplex(Func : TFuncNVar; X : TVector; Lb, Ub : Integer; MaxIter : Integer; Tol : Float; var F{\_}min : Float);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Minimization of a function of several variables by the simplex method of Nelder and Mead. \\
	Input parameters: Func = objective function; X = initial (guess) minimum coordinates; Lbound, Ubound = indices of first and last variables in X vector; MaxIter = maximum number of iterations; Tol = required precision.
	
	Output parameters: X = refined minimum coordinates; F{\_}min = function value at minimum.
	
	The function MathErr returns one of the following codes:
	
	OptOk = no error; OptNonConv = non{-}convergence.
	
\end{itemize}

\section{Unit ubfgs}
\label{ubfgs}
\index[unit]{ubfgs}
\subsection{Description}
Minimization of a function of several variables by the Broyden{-}Fletcher{-}Goldfarb{-}Shanno (BFGS) method 
\subsection{Functions and Procedures}
\subsubsection{SaveBFGS}
\label{ubfgs-SaveBFGS}
\index[proc]{SaveBFGS}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure SaveBFGS(FileName : string);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Save BFGS iterations in a file.
\end{itemize}
\subsubsection{BFGS}
\label{ubfgs-BFGS}
\index[proc]{BFGS}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure BFGS(Func : TFuncNVar; Gradient : TGradient; X : TVector; Lb, Ub : Integer; MaxIter : Integer; Tol : Float; var F{\_}min : Float; G : TVector; H{\_}inv : TMatrix);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Minimization of a function of several variables by the Broyden{-}Fletcher{-}Goldfarb{-}Shanno method.
	
	Input parameters: Func:\hyperref[utypes-TFuncNVar]{TFuncNVar} = objective function; Gradient:\hyperref[utypes-TGradient]{TGradient} = procedure to compute gradient; X = initial guess minimum coordinates; Lb, Ub = indices of first and last variables in X; MaxIter = maximum number of iterations; Tol = required precision.
	
	Output parameters: X = refined minimum coordinates; F{\_}min = function value at minimum; G = gradient vector; H{\_}inv = inverse hessian matrix.
	
	Possible results: OptOk, OptNonConv.
	
\end{itemize}


\section{Unit unewton}
\label{unewton}
\index[unit]{unewton}
\subsection{Description}
Minimization of a function of several variables by the Newton{-}Raphson method 
\subsection{Overview}
\begin{description}
	\item[\texttt{SaveNewton}]
	\item[\texttt{Newton}]
\end{description}
\subsection{Functions and Procedures}
\subsubsection{SaveNewton}
\label{unewton-SaveNewton}
\index[proc]{SaveNewton}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure SaveNewton(FileName : string);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Save Newton{-}Raphson iterations in a file
	
\end{itemize}
\subsubsection{Newton}
\label{unewton-Newton}
\index[proc]{Newton}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure Newton(Func : TFuncNVar; HessGrad : THessGrad; X : TVector; Lb, Ub : Integer; MaxIter : Integer; Tol : Float; var F{\_}min : Float; G : TVector; H{\_}inv : TMatrix; var Det : Float);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Minimization of a function of several variables by the Newton{-}Raphson method.
	
	Input parameters: Func = objective function; HessGrad = procedure to compute hessian and gradient; X = initial guess minimum coordinates; Lb, Ub = indices of first and last variables in X; MaxIter = maximum number of iterations; Tol = required precision.
	
	Output parameters: X = refined minimum coordinates; F{\_}min = function value at minimum; G = gradient vector; H{\_}inv = inverse hessian matrix; Det = determinant of hessian.
	
	Possible results: OptOk = no error OptNonConv = non{-}convergence OptSing = singular hessian matrix.
	
\end{itemize}
\section{Unit umarq}
\label{umarq}
\index[unit]{umarq}
\subsection{Description}
Minimization of a function of several variables by Marquardt's method 
\subsection{Overview}
\begin{description}
	\item[\texttt{SaveMarquardt}]
	\item[\texttt{Marquardt}]
\end{description}
\subsection{Functions and Procedures}
\subsubsection{SaveMarquardt}
\label{umarq-SaveMarquardt}
\index[proc]{SaveMarquardt}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure SaveMarquardt(FileName : string);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Save Marquardt iterations in a file
	
\end{itemize}
\subsubsection{Marquardt}
\label{umarq-Marquardt}
\index[proc]{Marquardt}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure Marquardt(Func : TFuncNVar; HessGrad : THessGrad; X : TVector; Lb, Ub : Integer; MaxIter : Integer; Tol : Float; out F{\_}min : Float; G : TVector; H{\_}inv : TMatrix; out Det : Float);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Minimization of a function of several variables by Marquardt's method.
	
	Input parameters. : Func = objective function; HessGrad = procedure to compute hessian and gradient; X = initial guess minimum coordinates; Lb, Ub = indices of first and last variables in X; MaxIter = maximum number of iterations; Tol = required precision.
	
	Output parameters: X = refined minimum coordinates; F{\_}min = function value at minimum; G = gradient vector; H{\_}inv = inverse hessian matrix; Det = determinant of hessian.
	
	Possible results: OptOk = no error; OptNonConv = non{-}convergence; OptSing = singular hessian matrix; OptBigLambda = too high Marquardt parameter Lambda.
	
\end{itemize}
\section{Unit ulinmin}
\label{ulinmin}
\index[unit]{ulinmin}
\subsection{Description}
Minimization of a function of several variables along a line.
\subsection{Overview}
\begin{description}
	\item[\texttt{LinMin}]
\end{description}
\subsection{Functions and Procedures}
\subsubsection{LinMin}
\label{ulinmin-LinMin}
\index[proc]{LinMin}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure LinMin(Func : TFuncNVar; X, DeltaX : TVector; Lb, Ub : Integer; var R : Float; MaxIter : Integer; Tol : Float; var F{\_}min : Float);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Minimizes function Func from point X in the direction specified by DeltaX.
	
	Input parameters: Func:\hyperref[utypes-TFuncNVar]{TFuncNVar} = objective function; X = initial minimum coordinates; DeltaX = direction in which minimum is searched; Lb, Ub = indices of first and last variables; R = initial step, in fraction of $|DeltaX|$; MaxIter = maximum number of iterations; Tol = required precision.
	
	Output parameters: X = refined minimum coordinates; R = step corresponding to the minimum; F{\_}min = function value at minimum.
	
	Possible results: OptOk, OptNonConv.
	
\end{itemize}

\section{Unit ugenalg}
\label{ugenalg}
\index[unit]{ugenalg}
\subsection{Description}
Optimization by Genetic Algorithm\\ 
Ref.: E. Perrin, A. Mandrille, M. Oumoun, C. Fonteix {\&} I. Marc Optimisation globale par strategie d'evolution Technique utilisant la genetique des individus diploides Recherche operationnelle / Operations Research 1997, 31, 161{-}201.\\
Thanks to Magali Camut for her contribution.
\subsection{Functions and Procedures}
\subsubsection{InitGAParams}
\label{ugenalg-InitGAParams}
\index[proc]{InitGAParams}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure InitGAParams(NP, NG : Integer; SR, MR, HR : Float);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Initialize Genetic Algorithm parameters.
	
	NP: Population size; NG: Max number of generations; SR: Survival rate; MR: Mutation rate; HR: Proportion of homozygotes.
	
\end{itemize}
\subsubsection{GA{\_}CreateLogFile}
\label{ugenalg-GA_CreateLogFile}
\index[proc]{GA{\_}CreateLogFile}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure GA{\_}CreateLogFile(LogFileName : String);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Initialize log file.
	
\end{itemize}
\subsubsection{GenAlg}
\label{ugenalg-GenAlg}
\index[proc]{GenAlg}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure GenAlg(Func : TFuncNVar; X, Xmin, Xmax : TVector; Lb, Ub : Integer; var F{\_}min : Float);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Minimization of a function of several variables by genetic algorithm.
	
	Input parameters: Func = objective function to be minimized; X = initial minimum coordinates; Xmin = minimum value of X; Xmax = maximum value of X; Lb, Ub = array bounds.
	
	Output parameters: X = refined minimum coordinates; F{\_}min = function value at minimum.
	
\end{itemize}

\section{Unit umcmc}
\label{umcmc}
\index[unit]{umcmc}
\subsection{Description}
Simulation by Markov Chain Monte Carlo (MCMC) with the Metropolis{-}Hastings algorithm.

This algorithm simulates the probability density function (pdf) of a vector X. The pdf P(X) is written as:
$$
P(X) = C \euler^{\frac{-F(X)}{T}}
$$
Simulating P by the Metropolis-Hastings algorithm is equivalent to minimizing F by simulated annealing at the constant temperature T. The constant C is not used in the simulation.

The series of random vectors generated during the annealing step constitutes a Markov chain which tends towards the pdf to be simulated.

It is possible to run several cycles of the algorithm. The variance{-}covariance matrix of the simulated distribution is re{-}evaluated at the end of each cycle and used for the next cycle.
\subsection{Functions and Procedures}
\subsubsection{InitMHParams}
\label{umcmc-InitMHParams}
\index[proc]{InitMHParams}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure InitMHParams(NCycles, MaxSim, SavedSim : Integer);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Initializes Metropolis{-}Hastings parameters.
	
\end{itemize}
\subsubsection{GetMHParams}
\label{umcmc-GetMHParams}
\index[proc]{GetMHParams}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure GetMHParams(out NCycles, MaxSim, SavedSim : Integer);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Returns Metropolis{-}Hastings parameters.
	
\end{itemize}
\subsubsection{Hastings}
\label{umcmc-Hastings}
\index[proc]{Hastings}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure Hastings(Func : TFuncNVar; T : Float; X : TVector; V : TMatrix; Lb, Ub : Integer; Xmat : TMatrix; X{\_}min : TVector; var F{\_}min : Float);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Simulation of a probability density function by the Metropolis{-}Hastings algorithm.
	
	Input parameters: Func = Function such that the pdf is 
	$$
	P(X) = C \euler^\frac{-\textrm{Func}(X)}{T}
	$$ 
	T = Temperature; X = Initial mean vector; V = Initial variance{-}covariance matrix; Lb, Ub = Indices of first and last variables.
	
	Output parameters: Xmat = Matrix of simulated vectors, stored row{-}wise, i.e. Xmat[1..MH{\_}SavedSim, Lb..Ub]; X = Mean of distribution; V = Variance{-}covariance matrix of distribution; X{\_}min = Coordinates of minimum of F(X) (mode of the distribution); F{\_}min = Value of F(X) at minimum.
	
	Possible results: MatOk: No error; MatNotPD: The variance{-}covariance matrix is not positive definite.
\end{itemize}
\section{Unit usimann}
\label{usimann}
\index[unit]{usimann}
\subsection{Description}
Optimization by Simulated Annealing\\ 
Adapted from Fortran program SIMANN by Bill Goffe:\\ 
\href{http://www.netlib.org/opt/simann.f}{http://www.netlib.org/opt/simann.f} 
\subsection{Functions and Procedures}
\subsubsection{InitSAParams}
\label{usimann-InitSAParams}
\index[proc]{InitSAParams}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure InitSAParams(NT, NS, NCycles : Integer; RT : Float);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Initialize simulated annealing parameters
	
	NT: Number of loops at constant temperature; NS: Number of loops before step adjustment; NCycles: Number of cycles; RT: Temperature reduction factor.
	
\end{itemize}
\subsubsection{SA{\_}CreateLogFile}
\label{usimann-SA_CreateLogFile}
\index[proc]{SA{\_}CreateLogFile}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure SA{\_}CreateLogFile(FileName : String);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Initialize log file
	
\end{itemize}
\subsubsection{SimAnn}
\label{usimann-SimAnn}
\index[proc]{SimAnn}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure SimAnn(Func : TFuncNVar; X, Xmin, Xmax : TVector; Lb, Ub : Integer; var F{\_}min : Float);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Minimization of a function of several variables by simulated annealing.
	
	Input parameters: Func:\hyperref[utypes-TFuncNVar]{TFuncNVar} = objective function to be minimized; X = initial guess minimum coordinates; Xmin = minimum value of X; Xmax = maximum value of X; Lb, Ub = indices of first and last variables.
	
	Output parameter: X = refined minimum coordinates; F{\_}min = function value at minimum.
	
\end{itemize}

\section{Unit ueval}
\label{ueval}
\index[unit]{ueval}
\subsection{Description}
Simple Expression Evaluator, Version: 1.1.
Author : Aleksandar Ruzicic (admin@krcko.net) File: fbeval.bas
BIG thanks goes to Jack W. Crenshaw for his "LET'S BUILD A COMPILER!" text series\\ (\href{http://compilers.iecc.com/crenshaw/}{http://compilers.iecc.com/crenshaw/})

Pascal version by Jean Debord for use with DMath, modified by V. Nesterov for LMath.

Following functions and operators are defined:\\[6pt] 
Operators: \code{+}, \code{-}, \code{*}, \code{/}, \code{\textbackslash} (integer division), \code{\%} (modulus), \code{\^} and \code{**} (exponentiation).\\[6pt]
Bitwise: \code{>} shift right, \code{<} shift left, \code{\&} and, \code{|} or, \code{\$} xor, \code{!} not, \code{@} imp, \code{=} EQV.\\[6pt]
Precedence: \code{!, \&, |, \$, =, @, \^, * and /, \textbackslash, \%, < and >, + and -}.\\
Parenthesis may be used to override the precedence.\\[6pt]
In DMath library, only 26 variables could be defined and only first letter of a variable name was meaningful; number of functions was limited to 100. In LMath beginning from version 0.3, number of functions and variables is not limited and identifiers can have unlimited length.

Operator \code{**} is added to \code{\^} for exponentiation. It may be necessary in some environments where \code{\^} may have a special meaning.

\subsection{Functions and Procedures}
\subsubsection{InitEval}
\label{ueval-InitEval}
\index[proc]{InitEval}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function InitEval : Integer;}
	\end{flushleft}
	\item[\descriptiontitle{Description}]
Initializes expression evaluation system. Must be called before first call to \code{eval}. Returns number of defined functions. 
\end{itemize}
\subsubsection{SetVariable}
\label{ueval-SetVariable}
\index[proc]{SetVariable} \lmath{-6pt}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure SetVariable(VarName : String; Value : Float);}
	\end{flushleft}
	\item[\descriptiontitle{Description}]
Defines variable \code{VarName }and initializes it with \code{Value}. Change in LMath: \code{VarName} is a string, may have arbitrary length and unlimited number of variables is possible. 
\end{itemize}
\subsubsection{SetFunction}
\label{ueval-SetFunction}
\index[proc]{SetFunction}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure SetFunction(FuncName : String; Wrapper : TWrapper);}
	\end{flushleft}
	\item[\descriptiontitle{Description}]
Defines a new function. \code{FuncName} is its name; \code{wrapper} is a function of \hyperref[utypes-TWrapper]{TWrapper} which will be actually called. Paramters of \code{FuncName} in the expression are copied into the vector of parameters for \code{Wrapper}. 
\end{itemize}
\subsubsection{Eval}
\label{ueval-Eval}
\index[proc]{Eval}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function Eval(ExpressionString : String) : Float;}
	\end{flushleft}
	\item[\descriptiontitle{Description}]
Actually evaluates expression in \code{ExpressionString} and returns result.
\end{itemize}
\subsubsection{DoneEval} \lmath{-6pt}
\label{ueval-DoneEval}
\index[proc]{InitEval}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{procedure DoneEval;}
	\end{flushleft}
	\item[\descriptiontitle{Description}]
	Removes functions and variables. Call it after the end of session to free memory.
\end{itemize}
\subsection{Variables}
\subsubsection{ParsingError}\lmath{-24pt}
\label{ueval-parsingerror}\index[var]{ParsingError}
\begin{itemize}
\item[\declarationitem{Declaration}\hfill]
\begin{flushleft}
	\code{ParsingError: boolean;}
\end{flushleft}
\item[\descriptiontitle{Description}] Returns true if an error of expression parsing occurred, which means invalid expression. In LMath the variable was made public.
\end{itemize}

\section{Unit ulinminq}
\label{ulinminq}
\index[unit]{ulinminq}
\subsection{Description}
Minimization of a sum of squared functions along a line (Used internally by equation solvers) 
\subsection{Functions and Procedures}
\subsubsection{LinMinEq}
\label{ulinminq-LinMinEq}
\index[proc]{LinMinEq}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure LinMinEq(Equations : TEquations; X, DeltaX, F : TVector; Lb, Ub : Integer; R : Float; MaxIter : Integer; Tol : Float);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Minimizes a sum of squared functions from point X in the direction specified by DeltaX, using golden search as the minimization algo.
	
	Input parameters: SysFunc = system of functions; X = starting point; DeltaX = search direction; Lb, Ub = bounds of X; R = initial step, in fraction of $|DeltaX|$; MaxIter = maximum number of iterations; Tol = required precision.
	
	Output parameters: X = refined minimum coordinates; F = function values at minimum; R = step corresponding to the minimum.
	
	Possible results: OptOk = no error; OptNonConv = non{-}convergence.
\end{itemize}

\section[unit uCobyla]{Unit uCobyla. Constrained optimization by linear approximation}\label{sec:unit-ucobyla}
\subsection{Description}
This unit defines a procedure implementing the Constrained optimization by linear approximation (COBYLA) algorithm, initially developed by Michael J. D. Powell and adapted from Fortran 77 for LMath by V. Nesterov. Source code in Fortran can be found \href{http://mat.uc.pt/~zhang/software.html#cobyla}{here}.  COBYLA is an optimization method for constrained problems which does not require knowing a derivative of the objective function. The procedure minimizes an objective function F(X) subject to M inequality constraints on X, where X is a vector of variables that has N components. Constrain expressions must be nonnegative. The algorithm employs linear approximations to the objective and constraint functions, the approximations being formed by linear interpolation at N+1 points in the space of the variables.
These interpolation points are regarded as vertices of a simplex. The parameter RHO controls the size of the simplex and it is reduced automatically from RHOBEG to RHOEND. For each RHO the procedure tries to achieve a good vector of variables for the current size, and then RHO is reduced until the value RHOEND is reached. Therefore RHOBEG and RHOEND should be set to reasonable initial values and the required accuracy in the variables respectively, but this accuracy should be viewed as a subject for experimentation because it is not guaranteed.
\subsection{Procedures and functions}
\subsubsection{COBYLA}
\label{cobyla}\index[proc]{cobyla}
\begin{itemize}
	\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		procedure COBYLA(N: integer; M: integer; X: TVector; \\ 
		\hspace{12pt}out F: float; out MaxCV: float; RHOBEG: float; RHOEND: float;\\
		\hspace{12pt} var MaxFun: integer; CalcFC: TCobylaObjectProc);
	\end{flushleft}
	\item[\descriptiontitle{Description}\hfill]
	\begin{description}
	\item{\textbf{N: integer}} Input. Number of variables to optimize, residing in \code{X[N]} array.
	\item{\textbf{M: integer}} Input. Number of inequality constrains.
	\item{\textbf{X: TVector}} Array of variables to be optimized. Guess values on input, optimal values on output.
	\item{\textbf{out F: float}} Output. Objective function value upon minimization.
	\item{\textbf{out MaxCV: float}} Output. Maximal constraint violation after optimization.
	\item{\textbf{RHOBEG: float}} Input. Initial size of simplex. Must be set by user. It is a subject of experimentation and depends on the size of the parameters. 
	\item{\textbf{RHOEND: float}} Input. End size of simplex: desired precision of objective function and constrain satisfaction.
	\item{\textbf{var MaxFun: integer}} On input: Limit on the number of calls of CALCFC user-supplied function. On output: number of actual calls CalcFC: TCobylaObjectProc.
	\item{\textbf{CalcFC: TCobylaObjectProc}} Objective function, type \hyperref[utypes_TCobylaObjectProc]{TCobylaObjectProc}. The function receives vector of variables X as input and calculates the value of objective function as well as values of constraint expressions. After the optimizaion constraint expressions must be non-negative, but, importantly, these constraints can be violated during the execution of the procedure.
	\end{description}
\end{itemize}

\section{unit uTrsTlp}\label{sec:unit-utrstlp}
\subsection{Description}
Unit uTrsTlp impplements linear optimization procedure uTrsTlp initially written by Michael J. D. Powell in Fortran 77 and adapted for LMath by V. Nesterov. This procedure is used by COBYLA algorithm, implemented in uCOBYLA unit.

 This procedure calculates an N-component vector DX by applying the
following two stages. In the first stage DX is set to the shortest
vector that minimizes the greatest violation of the constraints
$$A[1,K]\cdot DX[1]+A[2,K]\cdot DX[2]+\dots+A[N,K]\cdot DX[N] \geq [K], K = 2,3,...,M,$$
subject to the Euclidean length of DX being at most RHO. If its length is
strictly less than RHO, then we use the resultant freedom in DX to
minimize the objective function
$$-A[1,M+1] \cdot DX[1]-A[2,M+1]\cdot DX[2]-\dots-A[N,M+1]\cdot DX[N]$$
subject to no increase in any greatest constraint violation. This
notation allows the gradient of the objective function to be regarded as
the gradient of a constraint. Therefore the two stages are distinguished
by $MCON = M$ and $MCON > M$ respectively. It is possible that a
degeneracy may prevent DX from attaining the target length RHO. Then the
value $IFULL = 0$ would be set, but usually $IFULL = 1$ on return.

In general NACT is the number of constraints in the active set and
$$IACT[1],\dots,IACT[NACT]$$ are their indices, while the remainder of IACT
contains a permutation of the remaining constraint indices. Further, Z is
an orthogonal matrix whose first NACT columns can be regarded as the
result of Gram-Schmidt applied to the active constraint gradients. For
$J = 1,2,...,NACT$, the number ZDOTA[J] is the scalar product of the J-th
column of Z with the gradient of the J-th active constraint. DX is the
current vector of variables and here the residuals of the active
constraints should be zero. Further, the active constraints have
nonnegative Lagrange mulpliers that are held at the beginning of
VMUltc. The remainder of this vector holds the residuals of the inactive
constraints at DX, the ordering of the components of vmultc being in
agreement with the permutation of the indices of the constraints that is
in IACT. All these residuals are nonnegative, which is achieved by the
shift RESMAX that makes the lest residual zero.

\subsection{Procedure}
\subsubsection{TrsTlp}
\label{utrstlp:trstlp}\index[proc]{TrsTlp}
\begin{itemize}
	\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
procedure TrsTlp(N, M : integer; A : TMatrix; B : TVector; RHO : float; DX : TVector; out IFULL : integer);
	\end{flushleft}
\end{itemize}

\section[Unit uLinSimplex]{Unit uLinSimplex. Linear Programming}
\subsection{Description}
Simplex method for linear programming.  
Adapted from Fortran 90, \textit{Numerical Recipes.}
Detailed description of principle and input and output parameters may be found in the 
\href{https://websites.pmc.ucsc.edu/~fnimmo/eart290c_17/NumericalRecipesinF77.pdf}{``Numeric recipes in Fortran 77''}, pages 423-435.

Briefly, task of the linear programming is to maximize objective function
\begin{equation}\label{eq:linprogobjective}
z=a_1x_1+a_2x_2+\dots+a_Nx_N
\end{equation}
with the primary constrains $$x_1 \geq 0,\cdots,x_N \geq 0$$
and $M = m1+m2+m3$ secondary constrains in form:
\begin{align}
a_{i1}x_1+a_{i2}x_2+\dots+a_{iN}x_N \leq b_i & \quad (b_i \geq 0), &i=1,\dots,m_1 \label{eq:linprogm1}\\
a_{j1}x_1+a_{j2}x_2+\dots+a_{jN}x_N \geq b_j & \quad (b_j \geq 0), &j=m_1+1,\dots,m_1+m_2 \label{eq:linprogm2}\\
a_{k1}x_1+a_{k2}x_2+\dots+a_{kN}x_N = b_k & \quad (b_k \geq 0), &k=m1+m2+1,\dots,m_1+m_2+m_3 \label{eq:linprogm3}
\end{align}
$a_{ji}$ coefficients can be positive, negative, or zero.
\subsection{Functions and procedures}
\subsubsection{LinProgSolve}
\label{linprog:LinProgSolve}\index[proc]{LinProgSolve}
\begin{itemize}
	\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
procedure LinProgSolve(var A : TMatrix; N, M1, M2, M3 : integer;\\
out iCase: integer; out FuncVal : float; out SolVector :TVector);
	\end{flushleft}
	\item[\descriptiontitle{Description}\hfill]
	LinProgSolve is a convenience wrapper around main procedure LinSimplex. Here A is a matrix containing tableau which describes the problem to be solved. It must have dimentions A[M+2,N+1]. 
	
	In the first line, A[1,1] = 0, A[1,2] to A[1,N+1] contain  coefficients for objective function, $a_1$ to $a_N$.\\
	Lines A[2]..A[M+1] contain coefficients for constraints, in the order m1, m2, m3. That is:
	
	"$\leq$" constraints corresponding to Equation \ref{eq:linprogm1} are in A[2] to A[m1+1];\\
	"$\geq$" constraints (Equation \ref{eq:linprogm2}) in A[m1+2] to A[m1+m2+1];\\
	"$=$" constraints (Equation \ref{eq:linprogm3})    in A[m1+m2+2] to A[M+1].
	
	First column A[2,1] to A[M+1] is occupied by free members ($b_i,b_j$ and $b_k$ in Equations \ref{eq:linprogm1} to \ref{eq:linprogm3}). Cells A[2,2] to A[M+1,N+1] contain coefficients of constrains, $a_{i1}$ to $a_{i_N}, i=1,\dots,M$.

	Line A[M+2] is used internally for auxiliary function. 
	
	N is number of coefficients in the objective function z (\ref{eq:linprogobjective}), M1, M2 and M3 are number of constrains in form \ref{eq:linprogm1}, \ref{eq:linprogm2}, and \ref{eq:linprogm3}, correspondingly. 
	
	On output, iCase is a flag of an outcome of the calculation: icase = 0 means that finite solution was found; icase = 1: objective function is unbounded;	icase = -1: no solution exists (constrains are internally contradictory). FuncVal is the value of the objective function after optimization, and SolVector contains the solution vector, $X_1$ in SolVector[1] etc.
\end{itemize}
\subsubsection{LinSimplex}
\label{ulinsimplex:linsimplex}\index[proc]{LinSimplex}
\begin{itemize}
	\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
	procedure LinSimplex(var  A: TMatrix; N, M1, M2, M3 : integer; \\ \hspace{12pt}out icase : integer; out izrov, iposv : TIntVector);
	\end{flushleft}
	\item[\descriptiontitle{Description}\hfill]
	In most cases there is no need to call \code{LinSimplex} directly. rather use \code{LinProgSolve}. 
	
	On input, parameters A, N, M1, M2, and M3 have the same meaning as in \code{LinProgSolve}. But, importantly, for \textbf\code{LinProgSolve, {sign of coefficients in constrain equations must be changed!}} 
	
	Output: \code{A} is revized Tableu;  \code{A[1,1]} is objective function value. iposv and izrov are arrays indexing revized A. \code{High(iposv) = M}, \code{High(izrov) = N} where $ M = M1 + M2 + M3$.
	\code{iposv[j]} ($j \in [1..M]$) contains index $i$ of original variable $x[i]$, represented now by row $j+1$ in A. If $iposv[j] > N$, then row \code{A[j+1]} represents a slack variable.
	First row in A is row of objective function.
	
	izrov[k], $k \in [1..N]$, contains index i of a variable x[i] represented by column 1 to I.
	All these X are "0" in the solution, if $izrov[k] > N$, it represents a slack variable.
\end{itemize}


\chapter[Package lmNonLinEq]{Package lmNonLinEq: Units for Finding Roots of Non-Linear Equations}\label{package-lmNonLinEq}
\section{Unit ubisect}
\label{ubisect}
\index[unit]{ubisect}
\subsection{Description}
Bisection method for nonlinear equation. Equation may be defined either as \hyperref[utypes-TFunc]{TFunc} \code{(function Func(X : Float) : Float)}\ or as \hyperref[utypes-TParamFunc]{TParamFunc} \code{(function Func(X : Float; Params:Pointer) : Float)}\ where Params may be poiter to any structure used by the target function.  
\subsection{Functions and Procedures}
\subsubsection{RootBrack}
\label{ubisect-RootBrack}
\index[proc]{RootBrack}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure RootBrack(Func : TFunc; var X, Y, FX, FY : Float); overload;\\
			procedure RootBrack(Func : TParamFunc; Params:Pointer; var X, Y, FX, FY : Float); overload;}
	\end{flushleft}
	\item[\descriptiontitle{Description}]
	Expands the interval [X,Y] until it contains a root of Func, i. e. Func(X) and Func(Y) have opposite signs. The corresponding function values are returned in FX and FY;
\end{itemize}
\subsubsection{Bisect}
\label{ubisect-Bisect}
\index[proc]{Bisect}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure Bisect(Func : TFunc; var X, Y : Float; MaxIter : Integer; Tol : Float; out F : Float); overload;\\
			procedure Bisect(Func : TParamFunc; Params: Pointer; var X, Y : Float; MaxIter : Integer; Tol : Float; out F : Float); overload;}
	\end{flushleft}
	\item[\descriptiontitle{Description}]
	\code{Func} is a target function, \code{TFunc} or \code{TParamFunc}; the maximum number of iterations \code{MaxIter}; Initial values X; Y;  the tolerance \code{Tol} with which the root must be located.
\end{itemize}
\section{Unit ubroyden}
\label{ubroyden}
\index[unit]{ubroyden}
\subsection{Description}
Broyden method for system of nonlinear equations 
\subsection{Functions and Procedures}
\subsubsection{Broyden}
\label{ubroyden-Broyden}
\index[proc]{Broyden}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure Broyden(Equations : TEquations; X, F : TVector; Lb, Ub : Integer; MaxIter : Integer; Tol : Float);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Solves a system of nonlinear equations by Broyden's method.
	
	Input parameters: Equations = subroutine to compute equations; X = initial guess values for roots; Lb, Ub = bounds of X; MaxIter = maximum number of iterations; Tol = required precision.
	
	Output parameters: X = refined roots; F = function values.
	
	Possible results: OptOk = no error; OptNonConv = non{-}convergence.
\end{itemize}
\section{Unit unewteq}
\label{unewteq}
\index[unit]{unewteq}
\subsection{Description}
Newton{-}Raphson solver for nonlinear equation.
\subsection{Functions and Procedures}
\subsubsection{NewtEq}
\label{unewteq-NewtEq}
\index[proc]{NewtEq}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure NewtEq (Func, Deriv : TFunc; var X : Float; MaxIter : Integer; Tol : Float; var F : Float);}
	\end{flushleft}
	\item[\descriptiontitle{Description}]
	Solves a nonlinear equation by Newton's method.
	
	Input parameters: Func = function to be solved; Deriv = derivative; X = initial root; MaxIter = maximum number of iterations; Tol = required precision.
	
	Output parameters: X = refined root; F = function value.
	
	Possible results: OptOk = no error; OptNonConv = non{-}convergence; OptSing = singularity (null derivative).
\end{itemize}
\section{Unit unewteqs}
\label{unewteqs}
\index[unit]{unewteqs}
\subsection{Description}
Newton{-}Raphson solver for system of nonlinear equations. 
\subsection{Functions and Procedures}
\subsubsection{NewtEqs}
\label{unewteqs-NewtEqs}
\index[proc]{NewtEqs}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure NewtEqs(Equations: TEquations; Jacobian : TJacobian; X, F : TVector; Lb, Ub : Integer; MaxIter : Integer; Tol : Float);}
	\end{flushleft}
	\item[\descriptiontitle{Description}]
	Solves a system of nonlinear equations by Newton's method.
	
	Input parameters: Equations = subroutine to compute equations Jacobian = subroutine to compute Jacobian X = initial root MaxIter = maximum number of iterations Tol = required precision
	
	Output parameters: X = refined root; F = function values.
	
	Possible results: OptOk = no error; OptNonConv = non{-}convergence; OptSing = singular jacobian matrix.
	
\end{itemize}
\section{Unit usecant}
\label{usecant}
\index[unit]{usecant}
\subsection{Description}
Secant method for nonlinear equation.
\subsection{Functions and Procedures}
\subsubsection{Secant}
\label{usecant-Secant}
\index[proc]{Secant}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure Secant (Func : TFunc; var X, Y : Float; MaxIter : Integer; Tol : Float; out F : Float);}
	\end{flushleft}
	\item[\descriptiontitle{Description}]
	function Func(X : Float) : Float; the maximum number of iterations MaxIter; Initial values of X and Y; the maximum number of iterations MaxIter; the tolerance Tol with which the root must be located.
	
\end{itemize}
\chapter[Package lmRegression]{Package lmRegression: Linear and Non-Linear Regression and Curve Fitting}\label{package-lmRegression}
Procedures for non-linear regression and data fitting with some general models are collected in this package. Units uLinFit, uMultFit and uSVDfit include procedures for linear and multple linear regression; unit unlfit contains algorithms for general non-linear regression; other units contain a library of common regression models. In addition, unit uSpline provides spline interpolation of experimental data and procedures for exploration of the spline function. Ufft unit, which contains the routine for fast Fouier transform, is also included in this package. 

\section{Unit ulinfit}
\label{ulinfit}
\index[unit]{ulinfit}
\subsection{Description}
Linear regression:
$$Y = B_0 + B_1X$$ 
\subsection{Functions and Procedures}
\subsubsection{LinFit}
\label{ulinfit-LinFit}
\index[proc]{LinFit}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure LinFit(X, Y : TVector; Lb, Ub : Integer; B : TVector; V : TMatrix);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Unweighted linear regression. Input parameters: X, Y = point coordinates; Lb, Ub = array bounds. Output parameters: B = regression parameters; V = inverse matrix, [0..2,0..2].
	
\end{itemize}
\subsubsection{WLinFit}
\label{ulinfit-WLinFit}
\index[proc]{WLinFit}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure WLinFit(X, Y, S : TVector; Lb, Ub : Integer; B : TVector; V : TMatrix);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Weighted linear regression. Additional input parameter: S = standard deviations of observations.
	
\end{itemize}
\subsubsection{SVDLinFit}
\label{ulinfit-SVDLinFit}
\index[proc]{SVDLinFit}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure SVDLinFit(X, Y : TVector; Lb, Ub : Integer; SVDTol : Float; B : TVector; V : TMatrix);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Unweighted linear regression by singular value decomposition. SVDTol = tolerance on singular values.
	
\end{itemize}
\subsubsection{WSVDLinFit}
\label{ulinfit-WSVDLinFit}
\index[proc]{WSVDLinFit}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure WSVDLinFit(X, Y, S : TVector; Lb, Ub : Integer; SVDTol : Float; B : TVector; V : TMatrix);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Weighted linear regression by singular value decomposition.
	
\end{itemize}
\section{Unit umulfit}
\label{umulfit}
\index[unit]{umulfit}
\subsection{Description}
Multiple linear regression (Gauss-Jordan method) 
$$Y = B_0 + B_1X_1 + B_2X_2 +\dots+ B_dX_d$$
\subsection{Functions and Procedures}
\subsubsection{MulFit}
\label{umulfit-MulFit}
\index[proc]{MulFit}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure MulFit(X : TMatrix; Y : TVector; Lb, Ub, Nvar : Integer; ConsTerm : Boolean; B : TVector; V : TMatrix);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Input parameters: 
	\begin{itemize}
		\item X = matrix of independent variables, [Lb..Ub,1..NVar];
		\item Y = vector of dependent variable; 
		\item Lb, Ub = array bounds; 
		\item NVar = number of independent variables; 
		\item ConsTerm = presence of constant term B(0). 
	\end{itemize}
	Output parameters: B = regression parameters; V = inverse matrix, [0..d,0..d].
\end{itemize}
\subsubsection{WMulFit}
\label{umulfit-WMulFit}
\index[proc]{WMulFit}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure WMulFit(X : TMatrix; Y, S : TVector; Lb, Ub, Nvar : Integer; ConsTerm : Boolean; B : TVector; V : TMatrix);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Weighted multiple linear regression. S = standard deviations of observations, other parameters as in \hyperref[umulfit-MulFit]{MulFit}.
	
\end{itemize}
\section{Unit usvdfit}
\label{usvdfit}
\index[unit]{usvdfit}
\subsection{Description}
Multiple linear regression (Singular Value Decomposition) 
\subsection{Functions and Procedures}
\subsubsection{SVDFit}
\label{usvdfit-SVDFit}
\index[proc]{SVDFit}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure SVDFit(X : TMatrix; Y : TVector; Lb, Ub, Nvar : Integer; ConsTerm : Boolean; SVDTol : Float; B : TVector; V : TMatrix);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Input parameters: X = matrix of independent variables; Y = vector of dependent variable; Lb, Ub = array bounds; Nvar = number of independent variables; ConsTerm = presence of constant term B(0). SVDTol = tolerance on singular values. Output parameters: B = regression parameters; V = inverse matrix.
	
\end{itemize}
\subsubsection{WSVDFit}
\label{usvdfit-WSVDFit}
\index[proc]{WSVDFit}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure WSVDFit(X : TMatrix; Y, S : TVector; Lb, Ub, Nvar : Integer; ConsTerm : Boolean; SVDTol : Float; B : TVector; V : TMatrix);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Weighted multiple linear regression. S = standard deviations of observations. Other parameters as in \hyperref[usvdfit-SVDFit]{SVDFit}.
	
\end{itemize}

\section{Unit unlfit}
\label{unlfit}
\index[unit]{unlfit}
\subsection{Description}
Nonlinear regression. This unit defines generic procedures for non-linear regression which are used further in all non-linear models in the library. 
\subsection{Functions and Procedures}
\subsubsection{SetOptAlgo}
\label{unlfit-SetOptAlgo}
\index[proc]{SetOptAlgo}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure SetOptAlgo(Algo : TOptAlgo);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Sets the optimization algorithm according to Algo:\hyperref[utypes-TOptAlgo]{TOptAlgo}, which must be NL{\_}MARQ, NL{\_}SIMP, NL{\_}BFGS, NL{\_}SA, NL{\_}GA. Default is NL{\_}MARQ.
	
\end{itemize}
\subsubsection{GetOptAlgo}
\label{unlfit-GetOptAlgo}
\index[proc]{GetOptAlgo}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function GetOptAlgo : TOptAlgo;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Returns the optimization algorithm.
	
\end{itemize}
\subsubsection{SetMaxParam}
\label{unlfit-SetMaxParam}
\index[proc]{SetMaxParam}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure SetMaxParam(N : Byte);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Sets the maximum number of regression parameters.
	
\end{itemize}
\subsubsection{GetMaxParam}
\label{unlfit-GetMaxParam}
\index[proc]{GetMaxParam}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function GetMaxParam : Byte;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Returns the maximum number of regression parameters.
	
\end{itemize}
\subsubsection{SetParamBounds}
\label{unlfit-SetParamBounds}
\index[proc]{SetParamBounds}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure SetParamBounds(I : Byte; ParamMin, ParamMax : Float);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Sets the bounds on the I{-}th regression parameter.
	
\end{itemize}
\subsubsection{GetParamBounds}
\label{unlfit-GetParamBounds}
\index[proc]{GetParamBounds}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure GetParamBounds(I : Byte; var ParamMin, ParamMax : Float);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Returns the bounds on the I{-}th regression parameter.
	
\end{itemize}
\subsubsection{NullParam}
\label{unlfit-NullParam}
\index[proc]{NullParam}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function NullParam(B : TVector; Lb, Ub : Integer) : Boolean;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Checks if a regression parameter is equal to zero.
	
\end{itemize}
\subsubsection{NLFit}
\label{unlfit-NLFit}
\index[proc]{NLFit}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure NLFit(RegFunc : TRegFunc; DerivProc : TDerivProc; X, Y : TVector; Lb, Ub : Integer; MaxIter : Integer; Tol : Float; B : TVector; FirstPar, LastPar : Integer; V : TMatrix);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Unweighted nonlinear regression. Input parameters: RegFunc:\hyperref[utypes-TRegFunc]{TRegFunc} = regression function; DerivProc = procedure to compute derivatives; X, Y = point coordinates; Lb, Ub = array bounds; MaxIter = max. number of iterations; Tol = tolerance on parameters; B = initial parameter values; FirstPar = index of first regression parameter; LastPar = index of last regression parameter; Output parameters: B = fitted regression parameters; V = inverse matrix. Its dimentions must be [Lb..Ub, Lb..Ub], or [0..Ub,0..Ub]. The matrix must be allocated, but does not require any initialization.
	
\end{itemize}
\subsubsection{WNLFit}
\label{unlfit-WNLFit}
\index[proc]{WNLFit}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure WNLFit(RegFunc : TRegFunc; DerivProc : TDerivProc; X, Y, S : TVector; Lb, Ub : Integer; MaxIter : Integer; Tol : Float; B : TVector; FirstPar, LastPar : Integer; V : TMatrix);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Weighted nonlinear regression. S = standard deviations of observations. Other parameters as in NLFit.
	
\end{itemize}
\subsubsection{SetMCFile}
\label{unlfit-SetMCFile}
\index[proc]{SetMCFile}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure SetMCFile(FileName : String);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Set file for saving MCMC simulations
	
\end{itemize}
\subsubsection{SimFit}
\label{unlfit-SimFit}
\index[proc]{SimFit}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure SimFit(RegFunc : TRegFunc; X, Y : TVector; Lb, Ub : Integer; B : TVector; FirstPar, LastPar : Integer; V : TMatrix);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Simulation of unweighted nonlinear regression by Markov chain Monte Carlo (MCMC) method.
	
\end{itemize}
\subsubsection{WSimFit}
\label{unlfit-WSimFit}
\index[proc]{WSimFit}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure WSimFit(RegFunc : TRegFunc; X, Y, S : TVector; Lb, Ub : Integer; B : TVector; FirstPar, LastPar : Integer; V : TMatrix);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Simulation of weighted nonlinear regression by MCMC.
\end{itemize}

\section{Unit uConstrNLFit}\label{sec:unit-uconstrnlfit}
\subsection{Description}
This unit implements fit of a data with non-linear regression models including arbitrary constrains on the model variables and their relations. Fitting procedure uses the COBYLA algorithm, implemented in the unit uCOBYLA, see \ref{sec:unit-ucobyla}. 
\subsection{Types}
\subsubsection{TConstrainsProc}
\label{uconstrnlfit:tconstrainsproc}\index[type]{TConstrainsProc}
\begin{itemize}
\item[\declarationitem{Declaration}\hfill]
\begin{flushleft}
	TConstrainsProc = procedure(MaxCon: integer; B, Con : TVector);
\end{flushleft}
\item[\descriptiontitle{Description}]
This is function type for calculation of constraint expressions supplied to COBYLA algorithm. It calculates constraint functions and puts results of calculation into \code{Con} array. \code{B} is vector of model parameters as in \hyperref[uconstrnlfit-constrnlfit]{ConstrNLFit}. Constraint calculation results are placed from \code{Con[1]} and ending with \code{Con[LastCon]}. At the end they must be nonnegative.
\code{Con[0]} is not used, Fortran inheritance. \code{Con} is allocated by the fitting procedure.
\end{itemize}
\subsection{Procedures and Functions}
\subsubsection{ConstrNLFit}
\label{uconstrnlfit-ConstrNLFit}\index[proc]{ConstrNLFit}
\begin{itemize}
	\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
	procedure ConstrNLFit(\\
	\hspace{12pt} RegFunc: TRegFunc; ConstProc: TConstrainsProc;  X, Y: TVector; \\
	\hspace{12pt} Lb, Ub: Integer; var MaxFun: Integer; var Tol: Float; B: TVector;\\
	\hspace{12pt} LastPar: Integer; LastCon: Integer; out MaxCV: float);
	\end{flushleft}
	\item[\descriptiontitle{Description}\hfill]
	Non-linear regression with constrains. Parameters: RegFunc:\code{\hyperref[utypes-TRegFunc]{TRegFunc}} = regression function fitting the data; \code{ConstProc: \hyperref[uconstrnlfit:tconstrainsproc]{TConstrainsProc}} = procedure calculating constrain expressions, which must be non-negative; \code{X, Y} = point coordinates of the data to be fitted; \code{Lb, Ub} = bounds of \code{X} and \code{Y} arrays; \code{MaxFun} on input is maximal number of calls to objective function, to avoid endless looping; on output, actual number of calls; \code{Tol} = tolerance of fit (RhoEnd); \code{B} = vector of parameters, guesses in input, fitted values on output; \code{LastPar} = number of parameters in \code{B}. First parameter is placed in in \code{B[1]}, last in \code{B[LastParam]}; \code{LastCon} = number of constraints; \code{MaxCV} = maximal constraint violation.
\end{itemize}
\subsubsection{GetCFFittedData}
\label{uconstrnlfit:GetCFFittedData}\index[proc]{GetCFFittedData}
\begin{itemize}
	\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
	function GetCFFittedData: TVector;
	\end{flushleft}
	\item[\descriptiontitle{Description}\hfill]
Function which returns calculated values of regression function, corresponding to values from \code{X} array.
\end{itemize}
\subsubsection{GetCFResiduals}
\label{uconstrnlfit:GetCFResiduals}\index[proc]{GetCFResiduals}
\begin{itemize}
	\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
	function GetCFResiduals: TVector;
	\end{flushleft}
	\item[\descriptiontitle{Description}\hfill]
	Returns residuals (differences between data values supplied in Y array and calculated values, as returned by GetCFFittedData.)
\end{itemize}
\subsection{Variables}
\subsubsection{RhoBeg}\index[var]{RhoBeg}
\label{uconstrnlfit:RhoBeg}
\begin{itemize}
	\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
  RhoBeg : float = 1.0;
	\end{flushleft}
	\item[\descriptiontitle{Description}\hfill]
	Variable which defines RhoBeg parameter for the call of \hyperref[cobyla]{COBYLA} algorithm. Set it before call to ConstrNLFit, or leave default value if you have no idea about an optimal one. Must be scaled according to the scale of the variables and their uncertainty and is a subject of experimentation.
\end{itemize}
	
\section{Unit uevalfit}
\label{uevalfit}
\index[unit]{uevalfit}
\subsection{Description}
Fitting of a user{-}defined function. 
\subsection{Functions and Procedures}
\subsubsection{InitEvalFit}
\label{uevalfit-InitEvalFit}
\index[proc]{InitEvalFit}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure InitEvalFit(ExpressionString : String);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Defines a regression model from ExpressionList. The independent variable is denoted by 'x'. The regression parameters are denoted by single{-}character symbols, from 'a' to 'w'. Example: \code{InitEvalFit('a * exp({-}k * x)')}
	
\end{itemize}
\subsubsection{FuncName}
\label{uevalfit-FuncName}
\index[proc]{FuncName}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function FuncName : String;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Returns the name of the regression function (= ExpressionString).
	
\end{itemize}
\subsubsection{LastParam}
\label{uevalfit-LastParam}
\index[proc]{LastParam}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function LastParam : Integer;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Returns the index of the last regression parameter
	
\end{itemize}
\subsubsection{ParamName}
\label{uevalfit-ParamName}
\index[proc]{ParamName}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function ParamName(I : Integer) : String;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Returns the name of the I{-}th regression parameter.
	
\end{itemize}
\subsubsection{EvalFit}
\label{uevalfit-EvalFit}
\index[proc]{EvalFit}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure EvalFit(X, Y : TVector; Lb, Ub : Integer; MaxIter : Integer; Tol : Float; B : TVector; V : TMatrix);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Unweighted fit of the function defined by InitEvalFit
	
	Input parameters: X, Y = point coordinates; Lb, Ub = array bounds; MaxIter = max. number of iterations; Tol = tolerance on parameters. Output parameters: B = regression parameters; V = inverse matrix.
	
\end{itemize}
\subsubsection{WEvalFit}
\label{uevalfit-WEvalFit}
\index[proc]{WEvalFit}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure WEvalFit(X, Y, S : TVector; Lb, Ub : Integer; MaxIter : Integer; Tol : Float; B : TVector; V : TMatrix);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Weighted fit of the function defined by \hyperref[uevalfit-InitEvalFit]{InitEvalFit}.	
	Additional input parameter: S = standard deviations of observations.
	
\end{itemize}
\subsubsection{EvalFit{\_}Func}
\label{uevalfit-EvalFit_Func}
\index[proc]{EvalFit{\_}Func}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function EvalFit{\_}Func(X : Float; B : TVector) : Float;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Returns the value of the regression function at point X.
\end{itemize}

\section{Unit uiexpfit}
\label{uiexpfit}
\index[unit]{uiexpfit}
\subsection{Description}
This unit fits the increasing exponential :
$$y = Y_{min} + A(1-\exp(-kx))$$
\subsection{Functions and Procedures}
\subsubsection{IncExpFit}
\label{uiexpfit-IncExpFit}
\index[proc]{IncExpFit}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure IncExpFit(X, Y : TVector; Lb, Ub : Integer; ConsTerm : Boolean; MaxIter : Integer; Tol : Float; B : TVector; V : TMatrix);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Unweighted fit of model. Input parameters: X, Y = point coordinates; Lb, Ub = array bounds; ConsTerm = flag for presence of constant term (Ymin). MaxIter = max. number of iterations; Tol = tolerance on parameters. Output parameters: B = regression parameters, such that:	
	B[0] = $Y_{min}$, B[1] = A, B[2] = k; V = inverse matrix, [0..2,0..2].
	
\end{itemize}
\subsubsection{WIncExpFit}
\label{uiexpfit-WIncExpFit}
\index[proc]{WIncExpFit}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure WIncExpFit(X, Y, S : TVector; Lb, Ub : Integer; ConsTerm : Boolean; MaxIter : Integer; Tol : Float; B : TVector; V : TMatrix);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Weighted fit of model. Additional input parameter: S = standard deviations of observations.
	
\end{itemize}
\subsubsection{IncExpFit{\_}Func}
\label{uiexpfit-IncExpFit_Func}
\index[proc]{IncExpFit{\_}Func}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function IncExpFit{\_}Func(X : Float; B : TVector) : Float;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Returns the value of the regression function at point X.
	
\end{itemize}

\section{Unit uexpfit}
\label{uexpfit}
\index[unit]{uexpfit}
\subsection{Description}
This unit fits a sum of decreasing exponentials: 
$$y = Y_{min} + A_1 \exp(-a_1 x) + A_2 \exp(-a_2 x) + A_3 \exp(-a_3 x) + \dots+A_d \exp(-a_d x)$$ 
\subsection{Functions and Procedures}
\subsubsection{ExpFit}
\label{uexpfit-ExpFit}
\index[proc]{ExpFit}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure ExpFit(X, Y : TVector; Lb, Ub, Nexp : Integer; ConsTerm : Boolean; MaxIter : Integer; Tol : Float; B : TVector; V : TMatrix);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Unweighted fit of sum of exponentials. Input parameters: X, Y = point coordinates; Lb, Ub = array bounds; Nexp = number of exponentials; ConsTerm = presence of constant term B(0); MaxIter = max. number of iterations; Tol = tolerance on parameters. Output parameters: B = regression parameters; V = inverse matrix, $[0..2N_{exp},0..2N_{exp}]$.
	
	Regression parameters: $B[0] = Y_{min},\	B[1] = A_1,\ B[2] = a_1,\ B[2 i-1] = A_i,\ B[2 i] = a_i;\ i = 1..N_{exp}$.
	
	
\end{itemize}
\subsubsection{WExpFit}
\label{uexpfit-WExpFit}
\index[proc]{WExpFit}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure WExpFit(X, Y, S : TVector; Lb, Ub, Nexp : Integer; ConsTerm : Boolean; MaxIter : Integer; Tol : Float; B : TVector; V : TMatrix);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Weighted fit of sum of exponentials.
	
	Additional input parameter: S = standard deviations of observations.
	
\end{itemize}
\subsubsection{ExpFit{\_}Func}
\label{uexpfit-ExpFit_Func}
\index[proc]{ExpFit{\_}Func}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function ExpFit{\_}Func(X : Float; B : TVector) : Float;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Returns the value of the regression function at point X.
	
\end{itemize}

\section{Unit uexlfit}
\label{uexlfit}
\index[unit]{uexlfit}
\subsection{Description}
This unit fits the "exponential + linear" model:
$$y = A (1 - \exp(-k x)) + B x$$
\subsection{Functions and Procedures}
\subsubsection{ExpLinFit}
\label{uexlfit-ExpLinFit}
\index[proc]{ExpLinFit}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure ExpLinFit(X, Y : TVector; Lb, Ub : Integer; MaxIter : Integer; Tol : Float; B : TVector; V : TMatrix);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Unweighted fit of model
	
	Input parameters: X, Y = point coordinates; Lb, Ub = array bounds; MaxIter = max. number of iterations; Tol = tolerance on parameters. Output parameters: B = regression parameters, such that:
	
	B[0] = A, B[1] = k, B[2] = B; 
	
	V = inverse matrix, [0..2,0..2].
	
\end{itemize}
\subsubsection{WExpLinFit}
\label{uexlfit-WExpLinFit}
\index[proc]{WExpLinFit}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure WExpLinFit(X, Y, S : TVector; Lb, Ub : Integer; MaxIter : Integer; Tol : Float; B : TVector; V : TMatrix);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Weighted fit of model.
	
	Additional input parameter: S = standard deviations of observations.
	
\end{itemize}
\subsubsection{ExpLinFit{\_}Func}
\label{uexlfit-ExpLinFit_Func}
\index[proc]{ExpLinFit{\_}Func}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function ExpLinFit{\_}Func(X : Float; B : TVector) : Float;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Returns the value of the regression function at point X.
	
\end{itemize}

\section{Unit upolfit}
\label{upolfit}
\index[unit]{upolfit}
\subsection{Description}
Polynomial regression : 
$$Y = B_0 + B_1 X + B_2 X^2 + ...+B_d X^d$$ 
\subsection{Functions and Procedures}
\subsubsection{PolFit}
\label{upolfit-PolFit}
\index[proc]{PolFit}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure PolFit(X, Y : TVector; Lb, Ub, Deg : Integer; B : TVector; V : TMatrix);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Unweighted polynomial regression. Input parameters: X, Y = point coordinates; Lb, Ub = array bounds; Deg = degree of polynomial. Output parameters: B = regression parameters; V = inverse matrix, [0..Deg, 0..Deg].
	
\end{itemize}
\subsubsection{WPolFit}
\label{upolfit-WPolFit}
\index[proc]{WPolFit}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure WPolFit(X, Y, S : TVector; Lb, Ub, Deg : Integer; B : TVector; V : TMatrix);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Weighted polynomial regression. Additional input parameter: S = standard deviations of observations.
	
\end{itemize}
\subsubsection{SVDPolFit}
\label{upolfit-SVDPolFit}
\index[proc]{SVDPolFit}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure SVDPolFit(X, Y : TVector; Lb, Ub, Deg : Integer; SVDTol : Float; B : TVector; V : TMatrix);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Unweighted polynomial regression by singular value decomposition. SVDTol = tolerance on singular values.
	
\end{itemize}
\subsubsection{WSVDPolFit}
\label{upolfit-WSVDPolFit}
\index[proc]{WSVDPolFit}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure WSVDPolFit(X, Y, S : TVector; Lb, Ub, Deg : Integer; SVDTol : Float; B : TVector; V : TMatrix);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Weighted polynomial regression by singular value decomposition.
	
\end{itemize}
\section{Unit ufracfit}
\label{ufracfit}
\index[unit]{ufracfit}
\subsection{Description}
This unit fits a rational fraction:
$$y=\frac{p_0 + p_1 x + p_2 x^2 + ... + q_{d_1} x^{d_1}}{q_0 + q_1 x + q_2 x^2 + ... + q_{d_2} x^{d_2}}$$
\subsection{Functions and Procedures}
\subsubsection{FracFit}
\label{ufracfit-FracFit}
\index[proc]{FracFit}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure FracFit(X, Y : TVector; Lb, Ub : Integer; Deg1, Deg2 : Integer; ConsTerm : Boolean; MaxIter : Integer; Tol : Float; B : TVector; V : TMatrix);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Unweighted fit of rational fraction. Input parameters: X, Y = point coordinate; Lb, Ub = array bounds; Deg1, Deg2 = degrees of numerator and denominator; ConsTerm = presence of constant term $p_0$; MaxIter = max. number of iterations; Tol = tolerance on parameters. Output parameters: B = regression parameters, such that :
	
	$B[0] = p_0,\ B[1] = p_1,\ B[2] = p_2,\ \dots, B[Deg1] = p_d1$
	
	$B[Deg1 + 1] = q_0,\ B[Deg1 + 2] = q_1,\  \dots, B[Deg1+Deg2+1] = p_d2$; 
	
	V = inverse matrix, $[0..Deg1+Deg2+1,0..Deg1+Deg2+1]$.
	
\end{itemize}
\subsubsection{WFracFit}
\label{ufracfit-WFracFit}
\index[proc]{WFracFit}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure WFracFit(X, Y, S : TVector; Lb, Ub : Integer; Deg1, Deg2 : Integer; ConsTerm : Boolean; MaxIter : Integer; Tol : Float; B : TVector; V : TMatrix);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Weighted fit of rational fraction. Additional input parameter: S = standard deviations of observations.
	
\end{itemize}
\subsubsection{FracFit{\_}Func}
\label{ufracfit-FracFit_Func}
\index[proc]{FracFit{\_}Func}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function FracFit{\_}Func(X : Float; B : TVector) : Float;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Returns the value of the regression function at point X.
	
\end{itemize}
\section{Unit ugamfit}
\label{ugamfit}
\index[unit]{ugamfit}
\subsection{Description}
This unit fits the gamma variate regression model:
$$y = a (x - b)^c \exp\left(-\frac{x - b}{d}\right)$$
\subsection{Functions and Procedures}
\subsubsection{GammaFit}
\label{ugamfit-GammaFit}
\index[proc]{GammaFit}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure GammaFit(X, Y : TVector; Lb, Ub : Integer; MaxIter : Integer; Tol : Float; B : TVector; V : TMatrix);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Unweighted fit of model. Input parameters: X, Y = point coordinates; Lb, Ub = array bounds; MaxIter = max. number of iterations; Tol = tolerance on parameters. Output parameters: B = regression parameters, such that:
	
	B[1] = a, B[2] = b, B[3] = c, B[4] = d; 
	
	V = inverse matrix, [0..4,0..4].
	
\end{itemize}
\subsubsection{WGammaFit}
\label{ugamfit-WGammaFit}
\index[proc]{WGammaFit}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure WGammaFit(X, Y, S : TVector; Lb, Ub : Integer; MaxIter : Integer; Tol : Float; B : TVector; V : TMatrix);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Weighted fit of model. Additional input parameter: S = standard deviations of observations.
	
\end{itemize}
\subsubsection{GammaFit{\_}Func}
\label{ugamfit-GammaFit_Func}
\index[proc]{GammaFit{\_}Func}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function GammaFit{\_}Func(X : Float; B : TVector) : Float;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Returns the value of the regression function at point X.
	
\end{itemize}

\section{Unit ulogifit}
\label{ulogifit}
\index[unit]{ulogifit}
\subsection{Description}
This unit fits the logistic function :
$$
y=A + \frac{B-A}{1+\exp(-\alpha x + \beta)}
$$

and the generalized logistic function :
$$y=A + \frac{B-A}{(1+\exp(\alpha x + \beta))^n}$$
\subsection{Functions and Procedures}
\subsubsection{LogiFit}
\label{ulogifit-LogiFit}
\index[proc]{LogiFit}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure LogiFit(X, Y : TVector; Lb, Ub : Integer; ConsTerm : Boolean; General : Boolean; MaxIter : Integer; Tol : Float; B : TVector; V : TMatrix);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Unweighted fit of logistic function. Input parameters: X, Y = point coordinates; Lb, Ub = array bounds; ConsTerm = presence of constant term A; General = generalized logistic; MaxIter = max. number of iterations; Tol = tolerance on parameters. Output parameters: B = regression parameters, such that: B[0] = A; B[1] = B; B[2] = $\alpha$; B[3] = $\beta$; B[4] = n.
	
	V = inverse matrix, [0..4,0..4].
	
\end{itemize}
\subsubsection{WLogiFit}
\label{ulogifit-WLogiFit}
\index[proc]{WLogiFit}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure WLogiFit(X, Y, S : TVector; Lb, Ub : Integer; ConsTerm : Boolean; General : Boolean; MaxIter : Integer; Tol : Float; B : TVector; V : TMatrix);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Weighted fit of logistic function. Additional input parameter: S = standard deviations of observations.
	
\end{itemize}
\subsubsection{LogiFit{\_}Func}
\label{ulogifit-LogiFit_Func}
\index[proc]{LogiFit{\_}Func}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function LogiFit{\_}Func(X : Float; B : TVector) : Float;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Computes the regression function at point X. B is the vector of parameters.
	
\end{itemize}

\section{Unit upowfit}
\label{upowfit}
\index[unit]{upowfit}
\subsection{Description}
This unit fits a power function :
$$
y = A x^n
$$

\subsection{Functions and Procedures}
\subsubsection{PowFit}
\label{upowfit-PowFit}
\index[proc]{PowFit}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure PowFit(X, Y : TVector; Lb, Ub : Integer; MaxIter : Integer; Tol : Float; B : TVector; V : TMatrix);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Unweighted fit of model. Input parameters: X, Y = point coordinates; Lb, Ub = array bounds; MaxIter = max. number of iterations; Tol = tolerance on parameters. Output parameters: B = regression parameters, such that :
	
	B[0] = A, B[1] = n; 
	
	V = inverse matrix, [0..1,0..1].
	
\end{itemize}
\subsubsection{WPowFit}
\label{upowfit-WPowFit}
\index[proc]{WPowFit}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure WPowFit(X, Y, S : TVector; Lb, Ub : Integer; MaxIter : Integer; Tol : Float; B : TVector; V : TMatrix);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Weighted fit of model. Additional input parameter: S = standard deviations of observations.
	
\end{itemize}
\subsubsection{PowFit{\_}Func}
\label{upowfit-PowFit_Func}
\index[proc]{PowFit{\_}Func}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function PowFit{\_}Func(X : Float; B : TVector) : Float;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Computes the regression function at point X. B is the vector of parameters, such that:
	
	B[0] = A; B[1] = n.
	
\end{itemize}
\section{Unit uregtest}
\label{uregtest}
\index[unit]{uregtest}
\subsection{Description}
Goodness of fit tests
\subsection{Functions and Procedures}
\subsubsection{RegTest}
\label{uregtest-RegTest}
\index[proc]{RegTest}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure RegTest(Y, Ycalc : TVector; LbY, UbY : Integer; V : TMatrix; LbV, UbV : Integer; out Test : TRegTest);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Test of unweighted regression. Input parameters: Y, Ycalc = observed and calculated Y values; LbY, UbY = bounds of Y and Ycalc; V = inverse matrix, as returned by regression roitine; LbV, UbV = bounds of V; Output parameters: V = variance-covariance matrix; Test = test results.
	
\end{itemize}
\subsubsection{WRegTest}
\label{uregtest-WRegTest}
\index[proc]{WRegTest}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure WRegTest(Y, Ycalc, S : TVector; LbY, UbY : Integer; V : TMatrix; LbV, UbV : Integer; out Test : TRegTest);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Test of weighted regression. Additional input parameter: S = standard deviations of observations.
	
\end{itemize}
\section{Unit uSpline}\lmath{-24pt}
\label{uSpline}
\index[unit]{uSpline}
\subsection{Functions and Procedures}
\subsubsection{InitSpline}
\label{uSpline-InitSpline}
\index[proc]{InitSpline}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure InitSpline(Xv, Yv:TVector; var Yd:TVector; Lb,Ub:integer);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Input parameters: Xv, Yv are data points; Lb, Ub:  array bounds; Ydv: cubic spline values used in calls to \code{Splint}. This procedure must be called before actual drawing with \code{Splint} function.
\end{itemize}
\subsubsection{SplInt}
\label{uSpline-SplInt}
\index[proc]{SplInt}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function SplInt(X:Float; Xv, Yv, Ydv: TVector; Lb,Ub:integer):Float;}
	\end{flushleft}
	\par
	\item[\descriptiontitle{Description}]
	After preparing drawing by InitSpline, this function returns Y value at X. Input parameters: Xv, Yv: data points, same as at a call of \code{InitSpline}; Ydv: vector of spline data as returned by \code{InitSpline}; Lb,Ub: array bounds; X: independent variable. Returns spline value at X.
	
\end{itemize}
\subsubsection{SplDeriv}
\label{uSpline-SplDeriv}
\index[proc]{SplDeriv}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function SplDeriv(X:Float; Xv, Yv, Ydv: TVector; Lb, Ub:integer):float;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Returns first derivative to spline function at any given point.
	
\end{itemize}
\subsubsection{FindSplineExtremums}
\label{uSpline-FindSplineExtremums}
\index[proc]{FindSplineExtremums}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure FindSplineExtremums(Xv,Yv,Ydv:TVector; Lb,Ub:integer; var Minima, Maxima:TRealPointVector; var NMin, NMax: integer);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Finds all local minima and maxima of a spline between points Lb and Ub. Input parameters are the same as for \code{Splint}, except X. Output: found maximums in Maxima; minimums are in Minima; Minima[j].X is abscissa and Minima[j].Y an ordinate of extremum. Number of found minima is returned in NMin; of maxima, in NMax.
	
\end{itemize}

\section{Unit ufft}
\label{ufft}
\index[unit]{ufft}
\subsection{Description}
Fast Fourier transform 

Modified from Don Cross: \href{http://groovit.disjunkt.com/analog/time-domain/fft.html}{http://groovit.disjunkt.com/analog/time-domain/fft.html}

\subsection{Functions and Procedures}
\subsubsection{FFT}
\label{ufft-FFT}
\index[proc]{FFT}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure FFT(NumSamples : Integer; InArray, OutArray : TCompVector);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Calculates the Fast Fourier Transform of the array of complex numbers represented by 'InArray' to produce the output complex numbers in 'OutArray'. NumSamples is number of samples; InArray and OutArray must have dimentions [0..NumSamples-1].
	
\end{itemize}
\subsubsection{IFFT}
\label{ufft-IFFT}
\index[proc]{IFFT}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure IFFT(NumSamples : Integer; InArray, OutArray : TCompVector);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Calculates the Inverse Fast Fourier Transform of the array of complex numbers represented by 'InArray' to produce the output complex numbers in 'OutArray'.
	
\end{itemize}
\subsubsection{FFT{\_}Integer}
\label{ufft-FFT_Integer}
\index[proc]{FFT{\_}Integer}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure FFT{\_}Integer(NumSamples : Integer; RealIn, ImagIn : TIntVector; OutArray : TCompVector);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Same as procedure FFT, but uses Integer input arrays instead of double. Make sure you call FFT{\_}Integer{\_}Cleanup after the last time you call FFT{\_}Integer to free up memory it allocates.
	
\end{itemize}
\subsubsection{FFT{\_}Integer{\_}Cleanup}
\label{ufft-FFT_Integer_Cleanup}
\index[proc]{FFT{\_}Integer{\_}Cleanup}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure FFT{\_}Integer{\_}Cleanup;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	If you call the procedure 'FFT{\_}Integer', you must call 'FFT{\_}Integer{\_}Cleanup' after the last time you call 'FFT{\_}Integer' in order to free up dynamic memory.
	
\end{itemize}
\subsubsection{CalcFrequency}
\label{ufft-CalcFrequency}
\index[proc]{CalcFrequency}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function CalcFrequency(NumSamples, FrequencyIndex : Integer; InArray : TCompVector) : Complex;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	This function returns the complex frequency sample at a given index directly. Use this instead of 'FFT' when you only need one or two frequency samples, not the whole spectrum.
	
	It is also useful for calculating the Discrete Fourier Transform (DFT) of a number of data which is not an integer power of 2. For example, you could calculate the DFT of 100 points instead of rounding up to 128 and padding the extra 28 array slots with zeroes.
	
\end{itemize}
\chapter[Package lmSpecRegress]{Package lmSpecRegress: Specialized Regression Models}\label{package-lmSpecRegress}
\section{Description}
This package contains collection of some regression models, specific for paricular fields of knowledge. Currently it includes equation of enzyme kinetics (Michaelis-Menten equation, Hill equation), chemistry (acid-base titration curve), electrophysiology (Goldman-Hodgkin-Katz Equation for current), and some statistic distributions.
\section{Unit uDistribs}\lmath{-24pt}
\label{udistribs}
\index[unit]{udistribs}
\subsection{Description}
This unit defines several distributions and instruments to model experimental data with these distributions. Defined are binomial, exponential, hypoexponential and hyperexponential distributions.
\subsection{Functions and Procedures}
\subsubsection{dBinom}
\label{udistribs-dBinom}
\index[proc]{dBinom}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\begin{ttfamily}
			function dBinom(k,n:integer;q:Float):Float;\end{ttfamily}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Returns binomial probability density for value k in test with n trials and q probability of success in one trial. If k{$>$}n returns 0.
	
\end{itemize}
\subsubsection{ExponentialDistribution}
\label{udistribs-ExponentialDistribution}
\index[proc]{ExponentialDistribution}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\begin{ttfamily}
			function ExponentialDistribution(beta, X:float):float;\end{ttfamily}
		
	\end{flushleft}
	\item[\descriptiontitle{Description}]
	Evaluates exponential probability density with $\beta=beta$ for given X. If {$X\le 0$} returns 0.
	
\end{itemize}
\subsubsection{HyperExponentialDistribution}
\label{udistribs-HyperExponentialDistribution}
\index[proc]{HyperExponentialDistribution}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\begin{ttfamily}
			function HyperExponentialDistribution(N:integer; var Params:TVector; X:float):float;\end{ttfamily}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	N defines number of phases; Params: zero-based TVector[2*N] contains pairs of parameters for each phase: probability and time (not rate!) constant. Sum of all probabilities must be 1.
	
\end{itemize}
\subsubsection{Fit2HyperExponents}
\label{udistribs-Fit2HyperExponents}
\index[proc]{Fit2HyperExponents}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\begin{ttfamily}
			procedure Fit2HyperExponents(var Xs, Ys:TVector; Ub:integer; var P1, beta1, beta2:float);\end{ttfamily}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Estimates parameters of hyperexponential distribution with 2 phases using Marqardt algorithm
	
\end{itemize}
\subsubsection{HypoExponentialDistribution2}
\label{udistribs-HypoExponentialDistribution2}
\index[proc]{HypoExponentialDistribution2}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\begin{ttfamily}
			function HypoExponentialDistribution2(beta1, beta2, X:float):float;\end{ttfamily}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	PDF of the hypoexponential distribution with 2 phases; beta1, beta2 are time constants (not rate constants!)
	
\end{itemize}
\subsubsection{EstimateHypoExponentialDistribution}
\label{udistribs-EstimateHypoExponentialDistribution}
\index[proc]{EstimateHypoExponentialDistribution }
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\begin{ttfamily}
			procedure EstimateHypoExponentialDistribution(M,CV:float; out beta1, beta2:float);\end{ttfamily}
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Analytic estimate of the parameters of hypoexponential distribution
	
\end{itemize}
\subsubsection{Fit2Hypoexponents}
\label{udistribs-Fit2Hypoexponents}
\index[proc]{Fit2Hypoexponents}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\begin{ttfamily}
			procedure Fit2Hypoexponents(var Xs, Ys: TVector; Ub:integer; var beta1, beta2:float);\end{ttfamily}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Iterative fit of hypoexponential distribution.
	
\end{itemize}
\subsection{Types}
\subsubsection{TBinomialDistribFunction}
\label{udistribs-TBinomialDistribFunction}
\index[types]{TBinomialDistribFunction}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\begin{ttfamily}
			TBinomialDistribFunction = function(k, n:integer; q:Float):Float;\end{ttfamily}
	\end{flushleft}
\end{itemize}

\section{Unit uGauss}\lmath{-24pt}
\label{ugauss}
\index[unit]{uGauss}
\subsection{Description}
This unit fits experimental data with a multigaussian distribution which is a sum of several gaussian distributions; each has own mathematical expectancy and probability to occur, while variance is the same for all:
\begin{equation}
\label{eq:sum_gaussians}
\begin{cases}
pdf(x)=p_0g(x,\mu_0,\sigma_0)+\sum\limits_{i=1}^{n}p_{i}g(x,\mu_i,\sigma) \\
\sum\limits_{i=0}^{n}p_i=1 \,
\end{cases}
\end{equation}
Such distributions occur in patch{-}clamp experiments (distribution of current values over time in a recording with several active channels) and in chromatography (several peaks).
\subsection{Classes, Interfaces, Objects and Records}
\subsubsection{ENoSigma Class}
\label{ugauss.ENoSigma}
\index[types]{ENoSigma}
\paragraph{Hierarchy}\hspace*{\fill}

ENoSigma {$>$} Exception
%%%%Description
\subsection{Functions and Procedures}
\subsubsection{FindSigma}
\label{ugauss-FindSigma}
\index[proc]{FindSigma}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\begin{ttfamily}
			function FindSigma(var XArray, YArray:TVector; TheLength, MuPos :integer):Float;\end{ttfamily}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Quick and rough estimate of sigma for normal distribution, if $\mu$ is known and upper part of the empiric probability density curve is known. uses SigmaArray. Used internally to get guess value for the fit.
	
\end{itemize}
\subsubsection{expsig}
\label{ugauss-expsig}
\index[proc]{expsig}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\begin{ttfamily}
			function expsig(mu, sigma, X:float):float;\end{ttfamily}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Returns
	$$
	\frac{1}{2\pi}\dot\euler^\frac{-(\mu - x)^2}{2\sigma^2}
	$$
	Is used internally by several functions in the unit.
\end{itemize}
\subsubsection{ScaledGaussian}
\label{ugauss-ScaledGaussian}
\index[proc]{ScaledGaussian}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\begin{ttfamily}
			function ScaledGaussian(mu, sigma, ScF, X:float):float;\end{ttfamily}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Evaluates pdf of a gaussian distribution with mathematical expectance $\mu$ and variation $\sigma$, scaled by factor $ScF$.
\end{itemize}
\subsubsection{DerivGaussForX}
\label{ugauss-DerivGaussForX}
\index[proc]{DerivGaussForX}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\begin{ttfamily}
			function DerivGaussForX(mu, sigma, ScF, X: float):float;\end{ttfamily}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	derivative of scaled gaussian with respect to X
	
\end{itemize}
\subsubsection{DerivGaussForSigma}
\label{ugauss-DerivGaussForSigma}
\index[proc]{DerivGaussForSigma}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\begin{ttfamily}
			function DerivGaussForSigma(mu, sigma, ScF, X: float):float;\end{ttfamily}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	derivative of scaled gaussian with respect to sigma
	
\end{itemize}
\subsubsection{DerivGaussForScaler}
\label{ugauss-DerivGaussForScaler}
\index[proc]{DerivGaussForScaler}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\begin{ttfamily}
			function DerivGaussForScaler(mu, sigma, X:float):float;\end{ttfamily}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	derivative of scaled gaussian with respect to scaling factor
	
\end{itemize}
\subsubsection{DerivGaussForMean}
\label{ugauss-DerivGaussForMean}
\index[proc]{DerivGaussForMean}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\begin{ttfamily}
			function DerivGaussForMean(mu, sigma, ScF, X:float):float;\end{ttfamily}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	derivative of scaled gaussian with respect to mean
	
\end{itemize}
\subsubsection{SumGaussians}
\label{ugauss-SumGaussians}
\index[proc]{SumGaussians}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\begin{ttfamily}
			function SumGaussians(X:Float; Params:TVector):float;\end{ttfamily}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Evaluates sum of gaussians. X is independent variable; Params is vector of parameters, such that 
	
	Params[1] = $\sigma$, Params[2]..Params[N+1] -- scaling factors (in other words, probabilities of all gaussians); Params[N+2..2*N+2] -- $\mu_i,\ 0 \le i \le N$, where $N$ is number of gaussians. This function is used as RegFunc for fitting the sum of gaussians.
	
\end{itemize}
\subsubsection{SumGaussiansS0}
\label{ugauss-SumGaussiansS0}
\index[proc]{SumGaussiansS0}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\begin{ttfamily}
			function SumGaussiansS0(X:Float; Params:TVector):float;\end{ttfamily}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	$\sigma_0$ for gaussian defined as $g(\mu_0,\sigma_0)$ (See Equation~\ref{eq:sum_gaussians}) may be different from $\sigma$ for gaussians $[g_1..g_N]$ and is fitted separately. X is independent variable; Params is vector of parameters such that:
	
	Params[1] = $\sigma_0$, Params[2] = $\sigma$, it\'s value is shared among gaussians $g_1..g_N$; Params[3]..Params[N+2] are $ScF_i$ (scaling factors); Params[N+3]..[2*N+2] are $\mu_i$ for N gaussians.
	
\end{itemize}
\subsubsection{DerivGaussians}
\label{ugauss-DerivGaussians}
\index[proc]{DerivGaussians}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\begin{ttfamily}
			procedure DerivGaussians(X, Y: Float; Params, Derivs:TVector);\end{ttfamily}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	used as DerivProc
	
\end{itemize}
\subsubsection{DerivGaussiansS0}
\label{ugauss-DerivGaussiansS0}
\index[proc]{DerivGaussiansS0}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\begin{ttfamily}
			procedure DerivGaussiansS0(X, Y: Float; Params, Derivs:TVector);\end{ttfamily}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	used as DerivProc
	
\end{itemize}
\subsubsection{SetGaussFit}
\label{ugauss-SetGaussFit}
\index[proc]{SetGaussFit}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\begin{ttfamily}
			procedure SetGaussFit(ANumberOfGaussians:integer; AUseSigma0, AFitMeans: boolean);\end{ttfamily}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Set model parameters: ANumberOfGaussians: How many gaussians form the distribution; AUseSigma0 : if Sigma0 may be different from others; AFitMeans: if means of all gaussians are fitted or they are fixed and only sigmas and scale factors (which give probabilities for every gaussian) are fitted. This procedure must be called before \begin{ttfamily} SumGaussFit \end{ttfamily}.
	
\end{itemize}
\subsubsection{SumGaussFit}
\label{ugauss-SumGaussFit}
\index[proc]{SumGaussFit}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\begin{ttfamily}
			procedure SumGaussFit(var AMathExpect: TVector; var ASigma, ASigma0:Float; var ScFs : TVector; const AXV, AYV:TVector; Observ:integer);\end{ttfamily}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Actual fit of the model. AMathExpect: as input, guess values for means; as output, fitted means; ASigma, ASigma0: guessed and then found Sigma for all gaussians and, if needed, for first one; AXV, AYV: experimental data for X and for Y (observed probability distribution density); Observ: number of observations (High bound of AXV and AYV
	
\end{itemize}
\section{Unit uGaussf}\lmath{-24pt}
\label{ugaussf}
\index[unit]{ugaussf}
\subsection{Description}
This unit is largely similar to \code{lmgauss}, but in this model difference $\mu_{i+1} - \mu_{i} = \delta_{\mu}$ is constant. Such distributions arise often in patch-clamp experiments. Consequently, fitted are $[\sigma_0,\sigma, \mu_0,\delta_{\mu},SCF_i]$.
\subsection{Functions and Procedures}
\subsubsection{SumGaussiansF}
\label{ugaussf-SumGaussiansF}
\index[proc]{SumGaussiansF}
\begin{itemize}
	\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\begin{ttfamily}
			function SumGaussiansF(X:Float; Params:TVector):float;
		\end{ttfamily}
	\end{flushleft}
	\par
	\item[\descriptiontitle{Description}]
	X is independent variable; Params is vector of parameters: Params[1] is $\sigma$, Params[2]..Params[N+1] are $ScF_i$ (scaling factors); Params[N+2] is $\mu_0$; Params[N+3] is $\delta_{\mu}$. This function is used as RegFunc for fitting of sum of gaussian. 
\end{itemize}

\subsubsection{SumGaussiansFS0}
\label{ugaussf-SumGaussiansFS0}
\index[proc]{SumGaussiansFS0}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\begin{ttfamily}
			function SumGaussiansFS0(X:Float; Params:TVector):float;
		\end{ttfamily}
	\end{flushleft}
	\par
	\item[\descriptiontitle{Description}]
	Similar to \code{SumGaussiansS0}, this function evaluates multigaussian distribution with a separate $\sigma_0$. $X$ is independent variable; Params is vector of parameters: Params[1] is $\sigma_0$, Params[2] is $\sigma$, Params[3]..Params[N+2] are $ScF_i$ (scaling factors). Params[N+3] is $\mu_0$, Params[N+4] is $\delta_{\mu}$.
	
\end{itemize}
\subsubsection{DerivGaussForDelta}
\label{ugaussf-DerivGaussForDelta}
\index[proc]{DerivGaussForDelta}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\begin{ttfamily}
			function DerivGaussForDelta(X:float; Params:TVector; HaveS0:boolean):float;\end{ttfamily}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Calculates a partial derivative of \code{SumGaussiansF} with respect to $\delta_{\mu}$.
	
\end{itemize}
\subsubsection{DerivGaussForMu0}
\label{ugaussf-DerivGaussForMu0}
\index[proc]{DerivGaussForMu0}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\begin{ttfamily}
			function DerivGaussForMu0(X:float; Params:TVector):float;\end{ttfamily}
		
	\end{flushleft}
	\par
	\item[\descriptiontitle{Description}]
	Calculates a partial derivative of \code{SumGaussiansF} with respect to $\mu_0$.
	
\end{itemize}
\subsubsection{DerivGaussS0ForMu0}
\label{ugaussf-DerivGaussS0ForMu0}
\index[proc]{DerivGaussS0ForMu0}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\begin{ttfamily}
			function DerivGaussS0ForMu0(X:float; Params:TVector):float;\end{ttfamily}
		
	\end{flushleft}
	
\end{itemize}
\subsubsection{DerivGaussiansF}
\label{ugaussf-DerivGaussiansF}
\index[proc]{DerivGaussiansF}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\begin{ttfamily}
			procedure DerivGaussiansF(X, Y: Float; Params, Derivs:TVector);\end{ttfamily}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Calculates partial derivatives for all fitted params. Derivs[1] {-} with resp. to sigma Derivs[2]..Derivs[NumberOfGaussians+1] with respect to ScF Derivs[NumberOfGaussians+2] {-} to Mu0 Derivs[NumberOfGaussians+3] {-} to Delta
	
\end{itemize}
\subsubsection{DerivGaussiansFS0}
\label{ugaussf-DerivGaussiansFS0}
\index[proc]{DerivGaussiansFS0}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\begin{ttfamily}
			procedure DerivGaussiansFS0(X, Y: Float; Params, Derivs:TVector);\end{ttfamily}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Calculates partial derivatives for all fitted params, separate sigma for Mu0 Derivs[1] {-} with resp. to sigma0; Derivs[2] {-} to Sigma Derivs[3]..Derivs[NumberOfGaussians+2] with respect to ScF Derivs[NumberOfGaussians+3] {-} to Mu0 Derivs[NumberOfGaussians+4] {-} to Delta
	
\end{itemize}
\subsubsection{SetGaussFitF}
\label{ugaussf-SetGaussFitF}
\index[proc]{SetGaussFitF}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\begin{ttfamily}
			procedure SetGaussFitF(ANumberOfGaussians:integer; AUseSigma0:boolean);\end{ttfamily}
		
	\end{flushleft}
	\par
	\item[\descriptiontitle{Description}]
	Sets parameters of the model. \code{ANumberOfGaussians} is the number of gaussians which form the multigaussian distribution; \code{AUseSigma0} defines if $\sigma_0$ can be different from $\sigma$ for other distributions. This procedure must be called before \code{DeltaFitGauss}.
	
\end{itemize}
\subsubsection{DeltaFitGaussians}
\label{ugaussf-DeltaFitGaussians}
\index[proc]{DeltaFitGaussians}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\begin{ttfamily}
			procedure DeltaFitGaussians(var ASigma, ASigma0, ADelta, AMu0: Float; var ScFs: TVector; const AXV, AYV: TVector; Observ: integer);\end{ttfamily}
		
	\end{flushleft}
	\par
	\item[\descriptiontitle{Description}]
	This procedure executes actual fit of the multigaussian model with the costant $\delta_{\mu}$. \code{ASigma, ASigma0, ADelta, AMu0} before call must contain guess values for respective parameters of the model; after call, the found refined values. \code{ScFs[1..N]} is vector of scaling factors, guess values before the call and refined values upon return. \code{AXV[1..Observ]} and \code{AVY[1..Observ]} are vectors of independent variable (X) and corresponding distribution density (Y) in the observed histogram; \code{Observ} is number of observations, or bins in the histogram.
\end{itemize}

\section{Unit ugoldman}\lmath{-24pt}
\label{ugoldman}
\index[unit]{ugoldman}
\subsection{Description}
This unit defines and fits Goldman-Hodgkin-Katz equation for current:
\begin{equation}\label{eq:GHK_current}
I=P\dfrac{z^2F^2V_m}{RT}\cdot\dfrac{{C_i}-{C_e}\,\euler^{\frac{-zFV_m}{RT}}}{1-\euler^{\frac{-zFV_m}{RT}}}
\end{equation}
where $I$ is current ($Amp$) or current density ($Amp/m^2$); $P$ is specific permeability ($Mol/m^2$) if current density is calculated or permeability ($Mol/m^3$) if current is calculated. $z$ is valence of permeated ion; $F$ is Faraday constant; $R$ is gas constant; $T$ is absolute temperature, $K$; $V_m$ is transmembrane voltage, $V$; $C_{i}$ and $C_{e}$ are intracellular and extracellular concentrations of permeated ion, respectively.

Note, that at a call to function, temerature is expressed in \celsius\ and voltage in $mV$; all conversions are done by the function itself.   
\subsection{Functions and Procedures}
\subsubsection{GHK}
\label{ugoldman-GHK}
\index[proc]{GHK}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function GHK(P, z, Cin, Cout, Vm, TC: float):float;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Returns current, $Amp$, calculated according to Goldman-Hodgkin-Katz equation (\ref{eq:GHK_current}) at a given transmembrane potential, $mV$. 
	
	Parameters: $P$: permeability constant. Classically, current density $(Amp/m^2)$ is calculated and $P$ is in $m/s$. If we are interested in absolute value of current and not density, P is $m^3/s$. $z$ is ion charge (-1 for Cl\textsuperscript{-}; 2 for Ca\textsuperscript{++} etc). It is float since for non-selective channels apparent valence of permeated ion may be non-integer. $Cin$ is intracellular concentration of ion, $Mol/m^3$ or $mM/ml$; $Cout$ is extracellular concentration. Vm is transmembrane voltage, $mV$. TC is temperature, \celsius.
	
\end{itemize}
\subsubsection{FitGHK}
\label{ugoldman-FitGHK}
\index[proc]{FitGHK}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure FitGHK(CinFixed : boolean; az, aCout, aTC : float; var Cin, P : float; Voltages, Currents : TVector; Lb, Ub:integer);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Fits data with Goldman-Hodgkin-Katz equation. 
	
	Input parameters: $CinFixed$: flag that intracellular concentration is known and fixed; only permeability constant must be fitted. If false, both $C_{in}$ and $P$ are fitted. $az,\ aCout $ are valence and extracellular concentration of permeated ion; $aTC$ is temperature, \celsius; $Cin$ and $P$ are initial (guess) values for intracellular concentration and permeability; $Voltages$ and $Currents$ are vectors of observed data; $Lb$ and $Ub$ are array bounds.
	
	Output: Fitted permeability is returned in $P$ and, if not $CinFixed$, then fitted intracellular concentration in $Cin$, otherwise $Cin$ keeps its initial value.  
	
\end{itemize}
\subsubsection{GOutMax}
\label{ugoldman-GOutMax}
\index[proc]{GOutMax}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function GOutMax(P,TC,Cin,Cout,z:float):float;}
		
	\end{flushleft}
	
	\item[\descriptiontitle{Description}]
	When $V_m\rightarrow\pm\infty$, Goldman-Hodgkin-Katz voltage-current dependance tends to linear and slope conductance ($G_s$)tends to constant: 
	$$
	\lim_{V_m\rightarrow+\infty}{G_s}=G{OutMax}
	$$
\end{itemize}
\subsubsection{GInMax}
\label{ugoldman-GInMax}
\index[proc]{GInMax}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function GInMax(P,TC,Cin,Cout,z:float):float;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Similar to GoutMax, but finds limit for $-\infty$:
	$$
	\lim_{V_m\rightarrow-\infty}{G_s}=G{InMax}
	$$
	
\end{itemize}
\subsubsection{ERev}
\label{ugoldman-ERev}
\index[proc]{ERev}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function ERev(CIn, COut, z, TC:float):float;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Returns reverse potential by Nernst equation, mV. TC : temperature, \celsius.
	
\end{itemize}
\subsubsection{Intracellular}
\label{ugoldman-Intracellular}
\index[proc]{Intracellular}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function Intracellular(Cout, z, TC, ERev:float):float;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Returns intracellular concentration from $C_{out}$, valence, temperature (\celsius), $E_{Rev}$ ($mV$)
	
\end{itemize}
\subsubsection{GSlope}
\label{ugoldman-GSlope}
\index[proc]{GSlope}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function GSlope(Cin,Cout,z,TC,Vm,P:float):float;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Returns slope conductance at any $V_m$.
	
\end{itemize}
\subsubsection{PfromSlope}
\label{ugoldman-PfromSlope}
\index[proc]{PfromSlope}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function PfromSlope(dI,dV,z,C,TC:float):float;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Returns permeability for linear voltage-current relations. $dI$ and $dV$ are current and corresponding voltage.
	
\end{itemize}
\section{Unit uhillfit}
\label{uhillfit}
\index[unit]{uhillfit}
\subsection{Description}
This unit fits the Hill equation:
$$
y=A+\frac{B-A}{1+(K/x)^n}
$$

$n>0$ for an increasing curve; 

$n<0$ for a decreasing curve. 
\subsection{Functions and Procedures}
\subsubsection{HillFit}
\label{uhillfit-HillFit}
\index[proc]{HillFit}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure HillFit(X, Y : TVector; Lb, Ub : Integer; ConsTerm : Boolean; MaxIter : Integer; Tol : Float; B : TVector; V : TMatrix);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Unweighted fit of model. Input parameters: X, Y = point coordinates; Lb, Ub = array bounds; ConsTerm = presence of constant term A; MaxIter = max. number of iterations; Tol = tolerance on parameters. Output parameters: B = regression parameters, such that:
	
	B[0] = A, B[1] = B, B[2] = K, B[3] = n; 
	
	V = inverse matrix, [0..3,0..3].
	
\end{itemize}
\subsubsection{WHillFit}
\label{uhillfit-WHillFit}
\index[proc]{WHillFit}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure WHillFit(X, Y, S : TVector; Lb, Ub : Integer; ConsTerm : Boolean; MaxIter : Integer; Tol : Float; B : TVector; V : TMatrix);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Weighted fit of model. Additional input parameter: S = standard deviations of observations.
	
\end{itemize}
\subsubsection{HillFit{\_}Func}
\label{uhillfit-HillFit_Func}
\index[proc]{HillFit{\_}Func}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function HillFit{\_}Func(X : Float; B : TVector) : Float;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Computes the regression function at point X. B is the vector of parameters.
	
\end{itemize}
\section{Unit umichfit}
\label{umichfit}
\index[unit]{umichfit}
\subsection{Description}
This unit fits the Michaelis equation:
$$
y=\frac{Y_{max}X}{K_m+X}
$$
\subsection{Functions and Procedures}
\subsubsection{MichFit}
\label{umichfit-MichFit}
\index[proc]{MichFit}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure MichFit(X, Y : TVector; Lb, Ub : Integer; MaxIter : Integer; Tol : Float; B : TVector; V : TMatrix);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Unweighted fit of model. Input parameters: X, Y = point coordinates; Lb, Ub = array bounds; MaxIter = max. number of iterations; Tol = tolerance on parameters. Output parameters: B = regression parameters, such that:
	
	B[0] = $Y_{max}$, B[1] = $K_m$;
	
	V = inverse matrix, [0..1,0..1].
	
\end{itemize}
\subsubsection{WMichFit}
\label{umichfit-WMichFit}
\index[proc]{WMichFit}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure WMichFit(X, Y, S : TVector; Lb, Ub : Integer; MaxIter : Integer; Tol : Float; B : TVector; V : TMatrix);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Weighted fit of model. Additional input parameter: S = standard deviations of observations.
	
\end{itemize}
\subsubsection{MichFit{\_}Func}
\label{umichfit-MichFit_Func}
\index[proc]{MichFit{\_}Func}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function MichFit{\_}Func(X : Float; B : TVector) : Float;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Returns the value of the regression function at point X.
	
\end{itemize}
\section{Unit umintfit}
\label{umintfit}
\index[unit]{umintfit}
\subsection{Description}
This unit fits the Integrated Michaelis{-}Menten equation:
$$
y=S_0-K_m \cdot \textrm{W}\left(\frac{S_0}{K_m}\cdot \exp\left(\frac{S_0-k_{cat}\,E_0\,t}{K_m}\right)\right)
$$
y = product concentration at time t; $S_0$ = initial substrate concentration; $K_m$ = Michaelis constant; $k_{cat}$ = catalytic constant; $E_0$ = total enzyme concentration.

W is Lambert's function (reciprocal of x * exp(x)).

The independent variable x may be:
\begin{itemize}
	\item $t\ \Longrightarrow$ fitted parameters: $S_0$ (optional), $K_m$, $V_{max} = k_{cat}\,E_0$\ ;
	\item $S_0\ \Longrightarrow$ fitted parameters: $K_m,\ (V{max}\cdot t)$;
	\item $E_0\ \Longrightarrow$ fitted parameters: $S_0$ (optional), $K_m,\ (k_{cat}\cdot t)$.
\end{itemize}
Optional parameter is placed in \code{B[0]}, others in following elements of \code{B} array.
\subsection{Functions and Procedures}
\subsubsection{MintFit}
\label{umintfit-MintFit}
\index[proc]{MintFit}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure MintFit(X, Y : TVector; Lb, Ub : Integer; MintVar : TMintVar; Fit{\_}S0 : Boolean; MaxIter : Integer; Tol : Float; B : TVector; V : TMatrix);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Unweighted fit of model. Input parameters: X, Y = point coordinates; Lb, Ub = array bounds; MintVar = independant variable, possible values: (Var{\_}T, Var{\_}S, Var{\_}E). Fit{\_}S0 indicates if $S_0$ must be fitted (for Var{\_}T or Var{\_}E only); MaxIter = max. number of iterations; Tol = tolerance on parameters; B[0] = initial value of S0. Output parameters: B = regression parameters; V = inverse matrix, [0..2, 0..2].
	
\end{itemize}
\subsubsection{WMintFit}
\label{umintfit-WMintFit}
\index[proc]{WMintFit}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure WMintFit(X, Y, S : TVector; Lb, Ub : Integer; MintVar : TMintVar; Fit{\_}S0 : Boolean; MaxIter : Integer; Tol : Float; B : TVector; V : TMatrix);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Weighted fit of model. Additional input parameter: S = standard deviations of observations.
	
\end{itemize}
\subsubsection{MintFit{\_}Func}
\label{umintfit-MintFit_Func}
\index[proc]{MintFit{\_}Func}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function MintFit{\_}Func(X : Float; B : TVector) : Float;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Returns the value of the regression function at point X.
	
\end{itemize}

\section{Unit upkfit}
\label{upkfit}
\index[unit]{upkfit}
\subsection{Description}
This unit fits the acid/base titration function :
$$
y=A+\frac{B-A}{1+10^{(pK_a-x)}}
$$
where $x$ is pH, $y$ is some property (e.g. absorbance) which depends on the ratio of the acidic and basic forms of the compound. $A$ is the property for the pure acidic form, B is the property for the pure basic form. $pK_a$ is the acidity constant.
\subsection{Functions and Procedures}
\subsubsection{PKFit}
\label{upkfit-PKFit}
\index[proc]{PKFit}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure PKFit(X, Y : TVector; Lb, Ub : Integer; MaxIter : Integer; Tol : Float; B : TVector; V : TMatrix);}
		
	\end{flushleft}
	
\end{itemize}
\subsubsection{WPKFit}
\label{upkfit-WPKFit}
\index[proc]{WPKFit}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure WPKFit(X, Y, S : TVector; Lb, Ub : Integer; MaxIter : Integer; Tol : Float; B : TVector; V : TMatrix);}
		
	\end{flushleft}
	
\end{itemize}
\subsubsection{PKFit{\_}Func}
\label{upkfit-PKFit_Func}
\index[proc]{PKFit{\_}Func}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function PKFit{\_}Func(X : Float; B : TVector) : Float;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Computes the regression function at point X. B is the vector of parameters, such that : B[0] = A; B[1] = B; B[2] = pKa.
	
\end{itemize}

\section{Unit uModels}
\label{umodels}
\index[unit]{umodels}
\subsection{Description} Sets and returns properties of regression models.
\subsection{Types}
\subsubsection{TRegType}
\label{umodels-TRegType}
\index[types]{TRegType}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			TRegType = (...);}
	\end{flushleft}
	\item[\descriptiontitle{Description}]
	\item[\textbf{Values}]
	\begin{description}
		\item[\texttt{REG{\_}LIN}] Linear
		\item[\texttt{REG{\_}MULT}] Multiple linear
		\item[\texttt{REG{\_}POL}] Polynom
		\item[\texttt{REG{\_}FRAC}] Rational fraction
		\item[\texttt{REG{\_}EXPO}] Sum of exponentials
		\item[\texttt{REG{\_}IEXPO}] Increasing exponential
		\item[\texttt{REG{\_}EXLIN}] Exponential + linear
		\item[\texttt{REG{\_}LOGIS}] Logistic
		\item[\texttt{REG{\_}POWER}] Power
		\item[\texttt{REG{\_}GAMMA}] Gamma distribution
		\item[\texttt{REG{\_}MICH}] Michaelis equation
		\item[\texttt{REG{\_}MINT}] Integrated Michaelis equation
		\item[\texttt{REG{\_}HILL}] Hill equation
		\item[\texttt{REG{\_}PK}] Acid{-}base titration curve
		\item[\texttt{REG{\_}EVAL}] User{-}defined function
	\end{description}
\end{itemize}
\subsubsection{TModel}
\label{umodels-TModel}
\index[types]{TModel}
\begin{itemize}
	\item[\declarationitem{Declaration}\hfill]
	
	\begin{verbatim}
	TModel = record
	case RegType : TRegType of
	REG_MULT   : (Mult_ConsTerm : Boolean; Nvar : Integer);
	REG_POL    : (Deg : Integer);
	REG_FRAC   : (Frac_ConsTerm : Boolean; Deg1, Deg2 : Integer);
	REG_EXPO   : (Expo_ConsTerm : Boolean; Nexp : Integer);
	REG_IEXPO  : (IExpo_ConsTerm : Boolean);
	REG_LOGIS  : (Logis_ConsTerm, Logis_General : Boolean);
	REG_MINT   : (MintVar : TMintVar; Fit_S0 : Boolean);
	REG_Hill   : (Hill_ConsTerm : Boolean);
	end;
	\end{verbatim}			
	\item[\descriptiontitle{Description}]
	This record defines type and parameters of a model to be fitted with a call of \hyperref[umodels-FitModel]{FitModel} or \hyperref[umodels-WFitModel]{WFitModel}. \code{RegType} is \code{TRegType} introduced above; other fields correspond to call parameters of specific functions and can be found in their descriptions. 
\end{itemize}

\subsection{Functions and Procedures}
\subsubsection{FirstParam}
\label{umodels-FirstParam}
\index[proc]{FirstParam}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function FirstParam(Model : TModel) : Integer;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Returns the index of the first regression parameter. 	
\end{itemize}
\subsubsection{LastParam}
\label{umodels-LastParam}
\index[proc]{LastParam}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function LastParam(Model : TModel) : Integer;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Returns the index of the last regression parameter. 	
\end{itemize}
\subsubsection{FuncName}
\label{umodels-FuncName}
\index[proc]{FuncName}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function FuncName(Model : TModel) : String;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Returns the name (formula) of the regression function. 	
\end{itemize}
\subsubsection{ParamName}
\label{umodels-ParamName}
\index[proc]{ParamName}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function ParamName(Model : TModel; I : Integer) : String;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Returns the name of the I{-}th parameter 	
\end{itemize}
\subsubsection{RegFunc}
\label{umodels-RegFunc}
\index[proc]{RegFunc}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function RegFunc(Model : TModel; X : Float; B : TVector) : Float;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Returns the regression function. 	
\end{itemize}
\subsubsection{FitModel}
\label{umodels-FitModel}
\index[proc]{FitModel}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure FitModel(Model : TModel; X, Y, Ycalc : TVector; U : TMatrix; Lb, Ub : Integer; MaxIter : Integer; Tol, SVDTol : Float; B : TVector; V : TMatrix; var Test : TRegTest);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Unweighted fit of model. 
	Input:\\
	\code{Model:\hyperref[umodels-TModel]{TModel}}: type and parameters of the model to be fitted;\\
	X,Y: point coordinates;\\
	U: matrix of independent variables for multilinear regression;\\
	Lb, Ub: bounds for X and Y arrays;\\
	MaxIter: maximal number of iterations;\\
	Tol, SVDTol: tolerance on regression parameters;\\
	
	Output:\\ YCalc[Lb..Ub] contains predicted Y values for each X from X array. Before call it must be allocated but does not require initialization;\\
	B: vector of regression parameters, length depends on a model;\\
	V: inverse matrix, dimentions depend on the model;\\
	Test: results of goodness of fit test.
	
\end{itemize}
\subsubsection{WFitModel}
\label{umodels-WFitModel}
\index[proc]{WFitModel}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure WFitModel(Model : TModel; X, Y, S : TVector; Ycalc : TVector; U : TMatrix; Lb, Ub : Integer; MaxIter : Integer; Tol, SVDTol : Float; B : TVector; V : TMatrix; var Test : TRegTest);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Weighted fit of model. Additional input parameter S: vector of standard deviations, [Lb,Ub]. 	
\end{itemize}

\chapter[Package lmMathUtil]{Package lmMathUtil. Various utility functions.}\label{package-lmMathUtil}
\section{Description}
Package lmMathUtil includes several units which do not belong \textit{sensu stricto} to the field of numeric analysis, but can be useful for scientific programming. Unit lmUnitsFormat allows to output values with units in conveniently formatted form using prefixes as pico-, nano- and so on. Unit lmSorting implements several sorting algorithms for arrays of Float and of TRealPoint; the latter ones may be sorted both for X and for Y; units uStrings and uWinStr define several handy functions over strings.   
\section{Unit uSearchTrees}\lmatha{-24pt}
\label{usearchtrees}
\index[unit]{usearchtrees}
\subsection{Description}
This unit defines object type TStringTreeNode as a named element of a binary search tree and implements a procedure of a search within it. Old-type object is used instead of class to save space. I don't want to use a huge \code{classes} unit in LMath.
\subsection{Types and objects}
\subsubsection{TStringTreeNode}\index[types]{TStringTreeNode}
\paragraph{Declaration\\}
\begin{verbatim}
TStringTreeNode = object
  Name : string; {Name of the object. Function Finds searches for it}
  Left : PStringTreeNode; {Link to left (lesser) element}
  Right: PStringTreeNode; {Link to right (greater) element}
  constructor Init(AName:string);
  destructor Done;
  function Find(AName:string; out Comparison:integer):PStringTreeNode;
end;
\end{verbatim}
\paragraph{Methods\\}
\subparagraph{Init}
\begin{itemize}
\item[\declarationitem{Declaration}\hfill]constructor Init(AName:TString)
\item[\descriptiontitle{Description}]Creates the object, initializes \code{Name} field with \code{AName}, \code{Left} and \code{Right} with \code{nil}.
\end{itemize}
\subparagraph{Done}
\begin{itemize}
\item[\declarationitem{Declaration}\hfill] destructor Done;
\item[\descriptiontitle{Description}]Disposes the item and all its children. To dispose a whole tree beginning with \code{TreeRoot:TStringTreeNode}, call \code{dispose(TreeRoot, done)} for its root.
\end{itemize}
\subparagraph{Find}
\begin{itemize}
	\item[\declarationitem{Declaration}]\code{function Find(AName:string;\\{}\hspace*{2cm} out Comparison:integer):PStringTreeNode;}
	\item[\descriptiontitle{Description}] Searches self and children for a member with \code{Name = AName}. returns either found item (\code{Comparison = 0} in this case) or, if the tree does not contain an item which meets condition, then returns an item where a new item with \code{AName} must be inserted. If \code{AName < Name} and, consequently, the new Item must be inserted as \code{Find.Left}, then \code{Comparison < 0}, if \code{AName > Name}, then \code{Comparison > 0}.  
\end{itemize}
\section{Unit uUnitsFormat}\lmath{-24pt}
\label{lmunitsformat}
index[unit]{uUnitsFormat}
\subsection{Description}
This unit formats a value with exponent prefixes (milli, pico etc) such that value in output is in the range 1..1000 and adds provided string at the end. For example, FormatUnits(1.2E{-}12,S) will return "1.2 pS"
\subsection{Overview}
\begin{description}
	\item[\texttt{FormatUnits}]
	\item[\texttt{FindPrefixForExponent}]
\end{description}
\subsection{Functions and Procedures}
\subsubsection{FormatUnits}
\label{lmunitsformat-FormatUnits}
\index[proc]{FormatUnits}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\begin{ttfamily}
			function FormatUnits(Val:float; UnitsStr:string):string;\end{ttfamily}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Formats a value Val and SI units name UnitStr with SI decimal prefix such that numeric value in the output string is in [{-}999..999] range and corresponding prefix is used. E.g.: FormatUnits(12000, "Hz") returns "1.2 kHz"
	
\end{itemize}
\subsubsection{FindPrefixForExponent}
\label{lmunitsformat-FindPrefixForExponent}
\index[proc]{FindPrefixForExponent}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\begin{ttfamily}
			function FindPrefixForExponent(E:integer):string;\end{ttfamily}
		
	\end{flushleft}
	
\end{itemize}
\subsection{Constants}
\subsubsection{DefFormat}
\label{lmunitsformat-DefFormat}
\index[const]{DefFormat}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\begin{ttfamily}
			DefFormat = '{\#}{\#}{\#}{\#}0.000';\end{ttfamily}
		
	\end{flushleft}
	
\end{itemize}
\subsubsection{UnitExponents}
\label{lmunitsformat-UnitExponents}
\index[const]{UnitExponents}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\begin{ttfamily}
			UnitExponents : array[0..12] of Integer = (-18, -15, -12, -9, -6, -3, 0, 3, 6, 9, 12, 15, 18);\end{ttfamily}
		
	\end{flushleft}
	
\end{itemize}
\subsubsection{UnitFactors}
\label{lmunitsformat-UnitFactors}
\index[const]{UnitFactors}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\begin{ttfamily}
			UnitFactors : array[0..12] of Float = (1E-18, 1E-15, 1E-12, 1E-9, 1E-6, 1E-3, 1, 1E3, 1E6, 1E9, 1E12, 1E15, 1E18);\end{ttfamily}
		
	\end{flushleft}
	
\end{itemize}
\subsubsection{UnitPrefix}
\label{lmunitsformat-UnitPrefix}
\index[const]{UnitPrefix}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\begin{ttfamily}
			UnitPrefix  : array[0..12] of string = ('a','f','p','n','$\mu$','m','','K','M','G','T','P','E');\end{ttfamily}
		
	\end{flushleft}
	
\end{itemize}
\subsubsection{UnitPrefixLong}
\label{lmunitsformat-UnitPrefixLong}
\index[const]{UnitPrefixLong}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\begin{ttfamily}
			UnitPrefixLong : array[0..12] of String =
			('atto', 'femto', 'pico', 'nano', 'micro', 'milli','', 'Kilo', 'Mega', 'Giga', 'Tera', 'Peta', 'Exa');\end{ttfamily}
		
	\end{flushleft}
	
\end{itemize}
\section{Unit usorting}\lmath{-24pt}
\label{usorting}
\index[unit]{usorting}
\subsection{Description}
Quicksort, InsertSort and HeapSort algorithms are implemented for sorting of arrays of float, of TRealPoint for X and for TRealPoint for Y. In all these procedures, Vector or Points is an array to be sorted; Lb, Ub are low and upper bounds of the sorted array; if desc is true, the array is sorted in descending order, otherwise in ascending.
\subsection{Functions and Procedures}
\subsubsection{QuickSort}
\label{lmsorting-QuickSort}
\index[const]{QuickSort}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\begin{ttfamily}
			procedure QuickSort(Vector : TVector; Lb,Ub:integer; desc:boolean);\end{ttfamily}
		
	\end{flushleft}
	
\end{itemize}
\subsubsection{QuickSortX}
\label{lmsorting-QuickSortX}
\index[const]{QuickSortX}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\begin{ttfamily}
			procedure QuickSortX(Points : TRealPointVector; Lb,Ub:integer; desc:boolean);\end{ttfamily}
		
	\end{flushleft}
	
\end{itemize}
\subsubsection{QuickSortY}
\label{lmsorting-QuickSortY}
\index[const]{QuickSortY}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\begin{ttfamily}
			procedure QuickSortY(Points : TRealPointVector; Lb,Ub:integer; desc:boolean);\end{ttfamily}
		
	\end{flushleft}
	
\end{itemize}
\subsubsection{InsertSort}
\label{lmsorting-InsertSort}
\index[const]{InsertSort}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\begin{ttfamily}
			procedure InsertSort(Vector : TVector; Lb,Ub:integer; desc:boolean);\end{ttfamily}
		
	\end{flushleft}
	
\end{itemize}
\subsubsection{InsertSortX}
\label{lmsorting-InsertSortX}
\index[const]{InsertSortX}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\begin{ttfamily}
			procedure InsertSortX(Points : TRealPointVector; Lb,Ub:integer; desc:boolean);\end{ttfamily}
		
	\end{flushleft}
	
\end{itemize}
\subsubsection{InsertSortY}
\label{lmsorting-InsertSortY}
\index[const]{InsertSortY}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\begin{ttfamily}
			procedure InsertSortY(Points : TRealPointVector; Lb,Ub:integer; desc:boolean);\end{ttfamily}
		
	\end{flushleft}
	
\end{itemize}
\subsubsection{Heapsort}
\label{lmsorting-Heapsort}
\index[const]{Heapsort}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\begin{ttfamily}
			procedure Heapsort(Vector:TVector; Lb, Ub : integer; desc:boolean);\end{ttfamily}
		
	\end{flushleft}
	
\end{itemize}
\subsubsection{HeapSortX}
\label{lmsorting-HeapSortX}
\index[const]{HeapSortX}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\begin{ttfamily}
			procedure HeapSortX(Points:TRealPointVector; Lb, Ub : integer; desc:boolean);\end{ttfamily}
		
	\end{flushleft}
	
\end{itemize}
\subsubsection{HeapSortY}
\label{lmsorting-HeapSortY}
\index[const]{HeapSortY}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\begin{ttfamily}
			procedure HeapSortY(Points:TRealPointVector; Lb, Ub : integer; desc:boolean);\end{ttfamily}
		
	\end{flushleft}
\end{itemize}
\section{Unit uVecUtils}\label{sec:unit-uvecutils}\index[unit]{uVecUtils}
\lmatha{-28pt}
\subsection{Types}
\subsubsection{TTestFunc, TIntTestFunc}
\index[types]{TTestFunc}\label{uvecutils:ttestfunc}\index[types]{TTestFunc}
\begin{itemize}
	\item[\declarationitem{Declaration}\hfill]
\begin{flushleft}
	\code{TTestFunc = function(X:Float):boolean;}\\
 	\code{TIntTestFunc = function(X:Integer):boolean;}
\end{flushleft}
	\item[\descriptiontitle{Description}]
	Functions of these types are used as arguments calling functions Any and FirstElement, first one with TVector or TMatrix, second with TIntVector or TIntMatrix.
\end{itemize}
\subsubsection{TMatCoords}\index[types]{TMatCoords}
\begin{itemize}
	\item[\declarationitem{Declaration}\hfill]
\begin{verbatim}
TMatCoords = record
	Row, Col :integer;
end;
\end{verbatim}
\item[\descriptiontitle{Description}]
Record, representing coordinates of a matrix element.
\end{itemize}
\subsubsection{tmCoords}
\index[types]{tmCoords}
\begin{itemize}\label{uvecutils:tmcoords}
\item[\declarationitem{Declaration}\hfill]
\code{function tmCoords(ARow,ACol:integer):TMatCoords;}
\item[\descriptiontitle{Description}]
Constructor of TMatCoords from two integers.
\end{itemize}
\subsection{Procedures and Functions}
\subsubsection{Apply}
\label{uvecutils:apply}\index[proc]{Apply}
\begin{itemize}
	\item[\declarationitem{Declaration}\hfill]
\begin{flushleft}	\code{procedure Apply(V:TVector; Lb, Ub: integer; Func:TFunc);\\ \vspace{4pt}
	procedure Apply(M:TMatrix; LRow, URow, LCol, UCol: integer; Func:TFunc); \\ \vspace{4pt}
	procedure Apply(V:TIntVector; Lb, Ub: integer; Func:TIntFunc);\\ \vspace{4pt}
	procedure Apply(M:TIntMatrix; LRow, URow, LCol, UCol: integer; Func:TIntFunc);}
\end{flushleft}	\item[\descriptiontitle{Description}]
	These procedures apply \hyperref[utypes-TFunc]{\code{TFunc}} or \code{TIntFunc} to every element of \code{V} or \code{M}.
\end{itemize}
\subsubsection{CompVec}
\label{uvectutils:compvec}\index[proc]{CompVec}
\begin{itemize}
	\item[\declarationitem{Declaration}\hfill]
\begin{flushleft}\code{function CompVec(X, Xref : TVector; Lb, Ub  : Integer; Tol : Float) : Boolean;}
\end{flushleft}\item[\descriptiontitle{Description}]
 Checks if every component of vector X is within a fraction Tol of
the corresponding component of the reference vector Xref. In this
case, the function returns True, otherwise it returns False.
\end{itemize}
\subsubsection{Any}\index[proc]{Any}
\begin{itemize}
	\item[\declarationitem{Declaration}\hfill]
\begin{flushleft}
	\code{function Any(Vector : TVector; Lb, Ub : integer; Test : TTestFunc) : boolean;\\ \vspace{4pt}
	function Any(M : TMatrix; LRow, URow, LCol, UCol : integer; Test : TTestFunc) : boolean;\\ \vspace{4pt}
	function Any(Vector : TIntVector; Lb, Ub : integer; Test : TIntTestFunc) : boolean;\\ \vspace{4pt}
	function Any(M : TIntMatrix; LRow, URow, LCol, UCol : integer; Test : TIntTestFunc) : boolean;}
\end{flushleft}	
\item[\descriptiontitle{Description}]
Applies \code{Test} function of type \hyperref[uvecutils:ttestfunc]{TTestFunc}\ to every element in Vector[Lb..Ub] or M[LCol..UCol,LRow..URow] and returns \code{true} if for any of them \code{Test} returns \code{true}.
\end{itemize}
\subsubsection{FirstElement}
\label{uvecutils:firstelement}\index[proc]{FirstElement}
\begin{itemize}
	\item[\declarationitem{Declaration}\hfill]
\begin{flushleft}
		\code{
	function FirstElement(Vector : TVector; Lb, Ub : integer; Ref : float; Comparator : TComparator) : integer;\\\vspace{4pt}
	function FirstElement(M : TMatrix; LRow, URow, LCol, UCol : integer; Ref : float; Comparator : TComparator) : TMatCoords;\\ 
	\vspace{12pt}
	function FirstElement(Vector : TVector; Lb, Ub : integer; Test : TTestFunc) : integer;\\ \vspace{4pt}
	function FirstElement(M : TMatrix; LRow, URow, LCol, UCol : integer; Test : TTestFunc) : TMatCoords;\\ \vspace{12pt}
	function FirstElement(Vector : TIntVector; Lb, Ub : integer; Ref : integer; Comparator : TIntComparator) : integer;\\ \vspace{4pt}
	function FirstElement(M : TIntMatrix; LRow, URow, LCol, UCol : integer; Ref : integer; Comparator : TIntComparator) : TMatCoords;\\ \vspace{12pt}
	function FirstElement(Vector : TVector; Lb, Ub : integer; Ref : float; CompType : TCompOperator) : integer;\\\vspace{4pt}
	function FirstElement(M : TMatrix; LRow, URow, LCol, UCol : integer; Ref : float; CompType : TCompOperator) : TMatCoords;\\ \vspace{4pt} 
	function FirstElement(Vector : TIntVector; Lb, Ub : integer; Ref : integer; CompType : TCompOperator) : integer;\\ \vspace{4pt}
	function FirstElement(M : TIntMatrix; LRow, URow, LCol, UCol : integer; Ref : integer; CompType:TCompOperator) : TMatCoords; 
}
\end{flushleft}	
\item[\descriptiontitle{Description}]
	\code{FirstElement} tests every element of an array in a slice defined by \code{Lb} and \code{Ub}, or by \code{LRow, URow, LCol, UCol} and returns index (or indices, as \hyperref[uvecutils:tmcoords]{tmCoords}, when applied to a matrix) of the first element which meets a condition. There are three ways to set the condition. First, define and pass a test function of type \hyperref[uvecutils:ttestfunc]{TTestFunc}; second, pass a reference value and a comparator function, type \hyperref[utypes-TComparator]{TComparator}. FirstElement passes to the comparator an array element as a first parameter and \code{Ref} as a second. Third way is to pass a reference value and type of comparison as a parameter \code{CompType} of type \hyperref[utypes-TCompOperator]{TCompOperator}. FirstElement will return an index (or indices, for matrix) of an element which compares to \code{Ref} according to \code{CompType}. 
\end{itemize}

\subsubsection{MaxLoc, MinLoc}\index[proc]{MaxLoc}\index[proc]{MinLoc}
\begin{itemize}
	\item[\declarationitem{Declaration}\hfill]
\begin{flushleft}	\code{function MaxLoc(Vector:TVector; Lb, Ub:integer):integer;\\ \vspace{4pt}
	function MaxLoc(M:TMatrix; LRow,URow,LCol,UCol:integer):TMatCoords;\\ \vspace{4pt}
	function MaxLoc(Vector:TIntVector; Lb, Ub:integer):integer;\\ \vspace{4pt}
	function MaxLoc(M:TIntMatrix; LRow,URow,LCol,UCol:integer):TMatCoords;\\ \vspace{12pt}
	function MinLoc(Vector:TVector; Lb, Ub:integer):integer;\\ \vspace{4pt}
	function MinLoc(M:TMatrix; LRow,URow,LCol,UCol:integer):TMatCoords;\\ \vspace{4pt}
	function MinLoc(Vector:TIntVector; Lb, Ub:integer):integer;\\ \vspace{4pt}
	function MinLoc(M:TIntMatrix; LRow,URow,LCol,UCol:integer):TMatCoords;}
\end{flushleft}	
\item[\descriptiontitle{Description}]
	Functions \code{MaxLoc} and \code{MinLoc} return the index or indices, in latter case as \hyperref[uvecutils:tmcoords]{tmCoords} record, of a maximal or minimal, respectively, element of a slice of array where array is \code{M} or \code{Vector} and slice is defined by \code{Lb} and \code{Ub} or by \code{LRow, URow, LCol, UCol} parameters. 
\end{itemize}
\subsubsection{Seq}
\label{uvecutils:seq}\index[proc]{Seq}
\begin{itemize}
	\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
\code{	function Seq(Lb, Ub : integer; first, increment:Float; Vector:TVector = nil):TVector;\\
	\vspace{4pt}
	function ISeq(Lb, Ub : integer; first, increment:integer; Vector:TIntVector = nil):TIntVector;
}	\end{flushleft}
	\item[\descriptiontitle{Description}\hfill]
	Generates arithmetic progression,\\
	 \code{V[Lb] = First; \\ V[Lb+N] = First + N * Increment}\\
	  up to \code{V[Ub]}. 
\end{itemize}
\subsubsection{SelElements}
\label{uvecutils:SelElements}\index[proc]{SelElements}
\begin{itemize}
	\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
function SelElements(Vector:TVector; Lb, Ub, ResLb : integer; Ref: float; CompType:TCompOperator):TVector;\\
\vspace{4pt}
function SelElements(Vector:TVector; Lb, Ub, ResLb : integer; Ref:float; Comparator:TComparator):TVector;\\
\vspace{12pt}
function SelElements(Vector:TIntVector; Lb, Ub, ResLb : integer; Ref: Integer; CompType:TCompOperator):TIntVector; \\ \vspace{4pt}
function SelElements(Vector:TIntVector; Lb, Ub, ResLb : integer; Ref:Integer; Comparator:TIntComparator):TIntVector;
\end{flushleft}
	\item[\descriptiontitle{Description}\hfill]
Selects from input array those elements which compare to \code{Ref} value as CompType prescribes. CompType can be \code{LT, LE, EQ, GT, GE, NE} (type \hyperref[utypes-TCompOperator]{TCompOperator}).

Other form is \code{Ref} and \code{Comparator} where comparator is:\\ \code{function(V1,V2:float):boolean}\\ (\hyperref[utypes-TComparator]{TComparator}).
If comparator returns true for an array element, the element is selected. Element of array is passed as \code{V1}, \code{Ref} as \code{V2}.
Selected elements are copied to Result array beginning from \code{ResLb}.
\end{itemize}
\section{uVecFunc}\index[unit]{uVecFunc}\lmath{-28pt}
\subsection{Description}
Unit \code{uVecFunc} defines several standard functions over elements of arrays (vectors and matrices).
\subsection{Functions} 
\subsubsection{VecAbs}
\label{uvecfunc:VecAbs}\index[proc]{VecAbs}
\begin{itemize}
	\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
procedure VecAbs(V : TVector; Lb, Ub : integer);\\ \vspace{4pt}	
procedure VecAbs(V : TIntVector; Lb, Ub : integer);
	\end{flushleft}
	\item[\descriptiontitle{Description}\hfill]
	Calculates absolute value over all elements of a vector or integer vector from V[Lb] to V[Ub].
\end{itemize}
\subsubsection{MatAbs}
\label{uvecfunc:MatAbs}\index[proc]{MatAbs}
\begin{itemize}
	\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
procedure MatAbs(M : TMatrix; Lb1, Ub1, Lb2, Ub2 : integer);\\ \vspace{4pt}	 
procedure MatAbs(M : TIntMatrix; Lb1, Ub1, Lb2, Ub2 : integer);
	\end{flushleft}
	\item[\descriptiontitle{Description}\hfill]
	Calculates absolute value of all elements in M[Lb1,Lb2] to M[Lb2,Ub2].
\end{itemize}
\subsubsection{VecSqr}
\label{uvecfunc:VecSqr}\index[proc]{VecSqr}
\begin{itemize}
	\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
procedure VecSqr(V : TVector; Lb, Ub : integer); \\ \vspace{4pt}	
procedure VecSqr(V : TIntVector; Lb, Ub : integer); 
	\end{flushleft}
	\item[\descriptiontitle{Description}\hfill]
	Calculates square of all elements in of a vector or integer vector from V[Lb] to V[Ub].
\end{itemize}
\subsubsection{MatSqr}
\label{uvecfunc:MatSqr}\index[proc]{MatSqr}
\begin{itemize}
	\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
procedure MatSqr(M : TMatrix; Lb1, Ub1, Lb2, Ub2 : integer); \\ \vspace{4pt} 
procedure MatSqr(M : TIntMatrix; Lb1, Ub1, Lb2, Ub2 : integer); 
	\end{flushleft}
	\item[\descriptiontitle{Description}\hfill]
		Calculates square of all elements in M[Lb1,Lb2] to M[Lb2,Ub2].
\end{itemize}
\subsubsection{VecSqrt}
\label{uvecfunc:VecSqrt}\index[proc]{VecSqrt}
\begin{itemize}
	\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
procedure VecSqrt(V : TVector; Lb, Ub : integer); 
	\end{flushleft}
	\item[\descriptiontitle{Description}\hfill]
		Calculates square root of all elements in of a vector from V[Lb] to V[Ub].
\end{itemize}
\subsubsection{MatSqrt}
\label{uvecfunc:MatSqrt}\index[proc]{MatSqrt}
\begin{itemize}
	\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		procedure MatSqrt(V : TVector; Lb, Ub : integer); 
	\end{flushleft}
	\item[\descriptiontitle{Description}\hfill]
		Calculates square root of all elements in M[Lb1,Lb2] to M[Lb2,Ub2].
\end{itemize}

\section{Unit uVectorHelpers}
\lmath{-28pt}
\subsection{Description}
This unit defines type helpers for \hyperref[utypes-TVector]{TVector} and \hyperref[utypes-TIntVector]{TIntVector}.
\subsection{Types}
\subsubsection{TVectorHelper}\index[types]{TVectorHelper}
\begin{itemize}
\item[\declarationitem{Declaration}\hfill]
	\begin{verbatim}
TVectorHelper = type helper for TVector
     procedure Insert(value:Float; index:integer);
     procedure Remove(index:integer);
     procedure Swap(ind1,ind2:integer);
     procedure Fill(St, En : integer; Val:Float);
     procedure Sort(Descending:boolean);
     procedure InsertFrom(
     	Source:TVector; Lb, Ub: integer; ind:integer);
     function ToString(Index:integer):string;
     function ToStrings(Dest:TStrings; First, Last:integer;
     Indices:boolean; Delimiter: char):integer;
end;
	\end{verbatim}
\end{itemize}
\subsubsection{TIntVectorHelper}\index[types]{TIntVectorHelper}
\begin{itemize}
	\item[\declarationitem{Declaration}\hfill]
	\begin{verbatim}
TIntVectorHelper = type helper for TIntVector
     procedure Insert(value:Integer; index:integer);
     procedure Remove(index:integer);
     procedure Swap(ind1,ind2:integer);
     procedure Fill(St, En : integer; Val:Integer);
     procedure InsertFrom(
     	Source:TIntVector; Lb, Ub: integer; ind:integer);
     function ToString(Index:integer):string;
     function ToStrings(Dest:TStrings; First, Last:integer;
     Indices:boolean; Delimiter: char):integer;
end;
	\end{verbatim}
\end{itemize}
\subsection{Methods}
Most of the methods of TVectorHelper and TVIntVectorHelper are identical with the exception of array element type, the following descriptions are relevant for both. The only exception is \code{sort} which is defined for TVectorHelper only.
\subsubsection{Insert}
\begin{itemize}
	\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
     procedure Insert(value:Float; index:integer);\\ \vspace{4pt}
     procedure Insert(value:Integer; index:integer);
	\end{flushleft}
	\item[\descriptiontitle{Description}]
	Inserts \code{value} in the position \code{index}. Following elements are shifted to the right. Self[High(self)] is lost.
\end{itemize}
\subsubsection{Remove}
\begin{itemize}
	\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
     procedure Remove(index:integer);
	\end{flushleft}
	\item[\descriptiontitle{Description}\hfill]
	Element in the position \code{index} is removed; succeeding elements are shifted to the left. Self[High(self)] is set to 0. 
\end{itemize}
\subsubsection{Swap}
\begin{itemize}
	\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
     procedure Swap(ind1,ind2:integer);
	\end{flushleft}
	\item[\descriptiontitle{Description}\hfill]
	Swaps elements in positions ind1, ind2. No range check is performed.
\end{itemize}
\subsubsection{Fill}
\begin{itemize}
	\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		     procedure Fill(St, En : integer; Val:Float);\\ \vspace{4pt}
		     procedure Fill(St, En : integer; Val:integer);
	\end{flushleft}
	\item[\descriptiontitle{Description}\hfill]
	Sets all elements from \code{self[St]} to \code{self[En]} to \code{Val}. If \code{en} > high(self) all elements to the end of the array are set.
\end{itemize}
\subsubsection{InsertFrom}
\begin{itemize}
	\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
     procedure InsertFrom(Source:TVector; Lb, Ub: integer; ind:integer);\\ \vspace{4pt}
     procedure InsertFrom(Source:TIntVector; Lb, Ub: integer; ind:integer);
	\end{flushleft}
	\item[\descriptiontitle{Description}\hfill]
Elements of Source beginning from \code{Source[Lb]} to \code{Source[Ub]} are inserted into \code{Self} beginning from \code{Self[ind]}. If necessary, self is expanded with \code{SetLength}. No range check for Source is performed.	
\end{itemize}
\subsubsection{Sort (TVectorHelper only)}
\begin{itemize}
	\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
     procedure Sort(Descending:boolean);
	\end{flushleft}
	\item[\descriptiontitle{Description}\hfill]
	Sorts \code{Self} using Heap sort algorithm, \code{Descending} defines order. Note that Quick sort and insert sort algorithms are umplemented in \hyperref[usorting]{uSorting} unit.
\end{itemize}
\subsubsection{ToString}
\begin{itemize}
	\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
     function ToString(Index:integer):string;
	\end{flushleft}
	\item[\descriptiontitle{Description}\hfill]
	Returns \hyperref[ustrings-FloatStr]{FloatStr}(Self[Index]) or \hyperref[ustrings-IntStr]{IntStr}(Self[Index]). Output format is defined with \hyperref[ustrings]{uStrings}.\hyperref[ustrings-SetFormat]{SetFormat} function.
\end{itemize}
\subsubsection{ToStrings}
\begin{itemize}
	\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
     function ToStrings(Dest : TStrings; First, Last: integer; Indices: boolean; Delimiter: char):integer;
	\end{flushleft}
	\item[\descriptiontitle{Description}\hfill]
     Sends string representation of the subarray \code{self[Lb]} to \code{self[Ub]} to \code{Dest}. If \code{Indices} is true, every string (for TVectorHelper) is formed as \\
     \code{IntStr(Index)+' '+Delimiter+FloatToStr(self[Index])}.
\end{itemize}

\section{Unit uVecMatPrn}\lmath{-28pt}
\label{uvecmatprn}\index[unit]{uvecmatprn}
\subsection{Description}
This small unit introduces procedures for printout of a vector or matrix in a console, useful mostly for test and demonstration purposes. See program LinProgTest as an example of usage.
\subsection{Constants}
\subsubsection{lmFmtStr}
\label{uvecmatprn:lmFmtStr}\index[const]{lmFmtStr}
\begin{itemize}
	\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
	lmFmtStr : string = '\%8.3f';
	\end{flushleft}
	\item[\descriptiontitle{Description}\hfill]
	Default format for printout of a float point number, using \code{Format} function.
\end{itemize}
\subsubsection{lmFmtStr}
\label{uvecmatprn:lmIntFmtStr}\index[const]{lmIntFmtStr}
\begin{itemize}
	\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		lmIntFmtStr : string = '\%4d';
	\end{flushleft}
	\item[\descriptiontitle{Description}\hfill]
	Default format for printout of an integer number, using \code{Format} function.
\end{itemize}
\subsection{Variables}
\subsubsection{LB}
\label{uvecmatprn:LB}\index[vart]{uvecmatprn.LB}
\begin{itemize}
	\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
LB : integer = 1;
	\end{flushleft}
	\item[\descriptiontitle{Description}\hfill]
	Defines a lower bound of an array printout. Default value is 1 (Fortran inheritance).
\end{itemize}
\subsubsection{PrintVector}
\label{uvecmatprn:PrintVector}\index[vart]{PrintVector}
\begin{itemize}
	\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
	procedure PrintVector(V:TIntVector);
	procedure PrintVector(V:TVector);
	\end{flushleft}
	\item[\descriptiontitle{Description}\hfill]
	Prints TVector or TIntVector on one line in a console window.
\end{itemize}
\subsubsection{PrintMatrix}
\label{uvecmatprn:PrintMatrix}\index[vart]{PrintMatrix}
\begin{itemize}
	\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
	procedure PrintMatrix(A:TMatrix);
	\end{flushleft}
	\item[\descriptiontitle{Description}\hfill]
	Prints TMatrix as a table in a console window.
\end{itemize}
\section{Unit ustrings}
\label{ustrings}
\index[unit]{ustrings}
\subsection{Description}
Pascal string routines 
\subsection{Functions and Procedures}
\subsubsection{LTrim}
\label{ustrings-LTrim}
\index[proc]{LTrim}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function LTrim(S : String) : String;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Removes leading blanks
	
\end{itemize}
\subsubsection{RTrim}
\label{ustrings-RTrim}
\index[proc]{RTrim}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function RTrim(S : String) : String;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Removes trailing blanks
	
\end{itemize}
\subsubsection{Trim}
\label{ustrings-Trim}
\index[proc]{Trim}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function Trim(S : String) : String;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Removes leading and trailing blanks
	
\end{itemize}
\subsubsection{StrChar}
\label{ustrings-StrChar}
\index[proc]{StrChar}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function StrChar(N : Byte; C : Char) : String;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Returns a string made of character C repeated N times
	
\end{itemize}
\subsubsection{RFill}
\label{ustrings-RFill}
\index[proc]{RFill}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function RFill(S : String; L : Byte) : String;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Completes string S with trailing blanks for a total length L
	
\end{itemize}
\subsubsection{LFill}
\label{ustrings-LFill}
\index[proc]{LFill}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function LFill(S : String; L : Byte) : String;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Completes string S with leading blanks for a total length L
	
\end{itemize}
\subsubsection{CFill}
\label{ustrings-CFill}
\index[proc]{CFill}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function CFill(S : String; L : Byte) : String;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Completes string S with leading blanks to center the string on a total length L
	
\end{itemize}
\subsubsection{Replace}
\label{ustrings-Replace}
\index[proc]{Replace}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function Replace(S : String; C1, C2 : Char) : String;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Replaces in string S all the occurences of character C1 by character C2
	
\end{itemize}
\subsubsection{Extract}
\label{ustrings-Extract}
\index[proc]{Extract}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function Extract(S : String; var Index : Byte; Delim : Char) : String;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Extracts a field from a string. Index is the position of the first character of the field. Delim is the character used to separate fields (e.g. blank, comma or tabulation). Blanks immediately following Delim are ignored. Index is updated to the position of the next field.
	
\end{itemize}
\subsubsection{Parse}
\label{ustrings-Parse}
\index[proc]{Parse}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure Parse(S : String; Delim : Char; Field : TStrVector; var N : Byte);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Parses a string into its constitutive fields. Delim is the field separator. The number of fields is returned in N. The fields are returned in Field[0]..Field[N {-} 1]. Field must be dimensioned in the calling program.
	
\end{itemize}
\subsubsection{SetFormat}
\label{ustrings-SetFormat}
\index[proc]{SetFormat}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure SetFormat(NumLength, MaxDec : Integer; FloatPoint, NSZero : Boolean);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Sets the numeric format NumLength = Length of numeric field MaxDec = Max. number of decimal places FloatPoint = True for floating point notation NSZero = True to write non significant zero's
	
\end{itemize}
\subsubsection{FloatStr}
\label{ustrings-FloatStr}
\index[proc]{FloatStr}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function FloatStr(X : Float) : String;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Converts a real to a string according to the numeric format
	
\end{itemize}
\subsubsection{IntStr}
\label{ustrings-IntStr}
\index[proc]{IntStr}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function IntStr(N : LongInt) : String;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Converts an integer to a string
	
\end{itemize}
\subsubsection{CompStr}
\label{ustrings-CompStr}
\index[proc]{CompStr}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function CompStr(Z : Complex) : String;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Converts a complex number to a string
	
\end{itemize}
\section{Unit uwinstr}
\label{uwinstr}
\index[unit]{uWinStr}
\subsection{Description}
String routines for DELPHI 
\subsection{Functions and Procedures}
\subsubsection{StrDec}
\label{uwinstr-StrDec}
\index[proc]{StrDec}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function StrDec(S : String) : String;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Replaces commas or decimal points by the decimal separator defined in SysUtils
	
\end{itemize}
\subsubsection{IsNumeric}
\label{uwinstr-IsNumeric}
\index[proc]{IsNumeric}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function IsNumeric(var S : String; out X : Float) : Boolean;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Replaces in string S the decimal comma by a point, tests if the resulting string represents a number. If so, returns this number in X
	
\end{itemize}
\subsubsection{ReadNumFromEdit}
\label{uwinstr-ReadNumFromEdit}
\index[proc]{ReadNumFromEdit}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function ReadNumFromEdit(Edit : TEdit) : Float;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Reads a floating point number from an Edit control
	
\end{itemize}
\subsubsection{WriteNumToFile}
\label{uwinstr-WriteNumToFile}
\index[proc]{WriteNumToFile}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure WriteNumToFile(var F : Text; X : Float);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Writes a floating point number in a text file, forcing the use of a decimal point
	
\end{itemize}
\chapter[Package lmPlotter]{Package lmPlotter: \\ Plotting of Mathematics}\label{package-lmPlotter}
\section{Unit uhsvrgb}
\label{uhsvrgb}
\index[unit]{uhsvrgb}
\subsection{Description}
HSV / RGB conversion. \\ 
Adapted from \href{http://www.cs.rit.edu/~ncs/color/t_convert.html}{http://www.cs.rit.edu/~ncs/color/t{\_}convert.html} \\ R, G, B values are from 0 to 255 H = [0..360), S = [0..1], V = [0..1] if S = 0, then H is undefined. 
\subsection{Functions and Procedures}
\subsubsection{HSVtoRGB}
\label{uhsvrgb-HSVtoRGB}
\index[proc]{HSVtoRGB}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure HSVtoRGB(H, S, V : Float; var R, G, B : Byte);}
		
	\end{flushleft}
	
\end{itemize}
\subsubsection{RGBtoHSV}
\label{uhsvrgb-RGBtoHSV}
\index[proc]{RGBtoHSV}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure RGBtoHSV(R, G, B : Byte; var H, S, V : Float);}
		
	\end{flushleft}
	
\end{itemize}
\section{Unit uplot}
\label{uplot}
\index[unit]{uplot}
\subsection{Description}
Plotting routines for BGI graphics (based on the Graph unit) 
\subsection{Functions and Procedures}
\subsubsection{InitGraphics}
\label{uplot-InitGraphics}
\index[proc]{InitGraphics}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function InitGraphics(Pilot, Mode : Integer; BGIPath : String) : Boolean;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Enters graphic mode
\end{itemize}
\subsubsection{SetWindow}
\label{uplot-SetWindow}
\index[proc]{SetWindow}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure SetWindow(X1, X2, Y1, Y2 : Integer; GraphBorder : Boolean);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Sets the graphic window. X1, X2, Y1, Y2: Window coordinates in {\%} of maximum. GraphBorder: Flag for drawing the window border.
	
\end{itemize}
\subsubsection{SetOxScale}
\label{uplot-SetOxScale}
\index[proc]{SetOxScale}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure SetOxScale(Scale : TScale; OxMin, OxMax, OxStep : Float);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Sets the scale on the Ox axis.
\end{itemize}
\subsubsection{SetOyScale}
\label{uplot-SetOyScale}
\index[proc]{SetOyScale}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure SetOyScale(Scale : TScale; OyMin, OyMax, OyStep : Float);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Sets the scale on the Oy axis.
	
\end{itemize}
\subsubsection{GetOxScale}
\label{uplot-GetOxScale}
\index[proc]{GetOxScale}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure GetOxScale(var Scale : TScale; var OxMin, OxMax, OxStep : Float);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Returns the scale on the Ox axis.
	
\end{itemize}
\subsubsection{GetOyScale}
\label{uplot-GetOyScale}
\index[proc]{GetOyScale}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure GetOyScale(var Scale : TScale; var OyMin, OyMax, OyStep : Float);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Returns the scale on the Oy axis.
	
\end{itemize}
\subsubsection{SetGraphTitle}
\label{uplot-SetGraphTitle}
\index[proc]{SetGraphTitle}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure SetGraphTitle(Title : String);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Sets the title for the graph.
	
\end{itemize}
\subsubsection{SetOxTitle}
\label{uplot-SetOxTitle}
\index[proc]{SetOxTitle}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure SetOxTitle(Title : String);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Sets the title for the Ox axis
	
\end{itemize}
\subsubsection{SetOyTitle}
\label{uplot-SetOyTitle}
\index[proc]{SetOyTitle}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure SetOyTitle(Title : String);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Sets the title for the Oy axis.
	
\end{itemize}
\subsubsection{GetGraphTitle}
\label{uplot-GetGraphTitle}
\index[proc]{GetGraphTitle}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function GetGraphTitle : String;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Returns the title for the graph
	
\end{itemize}
\subsubsection{GetOxTitle}
\label{uplot-GetOxTitle}
\index[proc]{GetOxTitle}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function GetOxTitle : String;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Returns the title for the Ox axis.
	
\end{itemize}
\subsubsection{GetOyTitle}
\label{uplot-GetOyTitle}
\index[proc]{GetOyTitle}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function GetOyTitle : String;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Returns the title for the Oy axis.
	
\end{itemize}
\subsubsection{SetTitleFont}
\label{uplot-SetTitleFont}
\index[proc]{SetTitleFont}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure SetTitleFont(FontIndex, Width, Height : Integer);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Sets the font for the main graph title.
	
\end{itemize}
\subsubsection{SetOxFont}
\label{uplot-SetOxFont}
\index[proc]{SetOxFont}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure SetOxFont(FontIndex, Width, Height : Integer);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Sets the font for the Ox axis (title and labels).
	
\end{itemize}
\subsubsection{SetOyFont}
\label{uplot-SetOyFont}
\index[proc]{SetOyFont}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure SetOyFont(FontIndex, Width, Height : Integer);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Sets the font for the Oy axis (title and labels).
	
\end{itemize}
\subsubsection{SetLgdFont}
\label{uplot-SetLgdFont}
\index[proc]{SetLgdFont}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure SetLgdFont(FontIndex, Width, Height : Integer);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Sets the font for the legends.
	
\end{itemize}
\subsubsection{PlotOxAxis}
\label{uplot-PlotOxAxis}
\index[proc]{PlotOxAxis}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure PlotOxAxis;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Plots the horizontal axis.
	
\end{itemize}
\subsubsection{PlotOyAxis}
\label{uplot-PlotOyAxis}
\index[proc]{PlotOyAxis}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure PlotOyAxis;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Plots the vertical axis.
	
\end{itemize}
\subsubsection{PlotGrid}
\label{uplot-PlotGrid}
\index[proc]{PlotGrid}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure PlotGrid(Grid : TGrid);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Plots a grid on the graph.
	
\end{itemize}
\subsubsection{WriteGraphTitle}
\label{uplot-WriteGraphTitle}
\index[proc]{WriteGraphTitle}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure WriteGraphTitle;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Writes the title of the graph.
	
\end{itemize}
\subsubsection{SetClipping}
\label{uplot-SetClipping}
\index[proc]{SetClipping}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure SetClipping(Clip : Boolean);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Determines whether drawings are clipped at the current viewport boundaries, according to the value of the Boolean parameter Clip.
	
\end{itemize}
\subsubsection{SetMaxCurv}
\label{uplot-SetMaxCurv}
\index[proc]{SetMaxCurv}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function SetMaxCurv(NCurv : Byte) : Boolean;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Sets the maximum number of curves. Returns False if the needed memory is not available.
	
\end{itemize}
\subsubsection{SetPointParam}
\label{uplot-SetPointParam}
\index[proc]{SetPointParam}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure SetPointParam(CurvIndex, Symbol, Size, Color : Integer);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Sets the point parameters for curve {\#} CurvIndex.
	
\end{itemize}
\subsubsection{SetLineParam}
\label{uplot-SetLineParam}
\index[proc]{SetLineParam}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure SetLineParam(CurvIndex, Style, Width, Color : Integer);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Sets the line parameters for curve {\#} CurvIndex.
	
\end{itemize}
\subsubsection{SetCurvLegend}
\label{uplot-SetCurvLegend}
\index[proc]{SetCurvLegend}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure SetCurvLegend(CurvIndex : Integer; Legend : String);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Sets the legend for curve {\#} CurvIndex.
	
\end{itemize}
\subsubsection{SetCurvStep}
\label{uplot-SetCurvStep}
\index[proc]{SetCurvStep}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure SetCurvStep(CurvIndex, Step : Integer);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Sets the step for curve {\#} CurvIndex.
	
\end{itemize}
\subsubsection{GetMaxCurv}
\label{uplot-GetMaxCurv}
\index[proc]{GetMaxCurv}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function GetMaxCurv : Byte;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Returns the maximum number of curves.
	
\end{itemize}
\subsubsection{GetPointParam}
\label{uplot-GetPointParam}
\index[proc]{GetPointParam}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure GetPointParam( CurvIndex : Integer; var Symbol, Size, Color : Integer);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Returns the point parameters for curve {\#} CurvIndex.
	
\end{itemize}
\subsubsection{GetLineParam}
\label{uplot-GetLineParam}
\index[proc]{GetLineParam}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure GetLineParam( CurvIndex : Integer; var Style, Width, Color : Integer);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Returns the line parameters for curve {\#} CurvIndex.
	
\end{itemize}
\subsubsection{GetCurvLegend}
\label{uplot-GetCurvLegend}
\index[proc]{GetCurvLegend}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function GetCurvLegend(CurvIndex : Integer) : String;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Returns the legend for curve {\#} CurvIndex.
	
\end{itemize}
\subsubsection{GetCurvStep}
\label{uplot-GetCurvStep}
\index[proc]{GetCurvStep}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function GetCurvStep(CurvIndex : Integer) : Integer;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Returns the step for curve {\#} CurvIndex.
	
\end{itemize}
\subsubsection{PlotPoint}
\label{uplot-PlotPoint}
\index[proc]{PlotPoint}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure PlotPoint(Xp, Yp, CurvIndex : Integer);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Plots a point on the screen Input parameters : Xp, Yp = point coordinates in pixels CurvIndex = index of curve parameters (Symbol, Size, Color).
	
\end{itemize}
\subsubsection{PlotCurve}
\label{uplot-PlotCurve}
\index[proc]{PlotCurve}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure PlotCurve(X, Y : TVector; Lb, Ub, CurvIndex : Integer);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Plots a curve Input parameters : X, Y = point coordinates Lb, Ub = indices of first and last points CurvIndex = index of curve parameters.
	
\end{itemize}
\subsubsection{PlotCurveWithErrorBars}
\label{uplot-PlotCurveWithErrorBars}
\index[proc]{PlotCurveWithErrorBars}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure PlotCurveWithErrorBars(X, Y, S : TVector; Ns, Lb, Ub, CurvIndex : Integer);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Plots a curve with error bars. Input parameters: X, Y = point coordinates; S = errors; Lb, Ub = indices of first and last points; CurvIndex = index of curve parameters.
	
\end{itemize}
\subsubsection{PlotFunc}
\label{uplot-PlotFunc}
\index[proc]{PlotFunc}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure PlotFunc(Func : TFunc; X1, X2 : Float; CurvIndex : Integer);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Plots a function.
	
	Input parameters: Func = function to be plotted; X1, X2 = abscissae of 1st and last point to plot; CurvIndex = index of curve parameters (Width, Style, Color).
	
	The function must be programmed as: function Func(X : Float) : Float;
	
\end{itemize}
\subsubsection{WriteLegend}
\label{uplot-WriteLegend}
\index[proc]{WriteLegend}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure WriteLegend(NCurv : Integer; ShowPoints, ShowLines : Boolean);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Writes legends for all curves.
	
	NCurv: number of curves (1 to MaxCurv); ShowPoints: for displaying points; ShowLines: for displaying lines.
	
\end{itemize}
\subsubsection{WriteLegendSelect}
\label{uplot-WriteLegendSelect}
\index[proc]{WriteLegendSelect}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure WriteLegendSelect(NSelect : Integer; Select : TIntVector; ShowPoints, ShowLines : Boolean);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Writes legends for selected curves.
	
	NSelect: number of selected curves; Select  indices of selected curves.
	
\end{itemize}
\subsubsection{ConRec}
\label{uplot-ConRec}
\index[proc]{ConRec}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure ConRec(Nx, Ny, Nc : Integer; X, Y, Z : TVector; F : TMatrix);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Contour plot. Adapted from Paul Bourke, Byte, June 1987\\ \href{http://paulbourke.net/papers/conrec/}{http://paulbourke.net/papers/conrec/}.
	
	Input parameters: Nx, Ny = number of steps on Ox and Oy; Nc = number of contour levels; X[0..Nx], Y[0..Ny] = point coordinates; Z[0..(Nc {-} 1)] = contour levels in increasing order; F[0..Nx, 0..Ny] = function values, such that F[I,J] is the function value at (X[I], Y[J]).
	
\end{itemize}
\subsubsection{Xpixel}
\label{uplot-Xpixel}
\index[proc]{Xpixel}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function Xpixel(X : Float) : Integer;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Converts user abscissa X to screen coordinate.
	
\end{itemize}
\subsubsection{Ypixel}
\label{uplot-Ypixel}
\index[proc]{Ypixel}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function Ypixel(Y : Float) : Integer;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Converts user ordinate Y to screen coordinate.
	
\end{itemize}
\subsubsection{Xuser}
\label{uplot-Xuser}
\index[proc]{Xuser}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function Xuser(X : Integer) : Float;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Converts screen coordinate X to user abscissa.
	
\end{itemize}
\subsubsection{Yuser}
\label{uplot-Yuser}
\index[proc]{Yuser}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function Yuser(Y : Integer) : Float;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Converts screen coordinate Y to user ordinate.
	
\end{itemize}
\subsubsection{LeaveGraphics}
\label{uplot-LeaveGraphics}
\index[proc]{LeaveGraphics}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure LeaveGraphics;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Quits graphic mode.
	
\end{itemize}
\section{Unit utexplot}
\label{utexplot}
\index[unit]{utexplot}
\subsection{Description}
Plotting routines for LaTeX/PSTricks
\subsection{Functions and Procedures}
\subsubsection{TeX{\_}InitGraphics}
\label{utexplot-TeX_InitGraphics}
\index[proc]{TeX{\_}InitGraphics}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function TeX{\_}InitGraphics(FileName : String; PgWidth, PgHeight : Integer; Header : Boolean) : Boolean;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Initializes the LaTeX file.
	
	FileName = Name of LaTeX file (e. g. 'figure.tex'); PgWidth, PgHeight = Page width and height in cm; Header = True to write the preamble in the file.
	
\end{itemize}
\subsubsection{TeX{\_}SetWindow}
\label{utexplot-TeX_SetWindow}
\index[proc]{TeX{\_}SetWindow}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure TeX{\_}SetWindow(X1, X2, Y1, Y2 : Integer; GraphBorder : Boolean);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Sets the graphic window.
	
	X1, X2, Y1, Y2: Window coordinates in {\%} of maximum; GraphBorder: Flag for drawing the window border.
	
\end{itemize}
\subsubsection{TeX{\_}LeaveGraphics}
\label{utexplot-TeX_LeaveGraphics}
\index[proc]{TeX{\_}LeaveGraphics}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure TeX{\_}LeaveGraphics(Footer : Boolean);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Close the LaTeX file.
	
	Footer = Flag for writing the 'end of document' section.
	
\end{itemize}
\subsubsection{TeX{\_}SetOxScale}
\label{utexplot-TeX_SetOxScale}
\index[proc]{TeX{\_}SetOxScale}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure TeX{\_}SetOxScale(Scale : TScale; OxMin, OxMax, OxStep : Float);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Sets the scale on the Ox axis.
	
\end{itemize}
\subsubsection{TeX{\_}SetOyScale}
\label{utexplot-TeX_SetOyScale}
\index[proc]{TeX{\_}SetOyScale}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure TeX{\_}SetOyScale(Scale : TScale; OyMin, OyMax, OyStep : Float);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Sets the scale on the Oy axis
	
\end{itemize}
\subsubsection{TeX{\_}SetGraphTitle}
\label{utexplot-TeX_SetGraphTitle}
\index[proc]{TeX{\_}SetGraphTitle}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure TeX{\_}SetGraphTitle(Title : String);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Sets the title for the graph.
	
\end{itemize}
\subsubsection{TeX{\_}SetOxTitle}
\label{utexplot-TeX_SetOxTitle}
\index[proc]{TeX{\_}SetOxTitle}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure TeX{\_}SetOxTitle(Title : String);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Sets the title for the Ox axis.
	
\end{itemize}
\subsubsection{TeX{\_}SetOyTitle}
\label{utexplot-TeX_SetOyTitle}
\index[proc]{TeX{\_}SetOyTitle}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure TeX{\_}SetOyTitle(Title : String);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Sets the title for the Oy axis.
	
\end{itemize}
\subsubsection{TeX{\_}PlotOxAxis}
\label{utexplot-TeX_PlotOxAxis}
\index[proc]{TeX{\_}PlotOxAxis}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure TeX{\_}PlotOxAxis;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Plots the horizontal axis
	
\end{itemize}
\subsubsection{TeX{\_}PlotOyAxis}
\label{utexplot-TeX_PlotOyAxis}
\index[proc]{TeX{\_}PlotOyAxis}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure TeX{\_}PlotOyAxis;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Plots the vertical axis
	
\end{itemize}
\subsubsection{TeX{\_}PlotGrid}
\label{utexplot-TeX_PlotGrid}
\index[proc]{TeX{\_}PlotGrid}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure TeX{\_}PlotGrid(Grid : TGrid);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Plots a grid on the graph.
	
\end{itemize}
\subsubsection{TeX{\_}WriteGraphTitle}
\label{utexplot-TeX_WriteGraphTitle}
\index[proc]{TeX{\_}WriteGraphTitle}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure TeX{\_}WriteGraphTitle;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Writes the title of the graph.
	
\end{itemize}
\subsubsection{TeX{\_}SetMaxCurv}
\label{utexplot-TeX_SetMaxCurv}
\index[proc]{TeX{\_}SetMaxCurv}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function TeX{\_}SetMaxCurv(NCurv : Byte) : Boolean;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Sets the maximum number of curves and re{-}initializes their parameters.
	
\end{itemize}
\subsubsection{TeX{\_}SetPointParam}
\label{utexplot-TeX_SetPointParam}
\index[proc]{TeX{\_}SetPointParam}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure TeX{\_}SetPointParam(CurvIndex, Symbol, Size : Integer);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Sets the point parameters for curve {\#} CurvIndex.
	
\end{itemize}
\subsubsection{TeX{\_}SetLineParam}
\label{utexplot-TeX_SetLineParam}
\index[proc]{TeX{\_}SetLineParam}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure TeX{\_}SetLineParam(CurvIndex, Style : Integer; Width : Float; Smooth : Boolean);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Sets the line parameters for curve {\#} CurvIndex.
	
\end{itemize}
\subsubsection{TeX{\_}SetCurvLegend}
\label{utexplot-TeX_SetCurvLegend}
\index[proc]{TeX{\_}SetCurvLegend}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure TeX{\_}SetCurvLegend(CurvIndex : Integer; Legend : String);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Sets the legend for curve {\#} CurvIndex.
	
\end{itemize}
\subsubsection{TeX{\_}SetCurvStep}
\label{utexplot-TeX_SetCurvStep}
\index[proc]{TeX{\_}SetCurvStep}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure TeX{\_}SetCurvStep(CurvIndex, Step : Integer);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Sets the step for curve {\#} CurvIndex.
	
\end{itemize}
\subsubsection{TeX{\_}PlotCurve}
\label{utexplot-TeX_PlotCurve}
\index[proc]{TeX{\_}PlotCurve}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure TeX{\_}PlotCurve(X, Y : TVector; Lb, Ub, CurvIndex : Integer);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Plots a curve.
	
	Input parameters: X, Y = point coordinates; Lb, Ub = indices of first and last points; CurvIndex = index of curve parameters.
	
\end{itemize}
\subsubsection{TeX{\_}PlotCurveWithErrorBars}
\label{utexplot-TeX_PlotCurveWithErrorBars}
\index[proc]{TeX{\_}PlotCurveWithErrorBars}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure TeX{\_}PlotCurveWithErrorBars(X, Y, S : TVector; Ns, Lb, Ub, CurvIndex : Integer);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Plots a curve with error bars.
	
	Input parameters: X, Y = point coordinates; S = errors; Lb, Ub = indices of first and last points; CurvIndex = index of curve parameters.
	
\end{itemize}
\subsubsection{TeX{\_}PlotFunc}
\label{utexplot-TeX_PlotFunc}
\index[proc]{TeX{\_}PlotFunc}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure TeX{\_}PlotFunc(Func : TFunc; X1, X2 : Float; Npt : Integer; CurvIndex : Integer);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Plots a function.
	
	Input parameters: Func = function to be plotted; X1, X2 = abscissae of 1st and last point to plot; Npt = number of points; CurvIndex = index of curve parameters (Width, Style, Smooth).
	
	The function must be programmed as : function Func(X : Float) : Float; 
\end{itemize}
\subsubsection{TeX{\_}WriteLegend}
\label{utexplot-TeX_WriteLegend}
\index[proc]{TeX{\_}WriteLegend}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure TeX{\_}WriteLegend(NCurv : Integer; ShowPoints, ShowLines : Boolean);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Writes legends for all curves.
	
	NCurv: number of curves (1 to MaxCurv); ShowPoints: for displaying points; ShowLines: for displaying lines.
	
\end{itemize}
\subsubsection{TeX{\_}WriteLegendSelect}
\label{utexplot-TeX_WriteLegendSelect}
\index[proc]{TeX{\_}WriteLegendSelect}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure TeX{\_}WriteLegendSelect(NSelect : Integer; Select : TIntVector; ShowPoints, ShowLines : Boolean);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Writes legends for selected curves.
	
	NSelect : number of selected curves Select : indices of selected curves
	
\end{itemize}
\subsubsection{TeX{\_}ConRec}
\label{utexplot-TeX_ConRec}
\index[proc]{TeX{\_}ConRec}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure TeX{\_}ConRec(Nx, Ny, Nc : Integer; X, Y, Z : TVector; F : TMatrix);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Contour plot Adapted from Paul Bourke, Byte, June 1987\\ \href{http://paulbourke.net/papers/conrec/}{http://paulbourke.net/papers/conrec/}
	
	Input parameters: Nx, Ny = number of steps on Ox and Oy; Nc = number of contour levels; X[0..Nx], Y[0..Ny] = point coordinates; Z[0..(Nc {-} 1)] = contour levels in increasing order; F[0..Nx, 0..Ny] = function values, such that F[I,J] is the function value at (X[I], Y[I]).
	
\end{itemize}
\subsubsection{Xcm}
\label{utexplot-Xcm}
\index[proc]{Xcm}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function Xcm(X : Float) : Float;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Converts user coordinate X to cm.
	
\end{itemize}
\subsubsection{Ycm}
\label{utexplot-Ycm}
\index[proc]{Ycm}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function Ycm(Y : Float) : Float;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Converts user coordinate Y to cm.
	
\end{itemize}
\section{Unit uwinplot}
\label{uwinplot}
\index[unit]{uwinplot}
\subsection{Description}
lotting routines for Delphi
\subsection{Functions and Procedures}
\subsubsection{InitGraphics}
\label{uwinplot-InitGraphics}
\index[proc]{InitGraphics}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function InitGraphics(Width, Height : Integer) : Boolean;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Enters graphic mode.
	
	The parameters Width and Height refer to the object on which the graphic is plotted.
	
	Examples:
	
	To draw on a TImage object: InitGraph(Image1.Width, Image1.Height)
	
	To print the graphic: InitGraph(Printer.PageWidth, Printer.PageHeight)
	
\end{itemize}
\subsubsection{SetWindow}
\label{uwinplot-SetWindow}
\index[proc]{SetWindow}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure SetWindow(Canvas : TCanvas; X1, X2, Y1, Y2 : Integer; GraphBorder : Boolean);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Sets the graphic window.
	
	X1, X2, Y1, Y2 : Window coordinates in {\%} of maximum GraphBorder : Flag for drawing the window border.
	
\end{itemize}
\subsubsection{SetOxScale}
\label{uwinplot-SetOxScale}
\index[proc]{SetOxScale}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure SetOxScale(Scale : TScale; OxMin, OxMax, OxStep : Float);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Sets the scale on the Ox axis.
	
\end{itemize}
\subsubsection{SetOyScale}
\label{uwinplot-SetOyScale}
\index[proc]{SetOyScale}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure SetOyScale(Scale : TScale; OyMin, OyMax, OyStep : Float);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Sets the scale on the Oy axis.
	
\end{itemize}
\subsubsection{GetOxScale}
\label{uwinplot-GetOxScale}
\index[proc]{GetOxScale}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure GetOxScale(var Scale : TScale; var OxMin, OxMax, OxStep : Float);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Returns the scale on the Ox axis.
	
\end{itemize}
\subsubsection{GetOyScale}
\label{uwinplot-GetOyScale}
\index[proc]{GetOyScale}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure GetOyScale(var Scale : TScale; var OyMin, OyMax, OyStep : Float);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Returns the scale on the Oy axis.
	
\end{itemize}
\subsubsection{SetGraphTitle}
\label{uwinplot-SetGraphTitle}
\index[proc]{SetGraphTitle}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure SetGraphTitle(Title : String);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Sets the title for the graph.
	
\end{itemize}
\subsubsection{SetOxTitle}
\label{uwinplot-SetOxTitle}
\index[proc]{SetOxTitle}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure SetOxTitle(Title : String);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Sets the title for the Ox axis.
	
\end{itemize}
\subsubsection{SetOyTitle}
\label{uwinplot-SetOyTitle}
\index[proc]{SetOyTitle}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure SetOyTitle(Title : String);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Sets the title for the Oy axis.
	
\end{itemize}
\subsubsection{GetGraphTitle}
\label{uwinplot-GetGraphTitle}
\index[proc]{GetGraphTitle}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function GetGraphTitle : String;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Returns the title for the graph.
	
\end{itemize}
\subsubsection{GetOxTitle}
\label{uwinplot-GetOxTitle}
\index[proc]{GetOxTitle}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function GetOxTitle : String;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Returns the title for the Ox axis.
	
\end{itemize}
\subsubsection{GetOyTitle}
\label{uwinplot-GetOyTitle}
\index[proc]{GetOyTitle}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function GetOyTitle : String;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Returns the title for the Oy axis.
	
\end{itemize}
\subsubsection{PlotOxAxis}
\label{uwinplot-PlotOxAxis}
\index[proc]{PlotOxAxis}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure PlotOxAxis(Canvas : TCanvas);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Plots the horizontal axis.
	
\end{itemize}
\subsubsection{PlotOyAxis}
\label{uwinplot-PlotOyAxis}
\index[proc]{PlotOyAxis}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure PlotOyAxis(Canvas : TCanvas);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Plots the vertical axis.
	
\end{itemize}
\subsubsection{PlotGrid}
\label{uwinplot-PlotGrid}
\index[proc]{PlotGrid}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure PlotGrid(Canvas : TCanvas; Grid : TGrid);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Plots a grid on the graph.
	
\end{itemize}
\subsubsection{WriteGraphTitle}
\label{uwinplot-WriteGraphTitle}
\index[proc]{WriteGraphTitle}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure WriteGraphTitle(Canvas : TCanvas);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Writes the title of the graph.
	
\end{itemize}
\subsubsection{SetMaxCurv}
\label{uwinplot-SetMaxCurv}
\index[proc]{SetMaxCurv}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function SetMaxCurv(NCurv : Byte) : Boolean;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Sets the maximum number of curves. Returns False if the needed memory is not available.
	
\end{itemize}
\subsubsection{SetPointParam}
\label{uwinplot-SetPointParam}
\index[proc]{SetPointParam}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure SetPointParam(CurvIndex, Symbol, Size : Integer; Color : TColor);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Sets the point parameters for curve {\#} CurvIndex.
	
\end{itemize}
\subsubsection{SetLineParam}
\label{uwinplot-SetLineParam}
\index[proc]{SetLineParam}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure SetLineParam(CurvIndex : Integer; Style : TPenStyle; Width : Integer; Color : TColor);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Sets the line parameters for curve {\#} CurvIndex.
	
\end{itemize}
\subsubsection{SetCurvLegend}
\label{uwinplot-SetCurvLegend}
\index[proc]{SetCurvLegend}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure SetCurvLegend(CurvIndex : Integer; Legend : String);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Sets the legend for curve {\#} CurvIndex.
	
\end{itemize}
\subsubsection{SetCurvStep}
\label{uwinplot-SetCurvStep}
\index[proc]{SetCurvStep}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure SetCurvStep(CurvIndex, Step : Integer);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Sets the step for curve {\#} CurvIndex.
	
\end{itemize}
\subsubsection{GetMaxCurv}
\label{uwinplot-GetMaxCurv}
\index[proc]{GetMaxCurv}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function GetMaxCurv : Byte;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Returns the maximum number of curves.
	
\end{itemize}
\subsubsection{GetPointParam}
\label{uwinplot-GetPointParam}
\index[proc]{GetPointParam}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure GetPointParam( CurvIndex : Integer; var Symbol, Size : Integer; var Color : TColor);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Returns the point parameters for curve {\#} CurvIndex.
	
\end{itemize}
\subsubsection{GetLineParam}
\label{uwinplot-GetLineParam}
\index[proc]{GetLineParam}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure GetLineParam( CurvIndex : Integer; var Style : TPenStyle; var Width : Integer; var Color : TColor);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Returns the line parameters for curve {\#} CurvIndex.
	
\end{itemize}
\subsubsection{GetCurvLegend}
\label{uwinplot-GetCurvLegend}
\index[proc]{GetCurvLegend}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function GetCurvLegend(CurvIndex : Integer) : String;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Returns the legend for curve {\#} CurvIndex.
	
\end{itemize}
\subsubsection{GetCurvStep}
\label{uwinplot-GetCurvStep}
\index[proc]{GetCurvStep}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function GetCurvStep(CurvIndex : Integer) : Integer;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Returns the step for curve {\#} CurvIndex.
	
\end{itemize}
\subsubsection{PlotPoint}
\label{uwinplot-PlotPoint}
\index[proc]{PlotPoint}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure PlotPoint(Canvas : TCanvas; X, Y : Float; CurvIndex : Integer);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Plots a point on the screen. Input parameters : X, Y = point coordinates; CurvIndex = index of curve parameters (Symbol, Size, Color).
	
\end{itemize}
\subsubsection{PlotCurve}
\label{uwinplot-PlotCurve}
\index[proc]{PlotCurve}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure PlotCurve(Canvas : TCanvas; X, Y : TVector; Lb, Ub, CurvIndex : Integer);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Plots a curve Input parameters: X, Y = point coordinates; Lb, Ub = indices of first and last points; CurvIndex = index of curve parameters.
	
\end{itemize}
\subsubsection{PlotCurveWithErrorBars}
\label{uwinplot-PlotCurveWithErrorBars}
\index[proc]{PlotCurveWithErrorBars}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure PlotCurveWithErrorBars(Canvas : TCanvas; X, Y, S : TVector; Ns, Lb, Ub, CurvIndex : Integer);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Plots a curve with error bars. Input parameters: X, Y = point coordinates; S = errors; Ns = number of SD to be plotted; Lb, Ub = indices of first and last points; CurvIndex = index of curve parameters.
	
\end{itemize}
\subsubsection{PlotFunc}
\label{uwinplot-PlotFunc}
\index[proc]{PlotFunc}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure PlotFunc(Canvas : TCanvas; Func : TFunc; Xmin, Xmax : Float; Npt, CurvIndex : Integer);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Plots a function. Input parameters: Func = function to be plotted; Xmin, Xmax = abscissae of 1st and last point to plot; Npt = number of points; CurvIndex = index of curve parameters (Width, Style, Color).
	
	The function must be programmed as : function Func(X : Float) : Float;
	
\end{itemize}
\subsubsection{WriteLegend}
\label{uwinplot-WriteLegend}
\index[proc]{WriteLegend}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure WriteLegend(Canvas : TCanvas; NCurv : Integer; ShowPoints, ShowLines : Boolean);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Writes legends for all curves.
	
	NCurv: number of curves (1 to MaxCurv) ShowPoints: for displaying points ShowLines: for displaying lines.
	
\end{itemize}
\subsubsection{WriteLegendSelect}
\label{uwinplot-WriteLegendSelect}
\index[proc]{WriteLegendSelect}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure WriteLegendSelect(Canvas : TCanvas; NSelect : Integer; Select : TIntVector; ShowPoints, ShowLines : Boolean);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Writes legends for selected curves.
	
	NSelect: number of selected curves; Select : indices of selected curves.
	
\end{itemize}
\subsubsection{ConRec}
\label{uwinplot-ConRec}
\index[proc]{ConRec}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			procedure ConRec(Canvas : TCanvas; Nx, Ny, Nc : Integer; X, Y, Z : TVector; F : TMatrix);}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Contour plot. Adapted from Paul Bourke, Byte, June 1987.\\ \href{http://paulbourke.net/papers/conrec/}{http://paulbourke.net/papers/conrec/}
	
	Input parameters: Nx, Ny = number of steps on Ox and Oy; Nc = number of contour levels; X[0..Nx], Y[0..Ny] = point coordinates; Z[0..(Nc {-} 1)] = contour levels in increasing order; F[0..Nx, 0..Ny] = function values, such that F[I,J] is the function value at (X[I], Y[J]).
	
\end{itemize}
\subsubsection{Xpixel}
\label{uwinplot-Xpixel}
\index[proc]{Xpixel}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function Xpixel(X : Float) : Integer;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Converts user abscissa X to screen coordinate.
	
\end{itemize}
\subsubsection{Ypixel}
\label{uwinplot-Ypixel}
\index[proc]{Ypixel}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function Ypixel(Y : Float) : Integer;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Converts user ordinate Y to screen coordinate.
	
\end{itemize}
\subsubsection{Xuser}
\label{uwinplot-Xuser}
\index[proc]{Xuser}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function Xuser(X : Integer) : Float;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Converts screen coordinate X to user abscissa.
	
\end{itemize}
\subsubsection{Yuser}
\label{uwinplot-Yuser}
\index[proc]{Yuser}
\begin{itemize}\item[\declarationitem{Declaration}\hfill]
	\begin{flushleft}
		\code{
			function Yuser(Y : Integer) : Float;}
		
	\end{flushleft}
	
	\par
	\item[\descriptiontitle{Description}]
	Converts screen coordinate Y to user ordinate.
\end{itemize}
\printindex[types]
\printindex[const]
\printindex[proc]
\printindex
\end{document}
