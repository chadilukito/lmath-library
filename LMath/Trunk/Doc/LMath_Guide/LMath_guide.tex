\documentclass[12pt,a4paper,oneside]{report}
\usepackage{listings}
\lstset{
	language=[borland6]pascal,
	morekeywords={procedure}
	basicstyle=\selectfont\ttfamily,
	keywordstyle=\bfseries,
	columns=fullflexible
}
\usepackage[top=1in, bottom=1in, left=1.5in, right=1.0in]{geometry}
\usepackage[compact]{titlesec}
\titlespacing*{\chapter}{0pt}{-60pt}{10pt}
\titleformat{\chapter}[display]{\normalfont\LARGE\bfseries}{\chaptertitlename\ \thechapter}{10pt}{}
\titleformat{\section}[hang]{\normalfont\Large\bfseries}{\thesection\ }{0pt}{}
\titleformat{\subsubsection}[block]{\normalfont\large\bfseries} % format for label and text
{} %label (may be counter: \thesection)
{0pt} % distance between label and text, 0 if no label
{}
\titleformat{\paragraph}[runin]{\normalfont\normalsize\bfseries}{}{0pt}{}
\usepackage{amsmath}
\usepackage{xcolor}
\definecolor{darkblue}{RGB}{0,0,128}
\usepackage[pdftex]{hyperref}
\hypersetup{
	colorlinks   = true, %Colours links instead of ugly boxes
	urlcolor     = darkblue, %Colour for external hyperlinks
	linkcolor    = darkblue, %Colour of internal links
	citecolor	 = darkblue, %Colour of citations
	pdftitle	 ={LMath New functions},
	pdfauthor	 ={Viatcheslav Nesterov},
	pdfsubject	 ={Guide for new fuctions in LMath library},
	pdfkeywords	 ={pascal, object pascal, mathematics, math, library, science, programming, scientific programming}
}
\newcommand{\euler}{\mathrm{e}}
\newcommand{\keyword}[1]{\textbf{#1}}
\newcommand{\declarationitem}[1]{\textbf{#1}}
\newcommand{\descriptiontitle}[1]{\textbf{#1}}
\newcommand{\code}[1]{\texttt{#1}}
\newenvironment{ecode}
{	\vskip 6pt
	\ttfamily
	\hangindent=\parindent
	\parindent=0pt
 	\ttfamily
}
{	\rmfamily 
	\noindent
	\\
}
  
\begin{document}
\title{LMath 0.5: mathematical library for\\ Free Pascal --- Lazarus\\
{\Large User\'{}s Guide to functions and behaviour changed after DMath}}
\author{Viatcheslav V. Nesterov}
\maketitle
\newpage
\label{toc}\tableofcontents
\newpage
% special variable used for calculating some widths.
\newlength{\tmplength}
\chapter{General Operations}
\section{Installation and use of the library}
First, download LMath\_and\_Components.zip from the official site of the program. 
You can download and use trunk of SVN repository to study and research the latest development, but I do not guarantee that code in trunk was properly tested or to that end that it is a working code at all. 

LMath is organized as a set of Lazarus packages. Their complete list is located in the Reference Guide. To install, copy directory structure contained in LMath\_and\_Components.zip on your hard drive and compile all .lpk files. There is no need to install packages from LMath in the lazarus IDE. If you plan to use LMComponents, LMComponents.lpk must be installed. To use the library in your programs, add needed packages to the requirements of your project and, of course, necessary units in your \code{uses} clause.

Before LMath ver. 0.5, names of both packages and units began with ''u'', since 0.5 names for packages begin with ''lm''. 

Unlike DMath, no special means for compilation of the LMath as a shared library is provided. I find it unlikely that anybody would use this library in a language other then pascal, and in pascal it is always more convenient to have a single executable than an executable and required external libraries.
\section{Error handling}
In DMath, success or failure of a function was defined by a numeric error code, which could be checked by call of \code{MathErr} function.
However, numeric error code is not particularly informative, especially for end users. Therefore, in LMath numeric error codes are supplemented with text error messages. With this purpose, array of strings, corresponding to error coded was definedin \code{uErrors} unit. List of standard error codes and messages can be found in the \textit{uErrors} section in \hyperref{file:LMath05.pdf}{}{}{LMath User\'{}s Reference}. Additionally, a user can define own error codes and messages and set them by call of
\begin{lstlisting}
procedure SetErrCode(ErrCode : Integer; EMessage : string = '');
\end{lstlisting}
If \code{EMessage} parameter remains empty and ErrCode is a standard error code, than corresponding message from standard list is set. Otherwise, error message is set to \code{EMessage}. Error code can be retrieved by call of
\begin{lstlisting}
function MathErr : Integer;
\end{lstlisting}
and text message with
\begin{lstlisting}
function MathErrMessage : string;
\end{lstlisting}
Note that both functions must be called immediately after the call to mathematical function, before they could be rewritten by next call.
\section{NAN and tests for approximate equality}
Due to rounding errors, testing floating numbers for exact equality is unreliable. Therefore, LMath defines following functions for approximate equality:
\begin{lstlisting}
function IsZero(F: Float; Epsilon: Float = -1): Boolean;\\
function SameValue(A, B: Float; epsilon:float): Boolean; overload;\\
function SameValue(A,B:Float):boolean; overload;
\end{lstlisting}
\code{IsZero} returns true if $\left| F \right| < epsilon$. If parameter \code{epsilon} is not used, it is set to \code{MachEp/8}. First of \code{SameValue} functions returns true if $\left| A - B \right| < epsilon$. Third function is most sophisticated, it uses comparison with epsilon scaled to the scale of compared numbers. 

Besides that,constant \code{NAN} (not a number) is defined and function \code{IsNAN}. In LMath it is used to represent missing values in some statistical functions.
\section{Overloaded general functions and procedures}
In DMath, there was a family of functions \code{Dim*Vector} and \code{Dim*Matrix} for allocation of arrays of different base types. In LMath, procedures \code{DimVector} and \code{DimMatrix} are overloaded for different types:
\begin{lstlisting}
procedure DimVector(out V : TVector; Ub : Integer); overload;
procedure DimVector(out V : TIntVector; Ub : Integer); overload;
procedure DimVector(out V : TCompVector; Ub : Integer); overload;
procedure DimVector(out V: TRealPointVector; Ub: Integer); overload;
procedure DimVector(out V : TBoolVector; Ub : Integer); overload;
procedure DimVector(out V : TStrVector; Ub : Integer); overload;
	
procedure DimMatrix(out A : TMatrix; Ub1, Ub2 : Integer); overload;
procedure DimMatrix(out A : TIntMatrix; Ub1, Ub2 : Integer); overload;
procedure DimMatrix(out A : TCompMatrix; Ub1, Ub2 : Integer); overload;
procedure DimMatrix(out A : TBoolMatrix; Ub1, Ub2 : Integer); overload;
procedure DimMatrix(out A : TStrMatrix; Ub1, Ub2 : Integer); overload;
\end{lstlisting} 
Similarly, following general procedures for scalars are defined:
\begin{lstlisting}
function Min(X, Y : Float) : Float; overload;
function Min(X, Y : Integer) : Integer; overload;
function Max(X, Y : Float) : Float; overload;
function Max(X, Y : Integer) : Integer; overload;
function Sgn(X : Float) : Integer; overload;
function Sgn(X : integer) : integer; overload; 
function Sgn0(X : Float) : Integer; overload; 
function Sgn0(X : integer) : integer; overload; 
function DSgn(A, B : Float) : Float;
function Sign(X: Float):integer; inline;
function IsNegative(X: float):boolean; overload;
function IsNegative(X: Integer):boolean; overload;
function IsPositive(X: float):boolean; overload;
function IsPositive(X: Integer):boolean; overload; 
procedure Swap(var X, Y : Float);   overload; inline;
procedure Swap(var X, Y : Integer); overload; inline;
\end{lstlisting}
\code{Function Sign} has the same semantic as \code{Sgn0} and was introduced for compatibility with Math unit.
\section{New Operators}
Free Pascal allows to overload operators. LMath took advantage of this feature. It defines operator \code{**} for exponentiation for \code{Float} in \code{integer} degree and \code{Float} in \code{Float} degree.

For complex numbers (type \code{complex}) operators \code{+,-,*,/, =} (comparison) are defined for \code{complex} and \code{float} in all meaningful combinations. This part is largely based on ideas from uComplex unit by Pierre MÃ¼ller.

Operators defined for work with other structural types will be discussed in the next chapter where corresponding types are discussed.

\chapter{New Types}
\section{TInterval}
Type \code{TInterval} defines an interval on a numerical axis:
\begin{lstlisting}
TInterval = record
  Lo:float;
  Hi:float;
  function Length:float;
end;
\end{lstlisting}
Function \code{Length} returns the length of this interval, that is, $Hi-Lo$.
This type is useful for example in the tasks of signar processing where it can represent a window in finite impulse response filters. Another use is presentation of a fragment of axis shown on a screen or printout.

Following functions and procedures are defined over this type:
\begin{lstlisting}
function IntervalsIntersect(Lo1, Hi1, Lo2, Hi2:Float):boolean; overload;
\end{lstlisting}
Returns true if intervals [Lo1; Hi1] and [Lo2; Hi2] intersect.
\begin{lstlisting}
function IntervalsIntersect(Lo1, Hi1, Lo2, Hi2:Integer):boolean;\\
function IntervalsIntersect(Interval1, Interval2:TInterval):boolean;
\end{lstlisting}	
Returns true if intervals [Lo1; Hi1] and [Lo2; Hi2] intersect.
\begin{lstlisting}
function Contained(ContainedInterval,ContainingInterval:TInterval):boolean;
\end{lstlisting}	
Returns true if intervals Interval1 and Interval2 intersect: \\
 \code{(ContainedInterval.Lo > ContainingInterval.Lo) and \\
 (ContainedInterval.Hi < ContainingInterval.Hi)}.
\begin{lstlisting}
function Intersection(Interval1, Interval2:TInterval):TInterval;
\end{lstlisting}	
Returns intersection of Interval1 and Interval2. If they have no intersection, result is (0;0)
\begin{lstlisting}
function Inside(V:Float; AInterval:TInterval):boolean; overload;
\end{lstlisting}	
True if V is inside AInterval.
\begin{lstlisting}
function Inside(V:float; ALo, AHi:float):boolean; overload;
\end{lstlisting}	
True if V is inside (ALo, AHi) (similar to Math.InRange)
\begin{lstlisting}
function IntervalDefined(AInterval:TInterval):boolean;
\end{lstlisting}	
True if AInterval.Lo < AInterval.Hi
\begin{lstlisting}
function DefineInterval(ALo,AHi:Float):TInterval;
\end{lstlisting}	
Constructs TInterval from ALo and AHi.
\begin{lstlisting}
procedure MoveInterval(V:float; var AInterval:TInterval);
\end{lstlisting}	
Move interval by a value (it is added to both Lo and Hi)
\begin{lstlisting}
procedure MoveIntervalTo(V:Float; var AInterval:TInterval);
\end{lstlisting}	
Move interval to a value (Lo is set to this value, Hi adjusted such that length remains constant).
\section{TRealPoint and TRealPoints}
\chapter{Work with arrays}
Here TRealPointVector as well as uVecUtils, uVecFunc and uVecHelpers. Mention LBound, HBound to deal with different array bases (0 or 1 as fortran inheritance.)
	  
\end{document}